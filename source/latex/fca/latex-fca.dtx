% \iffalse meta-comment
% vim: textwidth=75
%<*internal>
\iffalse
%</internal>
%<*readme>
        |
-------:| -----------------------------------------------------------------
    fca:| Typesetting Formal Concept Analysis with LaTeX
 Author:| Bernhard Ganter
        | Tobias Schlemmer <keinstein@users.sf.net>
 E-mail:| keinstein@users.sf.net
License:| Released under the LaTeX Project Public License v1
    See:| http://www.latex-project.org/lppl.txt


Short description:

Formal Concept Analysis (FCA) is a field of mathematics based on the
theory of ordered sets and complete lattices, with applications to
data analysis and knowledge processing. To simplify typesetting of
FCA-related text, \fcastyle  provides two environments and some simple
macros. The two environments are

  - cxt     : for typesetting small formal contexts as cross-tables, and
  - diagram : for making line diagrams of concept lattices.
              This environment may be of some interest for other
              surposes as well, since it can also be used for
              arbitrary ordered sets and graphs.

A list of macros is given in an extra section.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip

\iffalse

 This program is provided under the terms of the                             %
 LaTeX Project Public License distributed from CTAN                          %
 archives in directory macros/latex/base/lppl.txt.                           %
\ else

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

\fi

\preamble
 latex-fca.dtx
 Copyright ℂ 2022 Ernst-Schröder-Zentrum
                  für Begriffliche Wissensverarbeitung
 Authors: Bernhard Ganter
          Tobias Schlemmer

 This program is provided under the terms of the
 LaTeX Project Public License distributed from CTAN
 archives in directory macros/latex/base/lppl.txt.

 This work is "maintained" (as per LPPL maintenance status) by
 Tobias Schlemmer <keinstein@users.sf.net>.

 This work consists of the files
   latex-fca.dtx and
   latex-fca.ins

 and the derived files
   fca.sty,
   formula0.cxt,
   formula1.cxt.

\endpreamble

\askforoverwritefalse

\usedir{tex/latex/fca}
\generate{%
        \file{fca.sty}{%
                \usepreamble\defaultpreamble
                \usepostamble\defaultpostamble
                \from{latex-fca.dtx}{fca.sty,cxtinput.sty,package}}
            }
\usedir{tex/generic/fca}
\generate{%
        \file{tikzlibraryfca.code.tex}{%
                \usepreamble\defaultpreamble
                \usepostamble\defaultpostamble
                \from{latex-fca.dtx}{tikz,package}}
            }
\usedir{doc/latex/fca}
\generate{%
  \file{formula0.cxt}{
    \nopreamble\nopostamble
    \from{latex-fca.dtx}{formula0.cxt}}
  \file{formula1.cxt}{
    \nopreamble\nopostamble
    \from{latex-fca.dtx}{formula1.cxt}}
  \file{notikzfcadoc.tex}{%
    \usepreamble\defaultpreamble
    \usepostamble\defaultpostamble
    \from{latex-fca.dtx}{notikzdriver}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/fca}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/fca}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
% \fi
% \iffalse
%<*package>
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%</package>
% \fi
% \iffalse
% Doc-Source file to use with LaTeX2e
% Copyright (C) 2022 Tobias Schlemmer, all rights reserved.
% \fi
% \iffalse
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<*driver>
\ProvidesFile{latex-fca.dtx}
%</driver>
%<notikzdriver>\ProvidesFile{notikzfcadoc.tex}
%<fca.sty>\ProvidesPackage{fca}
%<tikz>\ProvidesFile{tikzlibraryfca.code.tex}
%<*package|driver|notikzdriver>
    [2022/09/17 v3.0
%</package|driver|notikzdriver>
%<*fca.sty|driver|notikzdriver>
Formal Concept Analysis macros]
%</fca.sty|driver|notikzdriver>
%<tikz> TikZ support for Formal concept Analysis]
%<*driver|notikzdriver>
% In the DocInput part this code is blocked by the preceeding
% \backslash iffalse.
% However, TeX scans for all \backslash if statements in a fast
% forward mode in order to find nested ifs. Thus it also sees
% the following statement, if it is written in assembled form.
% That's why we use |csname|, here.
\expandafter\newif\csname iffcatikzdoc\endcsname
%</driver|notikzdriver>
%<notikzdriver>  \fcatikzdocfalse
%<*driver>
% Check whether we should disable \TikZ for documentation generation
\fcatikzdoctrue
%</driver>
%<*driver|notikzdriver>
% Hack around the convention to use the vertical bar for macro names.
% This clashes with the tabular environment.
\edef\catcodebarlatex{\noexpand\catcode`|=\the\catcode`|\relax}%
\documentclass[a4paper]{ltxdoc}
\def\catcodebarltxdoc{\noexpand\catcode`|=\active\relax}%
%\usepackage{a4}
\usepackage{dtxdescribe}
% |\tikz| gets overwritten when we load TikZ later. So we have to save
% it somehow else
\newcommand\TikZ{Ti\emph{k}Z}
%\let\TikZ\tikz
\newcommand\PGF{\acro{PGF}}
\usepackage{iftex}
\makeatletter
\@ifundefined{ifluatex}{
  \usepackage{ifluatex}
}{}
\makeatother
\iffcatikzdoc
  \usepackage{tikz}
  \ifLuaTeX
    \usetikzlibrary{luamath}
  \fi
  \usetikzlibrary{fca}
\else
  \ifLuaTeX
    \usepgflibrary{luamath}
  \fi
  \usepackage{fca}
\fi
%
\let\fcadtxexample\dtxexample
\makeatletter
\def\fca@dtxexample#1#2{%
  \typeout{Example: #2}%
  \tsdtxexample#1{#2}%
}
\def\fcadtxexample{\@ifstar{\fca@dtxexample*}{\fca@dtxexample{}}}
\makeatother

% we hack the cxt environment so that it deactivates the vertical
% bar. Otherwise it would break vertical column rules in context.
% Since \LaTeXe from 2020-08-21 we can use hooks for that
%
%
\iftrue
  \NeedsTeXFormat{LaTeX2e}[1999/12/01]
  \expandafter\def\expandafter\cxt
  \expandafter{\expandafter\catcodebarlatex\cxt}%
  \expandafter\def\expandafter\endcxt
  \expandafter{\endcxt\catcodebarltxdoc}%
\else
  \NeedsTeXFormat{LaTeX2e}[2020/08/21]
  \AddToHook{env/cxt/before}{%
    \catcodebarlatex
  }
  \AddToHook{env/cxt/after}{%
    \catcodebarltxdoc
  }
\fi

% We want to keep the version information of the whole package at one
% and the same place in the file. So we extract the version
% information from the version string.
\makeatletter
\newcommand\fca@parseversion{}
\def\fca@parseversion#1 #2 #3\fca@parseversion{%
  \def\fcacurrentversiondate{#1}%
  \def\fcacurrentversionversion{#2}%
  \def\fcacurrentversiondescription{#3}%
}
\newcommand\fcaparseversion[1]{%
  \edef\@tempa{\noexpand\fca@parseversion\csname ver@#1\endcsname{}
    \noexpand\fca@parseversion}%
  \@tempa
}
\makeatother

% \selectlanguage{english}
%
\usepackage{iftex}
\ifLuaTeX
\else
  \usepackage[utf8]{inputenc}
  \usepackage[T1]{fontenc}
\fi
\usepackage[english]{babel}
\usepackage{lmodern}
\usepackage{xcolor}
% \usepackage[%
%   colorlinks=false,
%   allbordercolors={0.9 0.9 0.9},
%   breaklinks=true,
%   ]{hyperref}

\RequirePackage{stmaryrd}
\usepackage[numbered]{hypdoc}
\hypersetup{
   pdfauthor = {Bernhard Ganter, Tobias Schlemmer},
   pdfkeywords = {FCA LaTeX sytle diagrame context},
   pdftitle = {fca.sty – LaTeX macros for Formal Concept Analysis},
   pdfsubject = {LaTeX style file for typesetting formal contexts and
     concept lattices}
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\def\fcastyle{\texttt{fca.sty}\xspace}
%<*driver>
\fcaparseversion{\jobname.dtx}
%</driver>
%<notikzdriver>\fcaparseversion{\jobname.tex}
\title{\fcastyle\protect\\\LaTeX--macros for Formal Concept Analysis\protect\\
  \fcacurrentversionversion}
\author{Bernhard Ganter\thanks{TU Dresden, Ernst-Schröder-Zentrum
    f\"ur Begriffliche Wissensverarbeitung}\protect\\
  Tobias Schlemmer\thanks{TU Dresden}}
\date{\fcacurrentversiondate}
\begin{document}
\errorcontextlines=1000\relax
\edef\latexfcajobname{\jobname}%
\edef\latexfcasourcefile{\detokenize{latex-fca}}%
\ifx\latexfcajobname\latexfcasourcefile
  \DocInput{latex-fca.dtx}
\else
  \DocInput{../../../source/latex/fca/latex-fca.dtx}
\fi
\end{document}
%</driver|notikzdriver>
%<*fcadoc>
% \fi
% \maketitle
% \begin{abstract}
% \FCA is a field of mathematics based on the theory of ordered sets and complete lattices, with applications to data analysis and knowledge processing.
% To simplify typesetting of FCA-related text, \fcastyle  provides two
% environments and some simple macros. The two environments are
% \begin{description}
% \item[cxt] for typesetting small formal contexts as cross-tables, and
% \item[diagram] for making line diagrams of concept lattices. This environment
%   may be of some interest for other purposes as well, since it can also be
%   used for ordered sets and graphs.
% \end{description}
% A list of \textbf{macros} is given in Section~\ref{sec:macros}
% below.
% \medbreak\par\noindent
% A recent version of \texttt{fca.sty} should be available from
% \begin{center}
%  \url{https://github.com/keinstein/latex-fca}
% \end{center}
% \end{abstract}
%
% \tableofcontents
%
% \section{Loading the package}
%
% The package |fca| is loaded by adding
% \begin{verbatim}\usepackage{fca}\end{verbatim}
% to the preamble.
%
% There is a package option, \texttt{compat}, to be used for files
% which were written for older versions up to Version 2.1 of
% \texttt{fca.sty}. See Section~\ref{subsec:compat} for details.
%
% The \texttt{newdrawline.sty} package is no longer needed.
%
% \section{Typesetting formal contexts with \env{cxt}}
% Formal contexts can be typeset using the |cxt| environment. What
% this (very simple) environment does can be guessed from an example.
% \begin{dtxexample}{A formal context.}
%   \begin{cxt}
%     \cxtName{Formula 1}
%   %
%     \att{1.}
%     \att{2.}
%     \atr{disqualified}
%   %
%     \obj{x..}{Verstappen}
%     \obj{.x.}{Hamilton}
%     \obj{.xx}{Leclerc}
%   \end{cxt}
% \end{dtxexample}
% \subsection{Basic usage of the \env{cxt} environment}
% \DescribeEnv{cxt}
%
% \DescribeMacro{\begin\{cxt\}} begins typesetting a formal context table.
%
% The commands within a \env{cxt} environment are
%
% \DescribeMacro{\cxtName}\marg{text}  Define the text for the upper
% left cell of the table. Optional. The default is no text.
%
% \DescribeMacro{\att}\marg{text} Give an attribute name. These names
% are processed in the order in which they are given. Attribute names
% given after an |\obj|  command are ignored.
%
% \DescribeMacro{\atr}\marg{text} Same as |\att|, but with rotated text.
%
% \DescribeMacro{\obj}\marg{text}\marg{text} Give an object's name and
% its incidence vector, consisting of dots and `x'es. The incidences
% come first, for better alignment. The length of each incidence
% vector must be the number of attributes.
%
% Each  instance of |\obj| is directly translated to a row of the
% |tabular|-environment. It is therefore possible to mix  |\obj|
% commands with usual  |tabular|-commands.
%
% \DescribeMacro{\begin\{cxt\}} Completes typesetting the context table.
%
% \texttt{cxt} can handle an arbitrary number of attributes.
%
% \subsubsection{Other predefined entries}
% An incidence vector for an object consists of dots and crosses
% (``\texttt{x}'' of ``\texttt{X}'').
% The arrow relations may also be noted. Instead of \texttt{x} and \texttt{.},
% type \texttt{d} (for ``down''), \texttt{u} (``up''), or \texttt{b} (``both'').
% In the following example, we also change the colour of these symbols:
%
% \begin{dtxexample}{Some predefined context characters, colour changed.}
% \begin{cxt}%
% \renewcommand{\fcaCxtArrowStyle}{\footnotesize\color{red}}%
% \cxtName{Formula 1}%
% \att{1.}%
% \att{2.}%
% \atr{disqualified}%
% \obj{xbd}{Verstappen}
% \obj{uxb}{Hamilton}
% \obj{bxx}{Leclerc}
% \end{cxt}
% \end{dtxexample}
%
% The default for |\fcaCxtArrowStyle| is |\footnotesize|. In the above
% example we have changed it using |\renewcommand| in order to make the
% arrows red. The default colour is black.
%
% The digits 0 to 9 may be used as well.
%
% \subsection{Advanced usage of the \env{cxt} environment}
% \subsubsection{Defining context characters}
%
% You can define your own markers using |\fcaNewContextChar|. It
% works like |\newcommand| but defines a single character. For
% single signs use |\cxtrlap| in order to give it an apropriate
% size as in the following example:
% \bigbreak
% \textcolor{red}{Die Zeile
% \texttt{$\backslash$fcaProvideContextChar\{.\}\{ignored\}\%}\ im
% folgenden Beispiel verstehe ich nicht.}
% \begin{dtxexample}{(Re-)defining context characters.}
% \begin{cxt}%
% \fcaNewContextChar{v}{\cxtrlap{$\vee$}}%
% \fcaProvideContextChar{\wedge}{\cxtrlap{$\wedge$}}%
% \fcaProvideContextChar{.}{ignored}%
% \fcaRenewContextChar{x}{\cxtrlap{$i$}}%
% \cxtName{Formula 1}%
% \att{1.}%
% \att{2.}%
% \atr{disqualified}%
% \obj{xuv}{Verstappen}
% \obj{\wedge xb}{Hamilton}
% \obj{dx.}{Leclerc}
% \end{cxt}
% \end{dtxexample}
%
% There are other possibilities. You may define a marker with a single
% argument that typesets its argument. There also is a macro
% |\freeobj| that takes a tabular row  as argument instead of the
% usual markers.  The following example illustrates these:
%
% \noindent\begin{minipage}[t]{.45\textwidth}
% \textit{\footnotesize \ Code:}
% \begin{verbatim}
% \begin{cxt}%
% \fcaNewContextChar{w}[1]{#1}%
% \cxtName{Formula 1}%
% \att{1.}%
% \att{2.}%
% \atr{disqualified}%
% \obj{5bw1}{Verstappen}
% \obj{w2xw{77}}{Hamilton}
% \freeobj{1&2&3}{Leclerc}
% \end{cxt}
% \end{verbatim}
% \end{minipage}
% \hfill
% \begin{minipage}[t]{.40\textwidth}
% \textit{\footnotesize \ Result:}\par\noindent
% \begin{cxt}%
% \fcaNewContextChar{w}[1]{\cxtrlap{#1}}%
% \cxtName{Formula 1}%
% \att{1.}%
% \att{2.}%
% \atr{disqualified}%
% \obj{5bw1}{Verstappen}
% \obj{w2xw{77}}{Hamilton}
% \freeobj{\cxtrlap{1}&2&3}{Leclerc}
% \end{cxt}
% \end{minipage}
%
%
% \subsubsection{\env{cxt} alignment}
%
% |cxt| takes an optional alignment parameter, which can be one of
% \texttt{t, c} or \texttt{b}. It is passed to the tabular
% environment (see there for further documentation).
%
% \begin{dtxexample}{Alignment parameter for a \env{cxt}-environment}
%   \makebox{%
%   \begin{cxt}[t]
%     \cxtName{Formula t}
%     %
%     \att{1.}
%     \att{2.}
%     \atr{disqualified}
%     %
%     \obj{x..}{Verstappen}
%     \obj{.x.}{Hamilton}
%     \obj{.xx}{Leclerc}
%   \end{cxt}\quad%
%   \begin{cxt}[c]
%     \cxtName{Formula c}
%     %
%     \att{1.}
%     \att{2.}
%     \atr{disqualified}
%     %
%     \obj{x..}{Verstappen}
%     \obj{.x.}{Hamilton}
%     \obj{.xx}{Leclerc}
%   \end{cxt}\quad%
%   \begin{cxt}[b]
%     \cxtName{Formula b}
%     %
%     \att{1.}
%     \att{2.}
%     \atr{disqualified}
%     %
%     \obj{x..}{Verstappen}
%     \obj{.x.}{Hamilton}
%     \obj{.xx}{Leclerc}
%   \end{cxt}
%   }
% \end{dtxexample}
%
%
%
% \subsubsection{Including Burmeister context files}
%
% The package |fca| allows to use context files in Burmeister format
% (which usually have the \texttt{.cxt} file name extension) to be
% included directly in a \LaTeX{} document. Its usage is as simple as
% possible.
%
% \begin{dtxexample}{Including a Burmeister context file}
% \begin{cxt}%
% \cxtinput{formula1.cxt}%
% \end{cxt}
% \end{dtxexample}
%
% The name of the context can be overwritten by using |\cxtName|
% inside the \env{cxt} environment. \textcolor{red}{Funktioniert nicht!}
% \begin{dtxexample}{Overwriting the context name}
% \begin{cxt}
% \cxtName{Formula 2}%
% \cxtinput{formula1.cxt}%
% \end{cxt}
% \end{dtxexample}
%
% To get non-rotated attribute names, redefine the \texttt{atr} command
% as in the following example:
% \begin{dtxexample}{Including contexts with unrotated attributes}
% \begin{cxt}[b]%
% \renewcommand{\atr}{\att}%
% \cxtinput{formula0.cxt}%
% \end{cxt}\quad
% \begin{cxt}[b]
% \cxtName{Formula 2}%
% \cxtinput{formula0.cxt}%
% \end{cxt}
% \end{dtxexample}
%
% \section{Drawing lattices with \env{diagram}}
% The \texttt{diagram} environment helps typesetting diagrams of concept
% lattices, but can be used for ordered sets and graphs as well. Again we start
% with a small example (for which we set |\unitlength 1.2mm|):
%
% \begin{dtxexample}{A lattice diagram}
% {\unitlength 1.2mm
% \begin{diagram}
%   \Node(1)(20,10)
%   \Node(2)(35,20)
%   \Node(3)(5,30)
%   \Node(4)(35,40)
%   \Node(5)(20,50)
%   \Edge(1)(2)
%   \Edge{1}{3}
%   \Edge{2}{4}
%   \Edge{3}{5}
%   \Edge{4}{5}
%   \leftAttbox(3){1.}
%   \rightAttbox(2){disqualified}
%   \rightAttbox(4){2.}
%   \leftObjbox(3){Verstappen}
%   \rightObjbox(2){Leclerc}
%   \rightObjbox(4){Hamilton}
% \end{diagram}}
% \end{dtxexample}
%
% \subsection{Basic usage of the \env{diagram} environment}
% \DescribeEnv{diagram}
%
% \DescribeMacro{\begin\{diagram\}} begins a PGF-picture.
% Unlike the previous versions, the width and height of the diagram no
% longer need to be specified. The old syntax
%
% |\begin{diagram}{width}{height}|
%
% is still supported and determines the bounding box, which is                %
% otherwise calculated automatically.
%
% A major advantage of using PGF-pictures is that we can use the many
% possibilities offered by PGF, even without knowing much about PGF.
% The |diagram| environment and its macros allow  optional parameters,
% e.g. for color, line thickness, etc. These will be described in
% Section~\ref{subsec:diagram-adv}.
%
% The commands within a \env{diagram} environment (in their basic form) are
%
% \DescribeMacro{\Node}\parg{nodenumber}\parg{xpos,ypos}
% Puts a circle at position \texttt{(xpos,ypos)} of the picture.
% These circles are drawn when |\end{diagram}| is invoked. The default
% diameter of the circles is 4 (times |\unitlength|). It can be changed
% (for all circles) with |\fcaCircleSize{}|. The argument must be an integer.
% The node numbers must be different, consecutive between 0 and 51, but need not
% necessarily be given in ascending order.
%
% The old syntax |\Node{nodenumber}{xpos}{ypos}| is also supported.
%
% \DescribeMacro{\Edge}\marg{nodenumber1}\marg{nodenumber2}
% Puts a line between the two nodes with the given numbers. These must
% have been declared earlier with a |\Node|--command.
% The |\Edge|--command is executed immediately.
%
% \DescribeMacro{\leftAttbox}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\centerAttbox}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\rightAttbox}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\leftObjbox}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\centerObjbox}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\rightObjbox}\parg{nodenumber}\marg{text}
%
% These are used to put
% text to diagram nodes. The |Attbox|--commands place the text above the
% corresponding node, the |Objbox| below. Similarly, the text can be placed
% to the left, be centered, or be placed to the right of the labelled node.
%
% For a better positioning of the label text an optional shift can be
% specified. For example,
%
% |\rightObjbox(4)(3,5){Hamilton}|
%
% moves the object label ``Hamilton'' at node number 4 by
% 3~|\unitlegth| in x-direction and by 5~|\unitlength| in y-direction.
%
% The old syntax |\rightObjbox{nodenumber}{xoffset}{yoffset}{labeltext}|
% is also supported. However, there is a small difference: while in
% the old syntax the shift |{xoffset}{yoffset}| is understood relative
% to the node, the shift |(xoffset,yoffset)| is interpreted relative
% to the diagram. This means that, e.g., |\leftAttbox{4}{3}{5}{text}|
% corresponds to |\leftAttbox(4)(-3,5){text}|.
%
% \DescribeMacro{\end\{diagram\}} This concludes the diagram. The circles
%  representing the nodes are drawn and filled with white, unless
%  specified otherwise.
%
% A helpful command when fine tuning a diagram is
%
% \DescribeMacro{\Numbers} Puts numbers inside circles.  While working on a
%  diagram it can be helpful to have a picture with numbered nodes.
%
% \begin{dtxexample}{Plotting numbers inside of nodes}
%   \fbox{\unitlength .7mm
%   \begin{diagram}{40}{55}
%     \Numbers
%     \Node{5}{20}{10}
%     \Node{6}{35}{20}
%     \Node{4}{5}{30}
%     \Node{8}{35}{40}
%     \Node{7}{20}{50}
%   \end{diagram}}
% \end{dtxexample}
%
% We recommend to remove the |\Numbers|--command when the diagram is
% ready. In most cases it is not a good idea to put text inside the
% nodes of a diagram.
%                                                                   %
% \DescribeMacro{\NoNumbers} can be used to exclude individual circles
% from the numbering.
%
%
% \subsection{Advanced usage of the \env{diagram} environment}
% \label{subsec:diagram-adv}
% The connection with PGF and TikZ results in many design tools that
% cannot be presented in detail here. We will discuss three simple
% possibilities, although not in all details: The use of optional
% parameters, setting global parameters and defining own styles for
% diagrams.
%
% \subsubsection{Optional parameters}
%
% All macros of the \env{diagram} environment, except for
% |\end{diagram}|, allow optional parameter. These must be specified
% within square brackets, as in the following example,
%
% |\Node[draw=red, fill=blue](4)(20,10)|
%
% which specified that a red circle, filled with blue, is to be drawn
% at position (20,10), representing the node with nodenumber 4.
%
% The impatient reader my infer some of the possibilities from the
% next example.
%
% \begin{dtxexample}{A \env{diagram} with some optional parameters}
% {\unitlength 1.2mm
% \definecolor{darkgreen}{rgb}{0.05,0.5,0.}
% \begin{diagram}
%  \Node[draw=red, fill=green](1)(20,10)
%  \Node[fill=black, radius=2mm](2)(35,20)
%  \Node[/tikz/opacity=0.3,fill=red](3)(5,30)
%  \Node[fill=darkgreen](4)(35,40)
%  \Node(5)(20,50)
%  {\color{red}\Edge(1)(2)}
%  \Edge[draw=blue,dotted](1)(3)
%  \Edge(2)(4)
%  \Edge[draw=green](3)(5)
%  \Edge(4)(5)
%   \leftAttbox(3){1.}
%   \rightAttbox(2){disqualified}
%   \rightAttbox(4){2.}
%   \leftObjbox(3){Verstappen}
%   \rightObjbox(2){Leclerc}
%   \rightObjbox(4){Hamilton}
% \end{diagram}}
% \end{dtxexample}
%
% \subsubsection{Global parameters}
%
% An example of a parameter for \texttt{fca.sty} is text width. It
% affects the type and size of the label boxes.
%
% When |text width| is set to a length, the text of the label is put
% in a |\parbox|. It can be broken into several lines using |\\|. The
% width of the |\parbox| is the value of the |text width| parameter.
% It is unset by default, resulting in a one-line box (i.e. hbox) for
% the label. In this case the width of the box is automatically detected.
%
% Label boxes are framed with the \texttt{draw} option. Their
% background color can be set with \texttt{fill}.
%
% Setting |text width| to a length can either be done as an optional
% parameter to the diagram, such as
%
% |\begin{diagram}[text width=6mm]|
%
%   or globally (for all diagrams) by
%
%   |\fcaset{text width=6mm}|
%
% or for single nodes only, again as an optional parameter.
%
% {\unitlength .7mm
% \begin{dtxexample}{Node labels}
%   \begin{diagram}[text width=4cm]%originally{40}{15}
%     \Node{0}{20}{10}
%     \leftAttbox[draw]{0}{1}{1}{left\\
%     attribute\\ label}
%     \rightAttbox[fill=red!50!blue!20]{0}{10}{10}{right
%     attri-\\ bute label}
%     \rightObjbox[draw]{0}{20}{5}{right\\
%     object\\ label}
%     \centerObjbox{0}{0}{5}{centered\\
%     object label}
%   \end{diagram}
% \end{dtxexample}
% }
%
% The style of the lables is given by
% \begin{description}
% \item[]|\fcaObjectLabelStyle|\hspace*{3.5ex}\quad
% Default: |\small\baselineskip6pt\rm|
% \item[]|\fcaAttributeLabelStyle|\quad
% Default: |\small\baselineskip6pt\it|.
% \end{description}
% These values can be changed with |\renewcommand|.
%
% \subsubsection{Defining a diagram style}
% With some knowledge about PGF and TikZ you can define your own style
% for concept lattice diagrams. For multiple use such definitions can
% be outsourced using the  |\fcaset{}| macro.
%
% We demonstrate this with an example where we define and then use a
% style called conexpstyle. It is based on Serhiy Yevtushenko's
% \texttt{Concept Explorer}, in which object and attribute concepts
% are color-coded, by a black lower semicircle and a blue upper
% semicircle, respectively.
%
% \begin{dtxexample}{Defining a \env{diagram} style}
% \fcaset{conexpstyle/.style={%
%     every attributes/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=blue,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid
%       }
%     },
%     every objects/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=black,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid,
%         rotate=180
%       }
%       }}}
% \end{dtxexample}
%
% To apply the defined style, use its name as an optional argument of
% \texttt{$\backslash$begin\{diagram\}}, or, if it shall be applied to
% single nodes only, as an optional argument for the respective node
% declarations.
%
% \begin{dtxexample}{Using a \env{diagram} style}
% {\unitlength 1.2mm
% \begin{diagram}[conexpstyle]
%   \Node(1)(20,10)
%   \Node(2)(35,20)
%   \Node(3)(5,30)
%   \Node(4)(35,40)
%   \Node(5)(20,50)
%   \Edge(1)(2)
%   \Edge(1)(3)
%   \Edge(2)(4)
%   \Edge(3)(5)
%   \Edge(4)(5)
%   \leftAttbox{3}{2}{2}{1}
%    \rightAttbox{2}{2}{2}{disqualified}
%   \rightAttbox{4}{2}{2}{2.}
%   \leftObjbox{3}{2}{2}{Verstappen}
%   \rightObjbox{2}{2}{2}{Leclerc}
%   \rightObjbox{4}{2}{2}{Hamilton}
% \end{diagram}
% }
% \end{dtxexample}
%
% \textcolor{red}{\bf Bernhards Arbeitsende}
%
%
% \section {weiter im normalen Text}
%
% \textcolor{red}{All this can be modified with the |shift| option.}
%
% \iffalse
% The offsets increase the placement effect. A |\rightObjbox|, which is
% placed to the lower right of the corresponding node, will be moved even
% further to the lower right if the offsets are positive. Similarly, positive
% offsets will push a |\leftAttbox| even more to the upper left, etc.
% \fi
%
% When |text width| is set to a length, the text of the label is put
% in a |\parbox|. It can be broken into several lines using |\\|. The
% width of the |\parbox| is the value of the |text width| parameter.
% It is unset by default, resulting in a one-line box (i.e. hbox) for
% the label. In this case the width of the box is automatically detected.
%
%
% \iffcatikzdoc
%   {\unitlength 1.2mm\relax
%   \begin{dtxexample}*{A \protect\TikZ -enhanced diagram}
%   \begin{diagram}[
%     every attributes/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=blue,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid
%       }
%     },
%     every objects/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=black,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid,
%         rotate=180
%       }
%       }]%
%
%     \begin{pgfscope}
%       \color{red}
%       \pgftransformshift{\pgfpoint{20\unitlength}{30\unitlength}}%
%       \pgfnode{circle}{center}{\Huge Example}{example
%       text}{\pgfusepath{stroke}}%
%     \end{pgfscope}
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \Node[/tikz/opacity=0.3](3)(5,30)
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \Edge[/tikz/opacity=0.3](1)(3)
%     \Edge[/tikz/arrows=<->](2)(4)
%     \Edge[/tikz/opacity=0.3](3)(5)
%     \Edge(4)(5)
%     \leftAttbox[/tikz/opacity=0.3](3){1.}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \leftObjbox[/tikz/opacity=0.3](3){Verstappen}
%     \rightObjbox(2){Leclerc}
%     \rightObjbox(4){Hamilton}
%     \begin{pgfscope}%
%       \edef\tempa{%
%       \noexpand\pgftransformshift{%
%       \noexpand\pgfpointanchor{\pgfkeysvalueof{/fca/name prefix}2\pgfkeysvalueof{/fca/name suffix}}{west}}%
%     }%
%       \tempa
%       \pgfmoveto{\pgfpoint{0pt}{0pt}}%
%       \pgflineto{\pgfpoint{4\unitlength}{0pt}}
%       \pgfsetstrokecolor{red}
%       \pgfusepath{stroke}
%     \end{pgfscope}%
%     {
%       \pgfmoveto{\pgfpointanchor{fca node 5}{west}}
%       \pgflineto{\pgfpointanchor{fca node 1}{north east}}
%       \pgfsetstrokecolor{green}
%       \pgfusepath{stroke}
%     }
%     \end{diagram}
% \end{dtxexample}
% }
%
%
% \begin{dtxexample}*{A \protect\TikZ diagram}
%   \begin{tikzpicture}[x=0.1cm, y=0.1cm]
%    %     x and y should have the same size, here
%     \node[red,shape=circle,anchor=center,draw=red] (example
%     text) at (20,30) {\Huge Example};
%     \begin{diagram}[
%       every attributes/.append style={
%         label concept/.append style={
%           shape=semicircle,
%           fill=blue,
%           anchor=south,
%           minimum height=2\unitlength,%
%           label/name suffix=attribute concept,
%           label/at=center,%
%           solid
%         }
%       },
%       every objects/.append style={%
%         label concept/.append style={%
%           shape=semicircle,
%           fill=black,
%           anchor=south,
%           minimum height=2\unitlength,
%           rotate=180,
%           label/name suffix=attribute concept,
%           label/at=center,
%           solid,
%         }
%       },
%         shift={(0pt,0pt)}]
%       \Node[/tikz/draw=orange](1)(20,10)
%       \Node(2)(35,20)
%       \Node[/tikz/opacity=0.3](3)(5,30)%
%       \Node(4)(35,40)
%       \Node(5)(20,50)
%       \Edge(1)(2)
%       \Edge[/tikz/opacity=0.3](1)(3)
%       \Edge[/tikz/arrows=<->](2)(4)
%       \Edge[/tikz/opacity=0.3](3)(5)
%       \Edge(4)(5)
%       \leftAttbox[/tikz/opacity=0.3](3){1.}
%       \rightAttbox(2){disqualified}
%       \rightAttbox(4){2.}
%       \leftObjbox[/tikz/opacity=0.3](3){Hamilton}
%       \rightObjbox(2){Massa}
%       \rightObjbox(4){Alonso}
%       \path[draw,red] (\pgfkeysvalueof{/fca/name
%       prefix}2\pgfkeysvalueof{/fca/name suffix}.west)
%       -- +(4\unitlength,0pt);
%       \path[draw,red!50!yellow] (2.west)
%       -- +(4\unitlength,0pt);
%       \draw[green] (fca node 5.west)--(fca node 1.north east);
%     \end{diagram}
%   \end{tikzpicture}
% \end{dtxexample}
%
% The same diagram can be typeset using PGF:
% \fi
%
% {\unitlength 1.2mm\relax
% \begin{dtxexample}*{A PGF enhanced diagram}
%   \begin{diagram}[
%     every attributes/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=blue,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid
%       }
%     },
%     every objects/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=black,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid,
%         rotate=180
%       }
%       }]
%     \begin{pgfscope}
%       \color{red}
%       \pgftransformshift{\pgfpoint{20\unitlength}{30\unitlength}}%
%       \pgfnode{circle}{center}{\Huge Example}{example
%       text}{\pgfusepath{stroke}}%
%     \end{pgfscope}
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \begin{pgfscope}
%       \pgfsetstrokeopacity{0.3}
%       \pgfsetfillopacity{0.3}
%       \Node(3)(5,30)
%     \end{pgfscope}
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \begin{pgfscope}
%       \pgfsetstrokeopacity{0.3}
%       \Edge(1)(3)
%     \end{pgfscope}
%     \begin{pgfscope}
%       \pgfsetarrows{<->}
%       \Edge(2)(4)
%     \end{pgfscope}
%     \begin{pgfscope}
%       \pgfsetstrokeopacity{0.3}
%       \Edge(3)(5)
%     \end{pgfscope}
%     \Edge(4)(5)
%     \begin{pgfscope}
%       \pgfsetstrokeopacity{0.3}
%       \pgfsetfillopacity{0.3}
%       \leftAttbox(3){1.}
%     \end{pgfscope}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \begin{pgfscope}
%       \pgfsetstrokeopacity{0.3}
%       \pgfsetfillopacity{0.3}
%       \leftObjbox(3){Verstappen}
%    \end{pgfscope}
%     \rightObjbox(2){Leclerc}
%     \rightObjbox(4){Hamilton}
%     \begin{pgfscope}%
%       \edef\tempa{%
%       \noexpand\pgftransformshift{%
%       \noexpand\pgfpointanchor{\pgfkeysvalueof{/fca/name prefix}2\pgfkeysvalueof{/fca/name suffix}}{west}}%
%     }%
%       \tempa
%       \pgfmoveto{\pgfpoint{0pt}{0pt}}%
%       \pgflineto{\pgfpoint{4\unitlength}{0pt}}
%       \pgfsetstrokecolor{red}
%       \pgfusepath{stroke}
%     \end{pgfscope}%
%     {
%       \pgfmoveto{\pgfpointanchor{fca node 5}{west}}
%       \pgflineto{\pgfpointanchor{fca node 1}{north east}}
%       \pgfsetstrokecolor{green}
%       \pgfusepath{stroke}
%     }
%   \end{diagram}
% \end{dtxexample}
% }
%
%
%   The old syntax is also supported:
%
% {\unitlength 1.2mm\relax
% \begin{dtxexample}*{A diagram}
%   \begin{diagram}[
%     every attributes/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=blue,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         solid
%       }
%     },
%     every objects/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=black,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         solid,
%         rotate=180
%       }
%     }]{40}{55}
%     \Node{1}{20}{10}
%     \Node{2}{35}{20}
%     \Node{3}{5}{30}
%     \Node{4}{35}{40}
%     \Node{5}{20}{50}
%     \Edge{1}{2}
%     \Edge{1}{3}
%     \Edge{2}{4}
%     \Edge{3}{5}
%     \Edge{4}{5}
%     \Numbers
%     \leftAttbox{3}{2}{2}{1.}
%     \rightAttbox{2}{2}{2}{disqualified}
%     \rightAttbox{4}{2}{2}{2.}
%     \leftObjbox{3}{2}{2}{Verstappen}
%     \rightObjbox{2}{2}{2}{Leclerc}
%     \rightObjbox{4}{2}{2}{Hamilton}
%     \begin{pgfscope}%
%       \edef\tempa{%
%       \noexpand\pgftransformshift{%
%       \noexpand\pgfpointanchor{\pgfkeysvalueof{/fca/name prefix}2\pgfkeysvalueof{/fca/name suffix}}{west}}%
%     }%
%       \tempa
%       \pgfmoveto{\pgfpoint{0pt}{0pt}}%
%       \pgflineto{\pgfpoint{4\unitlength}{0pt}}
%       \pgfsetstrokecolor{red}
%       \pgfusepath{stroke}
%     \end{pgfscope}%
%   \end{diagram}
% \end{dtxexample}
% }
%
%
% \DescribeMacro{\leftAttbox}\oarg{options}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\centerAttbox}\oarg{options}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\rightAttbox}\oarg{options}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\leftObjbox}\oarg{options}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\centerObjbox}\oarg{options}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\rightObjbox}\oarg{options}\parg{nodenumber}\marg{text}
%
% These are used to put
% text to diagram nodes. The |Attbox|--commands place the text above the
% corresponding node, the |Objbox| below. Similarly, the text can be placed
% to the left, be centered, or be placed to the right of the labelled node. All
% this can be modified with the |shift| option.
%
% \iffalse
% The offsets increase the placement effect. A |\rightObjbox|, which is
% placed to the lower right of the corresponding node, will be moved even
% further to the lower right if the offsets are positive. Similarly, positive
% offsets will push a |\leftAttbox| even more to the upper left, etc.
% \fi
%
% When |text width| is set to a length, the text of the label is put
% in a |\parbox|. It can be broken into several lines using |\\|. The
% width of the |\parbox| is the value of the |text width| parameter.
% It is unset by default, resulting in a one-line box (i.e. hbox) for
% the label. In this case the width of the box is automatically detected.
%
% The label text and the labelled node are connected with a dotted line.
% Here is an example:
%
% \DescribeMacro{\end\{diagram\}} This concludes the diagram. The circles
%  representing the nodes are drawn and filled with white. Everything inside
%  such a circle (except for the numbers caused by the |\Numbers| command)
%  is erased.
% \section{Zeugs, auf dem ich besthe (inhaltlich)}
% \subsection{compat / nocompat}\label{subsec:compat}
%
% \begin{itemize}
% \item Die Versionsnummer ist wichtig (falls später mal
% inkonsistenzen auftauchen
% \item \optn{compat} / \optn{nocompat} müssen \textbf{beide}
% dokumentiert werden.
% \end{itemize}
%
% In order to reduce incompatibilities with other packages,
% since version 2.2 |fca.sty| nearly all macros of |fca.sty|
% belong to a so called namespace. That means most of
% them start with the |\fca...|. Only in the environments |cxt| and
% |diagram| this rule is relaxed.
%
% The option |compat| also defines the old names that have been used
% before version 2.2.
%
% \watchout The current implementation can be only used to typeset
% unmodified Documents that were written before version 2.2. It maps
% the new macros to use the old ones. As soon as the new macros are
% redefined, the old ones are ignored. So, make shure you replace all
% occurrances of the old macros by the corresponding new ones at once.
%
% \DescribeOption{nocompat}
%
% This option reverts the effect of |compat|.
%
% \subsection{Definition der Symbole im Kontext}
% Die Makros sind im Abschnitt \textbf{The Code} \ref{sec:the-code}
% für Entwickler dokumentiert. Ein sinnvolles Vorgehen für Endnutzer
% muss spätestens im Abchnitt advanced usage für die
% \env{cxt}-Umgebung kommen. Dauzu gehört auch der hier aufgeführt
% Inhalt, insbesondere die tabellarische Form ist fürs schnelle
% Nachschlagen wichtig.
%
% \DescribeEnv{cxt}\oarg{alignment}
%
% |cxt| generates a tabular of the appropriate format. It takes
% an optional alignment parameter, that is passed to the tabular
% environment (see there for further documentation). The tabular is
% defined as soon as the first |\obj| command is given. Spaces in the
% preceding lines are not ignored in general. The standard macros have
% been designed to ignore following spaces. But this cannot be extended
% to other macros. Therefore, each line that contains individual
% (non-cxt-code) should be ended with a |%|\ .
%
% By default the following characters are predefined for the use in the first argument of \cs{obj}:
% \begin{description}
%   \ItemDescribeOther[char]{.} A non-incidence, usually printed as white space.
%   \ItemDescribeOther[char]{x} A a cross in the cross table.
%   \ItemDescribeOther[char]{X} A a cross in the cross table (alternate syntax).
%   \ItemDescribeOther[char]{u} An updarrow for the arrow relation.
%   \ItemDescribeOther[char]{d} A downarrow of the arrow relation.
%   \ItemDescribeOther[char]{b} An up- and downarrow of the arrow relation.
%   \ItemDescribeOther[char]{0} The number $0$ for many-valued contexts
%   \ItemDescribeOther[char]{1} The number $1$ for many-valued contexts
%   \ItemDescribeOther[char]{2} The number $2$ for many-valued contexts
%   \ItemDescribeOther[char]{3} The number $3$ for many-valued contexts
%   \ItemDescribeOther[char]{4} The number $4$ for many-valued contexts
%   \ItemDescribeOther[char]{5} The number $5$ for many-valued contexts
%   \ItemDescribeOther[char]{6} The number $6$ for many-valued contexts
%   \ItemDescribeOther[char]{7} The number $7$ for many-valued contexts
%   \ItemDescribeOther[char]{8} The number $8$ for many-valued contexts
%   \ItemDescribeOther[char]{9} The number $9$ for many-valued contexts
% \end{description}
%
%
% \subsection{Error messages}
% Package error messages for the \texttt{diagram} environment are not yet
% implemented. Errors usually are caused by using node numbers that have not
% been defined earlier.
%
% \subsection{Fine tuning}
% You can change certain layout parameters either permanently (by modifying the
% file \texttt{fca.sty}) or temporarily using the following commands:
% \begin{description}
% \ItemDescribeMacro{\fcaCircleSize}\marg{size} Default: 4\qquad
% (times |\unitlength|)
% \ItemDescribeMacro {\NodeColor}\marg{color}   Default: white
% \ItemDescribeMacro {\fcaNodeThickness}\marg{thickness}  \qquad
% Default: 1.2pt
% \ItemDescribeMacro {\fcaEdgeThickness}\marg{thickness}  \qquad
% Default: .8pt
% \ItemDescribeMacro {\NodeThickness}\marg{thickness} an alias to
% \cs{fcaNodeThickness} inside a \env{diagram} environment
% \ItemDescribeMacro {\EdgeThickness}\marg{thickness} an alias to
% \cs{fcaEdgeThickness} inside a \env{diagram} environment
% \ItemDescribeMacro {\fcaNoDots}
% \ItemDescribeMacro {\fcaObjectLabelStyle} can be redefined to set the
% style of object labels,
% \ItemDescribeMacro {\fcaAttributeLabelStyle} can be redefined to set
% the style of attribute labels,
% \ItemDescribeMacro {\fcaLabelBoxWidth} can be redefined to a width,
% which will be used to set the width of the object and attribute boxes.
% \end{description}
% Except for the first three, these commands can be focussed to single instances,
% using braces. For example,
% \begin{center}
% |{\fcaNoDots\centerObjbox{nodenumber}{xoffset}{yoffset}{labeltext}}|
% \end{center}
% generates a single centered object label without dotted line.
%
% \subsection{\pdfLaTeX \ compatibility}
% Version 2 of the \texttt{diagram} environment was designed to be \pdfLaTeX\
% compatibile. It no longer uses \texttt{eepic.sty}, which is not supported by
% \pdfLaTeX. Instead it uses \texttt{pict2e} and a |\fcadrawline| command,
% that replaces \texttt{eepic}'s |\drawline|.
%
% \subsection{Problems with colour}
% Since the diagrams are drawn using the \texttt{picture}--commands and the
% \texttt{pict2e} package, we can combine with other packages, for example, with
% the \texttt{color} package. This allows us to colour edges and text (but not
% individual nodes, see \ref{subsec:colornode}).
% However, \texttt{color} has a problem with spacing. Changing colors can cause
% unwanted spaces, and these are particularly unpleasant in pictures. Have a
% look at the following:\medbreak
%
% \begin{minipage}{.6\textwidth}
% \begin{verbatim}
% {\unitlength 2mm
% \begin{diagram}{20}{20}
% \Node{1}{5}{5}
% \Node{2}{15}{15}
% {\color{red}\Edge{1}{2}}
% {\color{blue}\Edge{1}{2}}
% {\color{red}\Edge{1}{2}}
% {\color{blue}\Edge{1}{2}}
% \end{diagram}}
% \end{verbatim}
% \end{minipage}\hfill
% \begin{minipage}{.3\textwidth}
% {\unitlength 2mm
% \begin{diagram}{20}{20}
% \Node{1}{5}{5}
% \Node{2}{15}{15}
% {\color{red}\Edge{1}{2}}
% {\color{blue}\Edge{1}{2}}
% {\color{red}\Edge{1}{2}}
% {\color{blue}\Edge{1}{2}}
% \end{diagram}}
% \end{minipage}
% \medbreak
%
% \noindent This effect disappears when spaces are avoided. Here is a better
% version:\medbreak
%
% \begin{minipage}{.6\textwidth}
% \begin{verbatim}
% {\unitlength 2mm
% \begin{diagram}{20}{20}
% \Node{1}{5}{5}
% \Node{2}{15}{15}
% {\color{red}\Edge{1}{2}}%
% {\color{blue}\Edge{1}{2}}%
% {\color{red}\Edge{1}{2}}%
% \color{blue}\Edge{1}{2}}%
% \end{diagram}% In order to reduce incompatibilities with other packages,
% since version 2.2 |fca.sty| nearly all macros of |fca.sty|
% belong to a so called namespace. That means most of
% them start with the |\fca...|. Only in the environments |cxt| and
% |diagram| this rule is relaxed.
%
% The option |compat| also defines the old names that have been used
% before version 2.2.
%
% \watchout The current implementation can be only used to typeset
% unmodified Documents that were written before version 2.2. It maps
% the new macros to use the old ones. As soon as the new macros are
% redefined, the old ones are ignored. So, make shure you replace all
% occurrances of the old macros by the corresponding new ones at once.
%
% \DescribeOption{nocompat}
%
% This option reverts the effect of |compat|.

% \end{verbatim}
% \end{minipage}\hfill
% \begin{minipage}{.3\textwidth}
% {\unitlength 2mm
% \begin{diagram}{20}{20}
% \Node{1}{5}{5}
% \Node{2}{15}{15}
% {\color{red}\Edge{1}{2}}%
% {\color{blue}\Edge{1}{2}}%
% {\color{red}\Edge{1}{2}}%
% {\color{blue}\Edge{1}{2}}%
% \end{diagram}}
% \end{minipage}
%
%
% \subsection{Colouring nodes}
% \label{subsec:colornode}
%
% The nodes can be coloured by using the \texttt{draw=} and
% \texttt{fill=} parameter. These can be set either by using
% \cs{fcaset} or in any other way, that allows to set styles.% In order to reduce incompatibilities with other packages,
% since version 2.2 |fca.sty| nearly all macros of |fca.sty|
% belong to a so called namespace. That means most of
% them start with the |\fca...|. Only in the environments |cxt| and
% |diagram| this rule is relaxed.
%
% The option |compat| also defines the old names that have been used
% before version 2.2.
%
% \watchout The current implementation can be only used to typeset
% unmodified Documents that were written before version 2.2. It maps
% the new macros to use the old ones. As soon as the new macros are
% redefined, the old ones are ignored. So, make shure you replace all
% occurrances of the old macros by the corresponding new ones at once.
%
% \DescribeOption{nocompat}
%
% This option reverts the effect of |compat|.

% So you can also add a fill parameter to the node:
%
% \begin{dtxexample}{Colouring individual nodes}
% {\definecolor{grey}{gray}{.8}
% \unitlength 2mm
% \fcaNodeThickness{2.5pt}
% \fcaEdgeThickness{2.5pt}
% \begin{diagram}
% \NodeColor{grey}
% \Node[fill=green](1)(5,5)
% \Node(2)(15,15)
% \Edge{1}{2}%
% \end{diagram}}
% \end{dtxexample}
%
% Nodes are filled with white by default. This can be changed to any other colour
% using the command |\NodeColor{colorname}|. This color then applies to
% \textbf{all nodes}. \texttt{colorname} must be a
% color specification as  used by the \texttt{color} package.
% \texttt{``red''}, \texttt{``blue''}, and \texttt{``green''} should usually
% work. Other colors may be defined with the |\definecolor| command, see
% the documentation of the \texttt{graphics} bundle. For finer colour
% nuances use the \texttt{xcolor} package and its documentation.
%
% \fcastyle does not support individual node colouring, but there is a trick to
% do it nevertheless. Simply include the \texttt{diagram} environment into a
% \texttt{picture} environment and insert the coloured nodes after the diagram
% is drawn. How this is done should become clear from the example
% below. \fcastyle provides a command |\fcaColorNode{colorname}| for this.
% It overwrites numbers generated by the |\Numbers| command.
% \medbreak
%
% \begin{minipage}{.6\textwidth}
% \begin{verbatim}
% {\definecolor{grey}{gray}{.8}
% \unitlength 2mm
% \fcaNodeThickness{2.5pt}
% \fcaEdgeThickness{2.5pt}
% \begin{picture}(20,20)%
% \put(0,0){%
% \begin{diagram}{20}{20}
% \NodeColor{grey}
% \Node{1}{5}{5}
% \Node{2}{15}{15}
% \Edge{1}{2}%
% \end{diagram}}
% \put(5,5){\fcaColorNode{green}}
% \end{picture}}
% \end{verbatim}
% \end{minipage}\hfill
% \begin{minipage}{.3\textwidth}
% {\unitlength 2mm\definecolor{grey}{gray}{.8}
% \fcaNodeThickness{2.5pt}
% \fcaEdgeThickness{2.5pt}
% \begin{picture}(20,20)%
% \put(0,0){%
% \begin{diagram}{20}{20}
% \NodeColor{grey}
% \Node{1}{5}{5}
% \Node{2}{15}{15}
% \Edge{1}{2}%
% \end{diagram}}
% \put(5,5){\fcaColorNode{green}}
% \end{picture}}
% \end{minipage}
%
% \clearpage
% \subsection{Some warning about future implementations}
%
% Currently |\unitlength| is used inside in the \env{diagram}
% environment. However, since PGF already comes with support for
% coordinate and canvas transformations, a future version might
% completely rely on them and abandon the usage of |\unitlength|.
% Then, |\unitlength| may be used only to initially set up the
% coordinate system and ignored later. So it is strongly discouraged
% to change |\unitlength| inside the \env{diagram} diagram
% environment.
%
% Thus, it is recommended to use Euclidian coordinate systems for
% diagrams. Other coordinate systems should work, too. However, the
% output may change in that case using future versions of this
% package. In particular the algorithm for the calculation of the node
% radius may change, and changes to |\unitlength| inside the
% environment will have no effect.
%
% The newly added option to encapsulate a \env{diagram} environment
% inside a \env{tikzpicture} or \env{pgfpicture} already goes into
% that direction. In this usage the |\unitlength| register is set to
% the sum of the horizontal unit lengths of the x and the y
% coordinates as provided by the surrounding environment.
%
% \section{Some macros}
% For a short description see Figure~\ref{fig:macros}.
% \begin{figure}[p]
%   \begin{center}
%    \begin{tabular}{cll}\hline
% Result&command& German version\\\hline
% $\GMI$&|\GMI|&\\
% $\context$&|\context|&\\
% $\context[L]$&|\context[L]|&\\
% $\CL$ &|\CL| &|\BV| \\
% $\BVGMI$  &|\CLGMI| &|\BVGMI| \\
% $\BGMI$  & |\CGMI|& |\BGMI|\\
% $\extent{}$&|\extent{}|&\\
% $\intent{}$&|\intent{}|&\\
% $\extents{}$&|\extents{}|&\\
% $\intents{}$&|\intents{}|&\\
% $\HNI$   &|\HNI| & \\
% $\relI$   &|\relI| & \\
% $\notI$   &|\notI| & \\
% $\bigtimes$   &|\bigtimes| & \\
% $\Semi$   &|\Semi| & \\
% $\Runterpfeil$   &|\DownArrow|&|\Runterpfeil| \\
% $\Hochpfeil$   &|\UpArrow| &|\Hochpfeil| \\
% $\Doppelpfeil$   &|\DoubleArrow| &|\Doppelpfeil| \\
% $\IRunterpfeil$   &|\IDownArrow| &|\IRunterpfeil| \\
% $\IHochpfeil$   &|\IUpArrow| &|\IHochpfeil| \\
% $\DDPfeil$   &|\DDArrow| &|\DDPfeil| \\
% $\NDDPfeil$   &|\NDDArrow| &|\NDDPfeil| \\
% \FCA   &|\FCA| & \\
% \FBA   & &|\FBA| \\
% \FnBA   & &|\FnBA| \\\hline
%      \end{tabular}
% \caption{Table of \texttt{fca.sty}--macros.}\label{fig:macros}
%  \end{center}
% \end{figure}
% \begin{figure}[p]
%  \begin{center}
%      \begin{tabular}{lll}\hline
% Symbol&command&package required\\\hline
% $\vee$&|\vee|&\\
% $\wedge$&|\wedge|&\\
% $\bigvee$&|\bigvee|&\\
% $\bigwedge$&|\bigwedge|&\\
% $\sqcup$&|\sqcup|&\\
% $\sqcap$&|\sqcap|&\\
% $\bigsqcup$&|\bigsqcup|&\\
% $\bigsqcap$&|\bigsqcap|&stmaryrd\\\hline
% &||&\\
% \end{tabular}
% \caption{Other symbols that are used in \FCA, and the commands that generate
%  them.}\label{fig:2}\end{center}
% \end{figure}
%
%
% \begin{description}
% \item[]|\GMI|\quad The formal context $\GMI$.
% \item[]|\context|\quad The symbol $\context$, a frequently used name for
%  a formal context.
% \item[]|\context[S]|\quad Other letters, such as $\context[S]$, may also
%  be used.
% \item[]|\CL|\quad The symbol $\CL$ for the concept lattice operator. If
%  ${\mathbb K}$ is a formal context, then $\CL({\mathbb K})$ denotes its
%  concept lattice.
% \item[]|\BV|\quad same as |\CL|.
% \item[]|\CLGMI|\quad The concept lattice $\CLGMI$ of the formal context
%  $(G,M,I)$.
% \item[]|\BVGMI|\quad Same as |\CLGMI|.
% \item[]|\CGMI|\quad The set $\CGMI$ of all formal concepts of the formal
%  context   $(G,M,I)$.
% \item[]|\BGMI|\quad Same as |\CGMI|.
% \item[]|\extent|\quad The extent $\extent{\mathfrak{c}}$ of the formal
%  concept $\mathfrak{c}:=(A,B)$ is  $A$.
% \item[]|\intent|\quad The intent $\intent{\mathfrak{c}}$ of the formal
%  concept $\mathfrak{c}:=(A,B)$ is  $B$.
% \item[]|\extents|\quad The set $\extents{\context}$ of extents of the
%  formal context $\context$.
% \item[]|\intents|\quad The set $\intents{\context}$ of intents of the
%  formal context $\context$.
% \item[]|\HNI|\quad The subcontext $\HNI$.
% \item[]|\relI|\quad The incidence relation $\relI$.
% \item[]|\notI|\quad The negation $\notI$ of the incidence
%  relation.
% \item[]|\bigtimes|\quad The product symbol $\bigtimes$.
% \item[]|\DownArrow|\quad The $\Runterpfeil$ of the arrow relations.
% \item[]|\Runterpfeil|\quad Same as |\DownArrow|.
% \item[]|\UpArrow|\quad The $\Hochpfeil$ of the arrow relations.
% \item[]|\Hochpfeil|\quad   Same as |\UpArrow|.
% \item[]|\DoubleArrow|\quad  The $\Doppelpfeil$ of the arrow relations.
% \item[]|\Doppelpfeil|\quad   Same as |\DoubleArrow|.
% \item[]|\IUpArrow|\quad  Gives $\IHochpfeil$, which is has the same
%  meaning as $\UpArrow$,  but is drawn in the other direction. This is needed
%  in the  definition of $\DPfeil$.
% \item[]|\IHochpfeil|\quad  Same as |\IUpArrow|.
% \item[]|\DDArrow|\quad Gives $\DDPfeil$, the symbol for the transitive
%  closure of the arrow relations.
% \item[]|\DDPfeil|\quad  Same as |\DDArrow|.
% \item[]|\NDDArrow|\quad Gives $\NDDPfeil$ the symbol for the negation of
%  $\DDPfeil$.
% \item[]|\NDDPfeil|\quad  Same as |\NDDArrow|.
% \item[]|\Semi|\quad Gives $\Semi$, the symbol for the semi-product.
% \item[]|\FCA|\quad Prints ``\FCA''.  In most cases, this command does not
%  eat the space following it (thanks to |\xspace|).
% \item[]|\FBA, \FnBA|\quad Print ``Formale(n) Begriffsanalyse''. These
%  commands also use |\xspace| so that blanks are preserved.
% \item[]Some symbols that are provided by \LaTeX\ are listed in
%  Figure~\ref{fig:2}.
% \end{description}
%
% \par\noindent
% Here is a sample text:
% \begin{verbatim}
% \FCA offers an elegant way to determine the congruence relations
% of a complete lattice: The congruence lattice of a doubly founded
% concept lattice $\CLGMI$ is isomorphic to $\CL(G,M,\NDDArrow)$.
% \end{verbatim}
% This translates to:
% \begin{center}
%  \begin{minipage}{.87\textwidth}
%  \FCA offers an elegant way to determine the congruence relations of a
%  complete lattice: The congruence lattice of a doubly founded concept lattice
%  $\CLGMI$ is   isomorphic to $\CL(G,M,\NDDArrow)$.
%  \end{minipage}
% \end{center}
%
%
% \section{To do}
% \begin{itemize}
% \item Improve the placement of the dotted lines connecting nodes with
%  attribute- and object names.
% \item Allow half-shaded nodes in diagrams, and make them
%  (optionally) automatic for object- and attribute concepts.
% \item Improve the code to avoid unwanted blanks.
% \end{itemize}
%
%
%
%
%
%
%
%
%
% \StopEventually{\PrintChanges}
% \clearpage
% \section{The Code}\label{sec:the-code}
% \iffalse
%    \begin{macrocode}
%</fcadoc>
%<*fca.sty>
%    \end{macrocode}
% \fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% This is file `fca.sty' : LaTeX macros for Formal Concept Analysis           %
%                                                                             %
% Copyright  Bernhard Ganter   5/03                                           %
% Version of                   10/07                                          %
%                                                                             %
% This program is provided under the terms of the                             %
% LaTeX Project Public License distributed from CTAN                          %
% archives in directory macros/latex/base/lppl.txt.                           %
%                                                                             %
% This package contains two environments, called cxt and diagram,             %
% for typesetting formal contexts and order diagrams,                         %
% and a few macros for frequently used symbols in FCA.                        %
%                                                                             %
% Short descriptions are given below. A recent version of this file           %
% as well as a file named fcadoc.tex                                          %
% should be available at http://tu-dresden.de/Members/bernhard.ganter         %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%
% \subsection{Package options for fca.sty}
%
%    \begin{macrocode}
\newif\iffca@compat@macros
\fca@compat@macrosfalse
\DeclareOption{compat}{%
  \fca@compat@macrostrue
}
\DeclareOption{nocompat}{%
  \fca@compat@macrosfalse
}
%    \end{macrocode}
%    \begin{macrocode}
\ProcessOptions\relax
%    \end{macrocode}
%
% \subsection{Loading other packages and general helpers}
%    \begin{macrocode}
\RequirePackage{pgf}
\usepgflibrary{shapes.geometric}
\RequirePackage{amssymb,graphics,color,ifthen,rotating,xspace}%%
%    \end{macrocode}
%
% \begin{macro}{\fca@parselength}\marg{register}\marg{expression}\marg{default unit}
%   Evaluates \meta{expression}. If it has no unit the \meta{default
%   unit} is use instead. The result is stored in \meta{register}.
%    \begin{macrocode}
\newcommand*\fca@parselength[3]{%
  \pgfmathparse{#2}%
  \ifpgfmathunitsdeclared
    #1=\pgfmathresult pt\relax
  \else
    #1=\pgfmathresult#3%
  \fi
}
%    \end{macrocode}
%
% \end{macro}
%
% \subsection{The context environment \env{cxt}}
% \subsubsection{Some configurations}
%
% \begin{macro}{\fca@cxt@Kreuz}
% \begin{macro}{\fca@cxt@Punkt}
% \begin{macro}{\fcaCxtArrowStyle}
% \begin{macro}{\cxtArrowStyle}
% \changes{2.2}{2022/03/8}{rename \cs{cxtArrowStyle} to \cs{fcaCxtArrowStyle}}
% \begin{macro}{\fca@cxt@down}
% \begin{macro}{\fca@cxt@up}
% \begin{macro}{\fca@cxt@both}
%   First we define some symbols that are used in formal contexts.
%    \begin{macrocode}
\newcommand{\fca@cxt@Kreuz}{$\times$}%
\newcommand{\fca@cxt@Punkt}{}%
\iffca@compat@macros
  \newcommand{\cxtArrowStyle}{\footnotesize}
  \def\fcaCxtArrowStyle{\cxtArrowStyle}
\else
  \newcommand{\fcaCxtArrowStyle}{\footnotesize}
\fi
\newcommand{\fca@cxt@down}{\fcaCxtArrowStyle$\Runterpfeil$}%
\newcommand{\fca@cxt@up}{\fcaCxtArrowStyle$\Hochpfeil$}%
\newcommand{\fca@cxt@both}{\fcaCxtArrowStyle$\Doppelpfeil$}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \DescribeCounter{fca@cxt@mAnz}%
%   Count the number of attributes in the current context.
%    \begin{macrocode}
\newcounter{fca@cxt@mAnz}%
%    \end{macrocode}
%
% \DescribeBoolean{fca@cxt@ttributes}
% Record whether we ar still in
% the attributes section or whether we have already started the object
% section of a formal context.
%
% \changes{2.2}{2022/03/08}{Rename \bool{@ttributes} to \bool{fca@cxt@ttributes}}
%    \begin{macrocode}
\newboolean{fca@cxt@ttributes}%
%    \end{macrocode}
%
% \DescribeLength{\fca@cxt@nameraise}
% Helper length for vertical alignment of the context and attribute names.
% \DescribeLength{\fca@cxt@ttnameheight}
% Helper length for vertical alignment of the context and attribute names.
%
% \changes{2.2}{2022/03/08}{Rename \cs{@ttnameheight} to \cs{fca@cxt@ttnameheight}}
%
%    \begin{macrocode}
\newlength{\fca@cxt@nameraise}%
\newlength{\fca@cxt@ttnameheight}%
%    \end{macrocode}
%
%
% \begin{macro}{\adjcxt@name}
% Adjusts the the vertical alignment of the attributes.
%    \begin{macrocode}
\newcommand{\adjcxt@name}{%
  \ifthenelse{\fca@cxt@nameraise<\fca@cxt@ttnameheight}%
  {\setlength{\fca@cxt@nameraise}{\fca@cxt@ttnameheight}}{}}%
%    \end{macrocode}
%
% \end{macro}
%
% \begin{macro}{\alignBottom}
% \begin{macro}{\fcaCxtAlignBottom}
%   Align the current context to the bottom. Inside the \env{cxt}
%   environment the macro \cs{fcaCxtAlignBottom} is available in its
%   short form \cs{alignBottom}.
%
%   \changes{2.2}{2022/03/08}{add \cs{cxtAlignBottom}}
%    \begin{macrocode}
\newcommand{\fcaCxtAlignBottom}{\def\fca@cxt@align{b}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\alignCenter}
% \begin{macro}{\fcaCxtAlignCenter}
%   Align the current context to the top. Inside the \env{cxt}
%   environment the macro \cs{fcaCxtAlignCenter} is available in its
%   short form \cs{alignCenter}.
%
%   \changes{2.2}{2022/03/08}{add \cs{cxtAlignCenter}}
%    \begin{macrocode}
\newcommand{\fcaCxtAlignCenter}{\def\fca@cxt@align{t}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\alignTop}
% \begin{macro}{\fcaCxtAlignTop}
%   Align the current context to the top. Inside the \env{cxt}
%   environment the macro \cs{fcaCxtAlignTop} is available in its
%   short form \cs{alignTop}.
%
%   \changes{2.2}{2022/03/08}{add \cs{cxtAlignTop}}
%    \begin{macrocode}
\newcommand{\fcaCxtAlignTop}{\def\fca@cxt@align{t}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{The main structure of a context}
%
% Typically a context is created in the following way:
% \begin{enumerate}
% \item The environment \env{cxt} is opened. This sets up the basic
%   configuration. An empty name is constructed.
% \item Attributes are added to the context. They are added as tokens
%   to \cs{fca@cxt@tabtop}.
% \item When the control arrives at the first call to \cs{obj}, the
%   \env{tabular} environment is opened and \cs{att} and \cs{atr} are
%   disabled.
% \end{enumerate}
%
% \begin{macro}{\cxtName}
% \begin{macro}{\fcaCxtName}
%   Set the name of the current formal context. If used outside of a
%   \env{cxt} environment it sets the name for all following contexts.
%   Inside a \env{cxt} environment \cs{fcaCxtName} can be accessed
%   also with the shorter name \cs{cxtName}.
%   \changes{2.2}{2022/03/08}{rename \cs{cxtName} to \cs{fcaCxtName},
%   \cs{cxtName} is still accessible inside the \env{cxt} environment,
%   ignore spaces after the macro call}
%    \begin{macrocode}
\newcommand{\fcaCxtName}[1]{%
  \def\fca@cxtn@me{%
    \multicolumn{1}{|c||}{%
      \settoheight{\fca@cxt@ttnameheight}{#1}%
      \addtolength{\fca@cxt@nameraise}{-1\fca@cxt@ttnameheight}%
      \raisebox{.5\fca@cxt@nameraise}{#1}%
    }%
  }%
  \ignorespaces
}%
\iffca@compat@macros
  \newcommand{\cxtName}{\fcaCxtName}
\fi
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\fca@cxt@att}\marg{name}
% Implementation for \cs{att}. The corresponding alias is set up
% during \cs{begin}\marg{\env{cxt}}.
% \begin{macro}{\att}\marg{name}
%
% For each attribute the user must provide us a name either with
% \cs{att} or with \cs{atr}. Both save the prvided name as heading.
% For horizontally oriented attribute names (typically very short
% ones) the user should use \cs{att}.
%
% \changes{2.2}{2022/03/08}{rename \cs{att} to \cs{fca@cxt@att} and
% make it available as \cs{att} in the \env{cxt} environment, only.}
%    \begin{macrocode}
\newcommand{\fca@cxt@att}[1]{%
  \ifthenelse{\boolean{fca@cxt@ttributes}}{%
    \settoheight{\fca@cxt@ttnameheight}{#1}\adjcxt@name%
    \expandafter\def\expandafter\fca@cxt@tabtop\expandafter{%
      \fca@cxt@tabtop&#1}%
    \stepcounter{fca@cxt@mAnz}%
  }{%
    \PackageWarning{fca}{Attribute following object in
      cxt-environment%
      has been ignored}{}}%
  \ignorespaces }%
%    \end{macrocode}

% \end{macro}
% \end{macro}
% \begin{macro}{\fca@cxt@atr}\marg{name}
% Implementation for \cs{atr}. The corresponding alias is set up
% during \cs{begin}\marg{\env{cxt}}.
% \begin{macro}{\atr}\marg{name}
%   The macro \cs{atr} is available only in the \env{cxt} environment.
%   it calls \cs{att} with its name rotated by 90 degrees, so that the
%   name is typeset vertically.
% \changes{2.2}{2022/03/08}{rename \cs{atr} to \cs{fca@cxt@atr} and
% make it available as \cs{atr} in the \env{cxt} environment, only.}
%    \begin{macrocode}
\newcommand{\fca@cxt@atr}[1]{\att{\rotatebox{90}{#1~~}}}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fca@cxt@obj}\marg{crosses}\marg{objectname}
%   Implementation for \cs{obj}. The corresponding alias is set up
%   during \cs{begin}\marg{\env{cxt}}.
% \begin{macro}{\obj}\marg{crosses}\marg{objectname}
%   This macro typesets an object line of a formal context inside the
%   \env{cxt} environment. The second argument \marg{objectname} is
%   the name of the objects. The first argument \marg{crosses} is a
%   line of tokens. Each token represents the contents of one cell in
%   the context table. Typically tokens contain spaces, arrows,
%   crosses. But they can be defined to represent other material as
%   well. Even multi character tokens are possible. However these are
%   not documented.%
%   \changes{2.2}{2022/03/08}{rename \cs{obj} to \cs{fca@cxt@obj} and
%   make it available as \cs{obj} in the \env{cxt} environment,
%   only.}%
%   \changes{2.2}{2022/03/11}{avoid usage of \cs{setboolean} in
%   \cs{fca@cxt@obj}}%
%    \begin{macrocode}
\newcommand{\fca@cxt@obj}[2]{%
  \fca@cxt@tabdef
  #2\strut
  \fca@cxt@Line{#1}%
  \\
}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fca@cxt@freeobj}\marg{columns}\marg{name}
%   Implementation for \cs{freeobj}. The corresponding alias is set up
%   during \cs{begin}\marg{\env{cxt}}.
% \begin{macro}{\freeobj}\marg{columns}\marg{name}
%   This macro allows to typeset any material in the incidence area of the
%   context. The second argument is typeset in the name column of the
%   context, while the first one occures inside the incidence area of the
%   context. The different fields in the first argument must be
%   separated as usual by |&|.
% \changes{2.2}{2022/03/08}{rename \cs{freeobj} to \cs{fca@cxt@freeobj} and
% make it available as \cs{freeobj} in the \env{cxt} environment, only.}
%
%    \begin{macrocode}
\newcommand{\fca@cxt@freeobj}[2]{%acrocod}
  \fca@cxt@tabdef%
  #2&#1\\\hline }%
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\fca@cxt@tabtop}
%   Material that is typeset above a context line.
%
%   At the beginning this macro contains the table header. Later it is
%   used to typeset the lines between the objects.
%
%   The Table heading for the attributes will be filled by |\att| and
%   |\atr| during the attribute section of the formal context. The
%   first |\obj| will use it.
%   \changes{2.2}{2022/03/11}{use \cs{fca@cxt@tabtop} also for storing
%   the \cs{hline} between the objects.}
%    \begin{macrocode}
\def\fca@cxt@tabtop{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fca@cxt@tabdef}
% \begin{macro}{\fca@cxt@tabdef@@}
%   Expand \cs{fca@cxt@align} as argument to \cs{fca@cxt@tabdef@}.
%
%   At the begin of a \env{cxt} environment \cs{fca@cxt@tabdef} set to
%   be an alias of \cs{fca@cxt@tabdef@@}. As soon as
%   \cs{fca@cxt@tabdef} is executed, this macro is set to \cs{relax}.
%
%   It is executed at the end of the cxt environment so that we can
%   typeset contexts without any objects.
%
%   \changes{2.2}{2022/03/11}{move generation of 1st line into \cs{fca@cxt@tabdef@@}}
%    \begin{macrocode}
\def\fca@cxt@tabdef@@{%
  \expandafter\fca@cxt@tabdef@\fca@cxt@align
  \fca@cxtn@me%&%
  \fca@cxt@tabtop\strut\\\hline\hline
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fca@cxt@tabdef@}\marg{alignment}
%   Do the work of \cs{fca@cxt@tabdef}: Open the tabular
%   environment. The parameter \marg{alignment} will be used to set
%   the vertiacal alignment of the context. See the documentation of
%   the |tabular| environment for further documentation.
%
%   Note: We must do all definitions outside of the tabular
%   environment.
%    \begin{macrocode}
\def\fca@cxt@tabdef@#1{%
  \def\fca@cxt@tabdef{\hline}%
  \tabcolsep0.5ex\relax%
  \begin{tabular}[#1]{|l||*{\value{fca@cxt@mAnz}}{c|}}%
    \hline%
    }%
%    \end{macrocode}
% \end{macro}
% \begin{environment}{cxt}\oarg{alignment}
%
%   The \env{cxt} environment. During setup a set of macros are
%   defined, and a new group is opened. The alignment argument is
%   saved. During the the first call to \cs{obj} a tabular environment
%   will be opened by calling \cs{fca@cxt@tabdef}.
%    At the end of the environment the tabular environment
%    is closed.
%
%   Here we test empty contexts. They should work, but don't need to
%   be documented:
% \begin{dtxexample}{A formal context without objects.}
%   \begin{cxt}
%     \cxtName{Formula 1}
%   %
%     \att{1.}
%     \att{2.}
%     \atr{disqualified}
%   %
%   \end{cxt}
% \end{dtxexample}
% \begin{dtxexample}{A formal context without attributes.}
%   \begin{cxt}
%     \cxtName{Formula 1}
%   %
%     \obj{}{Verstappen}
%     \obj{}{Hamilton}
%     \obj{}{Leclerc}
%   \end{cxt}
% \end{dtxexample}
%
% \begin{dtxexample}{An empty named context.}
%   \begin{cxt}
%     \cxtName{Formula 0}
%   \end{cxt}
% \end{dtxexample}
%
% \begin{dtxexample}{An empty \env{cxt} environment.}
%   \begin{cxt}
%   \end{cxt}
% \end{dtxexample}
%
%
%    \begin{macrocode}
    \newenvironment{cxt}[1][t]{%
    \begingroup
    \fca@cxt@resetDefaults
    \def\fca@cxt@align{#1}%
    \ignorespaces
    }{%
    \fca@cxt@tabdef% open the tabular in case there are no objects
  \end{tabular}%
  \endgroup }%
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\fca@cxt@resetDefaults}
%   Initialize macros an registered that are used in a formal context.
%   This macro is called at \cs{begin}\env{\{cxt\}}.
%    \begin{macrocode}
\newcommand{\fca@cxt@resetDefaults}{%
  \setlength{\fca@cxt@nameraise}{0pt}%
  \setlength{\fca@cxt@ttnameheight}{0pt}%
  \setcounter{fca@cxt@mAnz}{0}%
  \setboolean{fca@cxt@ttributes}{true}%
  \let\cxtName\fcaCxtName
  \let\alignBottom\fcaCxtAlignBottom
  \let\alignCenter\fcaCxtAlignCenter
  \let\alignTop   \fcaCxtAlignTop
  \let\att\fca@cxt@att
  \let\atr\fca@cxt@atr
  \let\obj\fca@cxt@obj
  \let\freeobj\fca@cxt@freeobj
  \let\cxtphantom\fca@cxt@phantom
  \let\cxtrlap\fca@cxt@rlap
  \let\fca@cxtn@me\@empty%
  \let\fca@cxt@tabdef\fca@cxt@tabdef@@
}%
%    \end{macrocode}
% \end{macro}
%
% \subsection{Cross table contents}
% \subsubsection{Defining the characters in a context.}
%
% Formal contexts usually contain crosses and – when we are looking
% for irreducible elements – arrows. Many-valued contexts can contain
% arbitrary content. This section describes the macros that used to
% typeset a single cell. This incluedes the symbols that can be used
% in a context line as well as the macros that allow to define them.
%
% It is necessary that very symbol in the context lines must be
% defined with the macros from this sections. Only this ensures that
% the parser gets restarted whenever a character is executed.
%
% \begin{macro}{\fca@cxt@phantom}
% \begin{macro}{\cxtphantom}
% This macro creates the horizontal space that would have been taken
% by a cross in the context. It is used to properly position other
% signs in the table without modifying the spacing.
%    \begin{macrocode}
\def\fca@cxt@phantom{\phantom{\fca@cxt@Kreuz}}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fca@cxt@rlap}\marg{content}
% \begin{macro}{\cxtrlap}\marg{content}
%   The argument \meta{content} will be typeset centered in a cell
%   that has the same size as an ordinary cross.
% \cs{cxtrlap} is only available in the \env{cxt} environment.
%    \begin{macrocode}
\def\fca@cxt@rlap#1{%
  \settowidth\@tempdima{\cxtphantom}%
  \makebox[\@tempdima][c]{\hss #1\hss}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \changes{2.2}{2022/03/21}{add \cs{fcaNewContextChar},\cs{fcaProvideContextChar} and \cs{fcaRenewContextChar} that define new letters for the context}
%
% \begin{macro}{\fca@cxt@M@kechar@newcommand}
% Put a starred \cs{newcommand*} into one single token. We will use it when we define a single character.
%    \begin{macrocode}
\def\fca@cxt@M@kechar@newcommand{%
  \newcommand*%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@cxt@Makechar@newcommand}\oarg{letter}
%   Defines a macro for the \meta{letter} to be used as a single token in the \env{cxt} environment. It is equivalent to
% \cs{newcommand*\{letter\}} and can take all additional arguments that \cs{newcommand} takes.
%
% Note: the macro is not restricted to letters. It can also use command names (that are converted to strings)
%    \begin{macrocode}
\def\fca@cxt@Makechar@newcommand#1{%
  \expandafter \fca@cxt@M@kechar@newcommand \csname cxt@char@\string#1 \endcsname
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fcaNewContextChar}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaNewContextChar@}\marg{character}\marg{definition}
% \begin{macro}{\fcaNewContextChar@@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaNewContextCh@r}\marg{character}\oarg{arguments}\marg{definition}
% \begin{macro}{\fcaNewContextCh@r@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
%   The macro \cs{fcaNewContextChar} can be used to define a new
%   character for usage in the \env{cxt} environment in the \cs{obj}
%   macro.
%   Internally it calls \cs{newcommand*} with the given arguments.
%
%   The remaining macros \cs{fcaNewContextChar@},
%   \cs{fcaNewContextChar@@}, \cs{fcaNewContextCh@r} and
%   \cs{fcaNewContextCh@r@} are used to pass the right arguments to
%   \cs{newcommand*}.
%    \begin{macrocode}
\def\fcaNewContextCh@r@#1[#2][#3]#4{%
  \fca@cxt@Makechar@newcommand{#1}[{#2}][{#3}]{#4\fca@cxt@read@line}%
}%
\def\fcaNewContextCh@r#1[#2]#3{%
  \fca@cxt@Makechar@newcommand{#1}[{#2}]{#3\fca@cxt@read@line}%
}%
\def\fcaNewContextChar@@#1[#2]{%
  \@ifnextchar[{\fcaNewContextCh@r@{#1}[{#2}]}{\fcaNewContextCh@r{#1}[{#2}]}%
}%
\def\fcaNewContextChar@#1#2{%
  \fca@cxt@Makechar@newcommand{#1}{#2\fca@cxt@read@line}%
}%
\def\fcaNewContextChar#1{%
  \@ifundefined{cxt@char@\string#1 }{}{%
    \PackageError{fca}{The character `\string#1' is already defined.}%
    \expandafter\let
    \csname cxt@char@\string#1 \endcsname\@undefined
  }%
  \@ifnextchar[{\fcaNewContextChar@@{#1}}{\fcaNewContextChar@{#1}}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\fca@cxt@M@kechar@providecommand}
% Put a starred \cs{providecommand*} into one single token. We will use it when we define a single character.
%    \begin{macrocode}
\def\fca@cxt@M@kechar@providecommand{%
  \providecommand*%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@cxt@Makechar@providecommand}\oarg{letter}
%   Defines a macro for the \meta{letter} to be used as a single token in the \env{cxt} environment. It is equivalent to
% \cs{providecommand*{letter}} and can take all additional arguments that \cs{providecommand} takes.
%
% Note: the macro is not restricted to letters. It can also use command names (that are converted to strings)
%    \begin{macrocode}
\def\fca@cxt@Makechar@providecommand#1{%
  \expandafter \fca@cxt@M@kechar@providecommand \csname cxt@char@\string#1 \endcsname
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fcaProvideContextChar}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaProvideContextChar@}\marg{character}\marg{definition}
% \begin{macro}{\fcaProvideContextChar@@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaProvideContextCh@r}\marg{character}\oarg{arguments}\marg{definition}
% \begin{macro}{\fcaProvideContextCh@r@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
%   The macro \cs{fcaProvideContextChar} can be used to define a provide
%   character for usage in the \env{cxt} environment in the \cs{obj}
%   macro.
%   Internally it calls \cs{providecommand*} with the given arguments.
%
%   The remaining macros \cs{fcaProvideContextChar@},
%   \cs{fcaProvideContextChar@@}, \cs{fcaProvideContextCh@r} and
%   \cs{fcaProvideContextCh@r@} are used to pass the right arguments to
%   \cs{providecommand*}.
%    \begin{macrocode}
\def\fcaProvideContextCh@r@#1[#2][#3]#4{%
  \fca@cxt@Makechar@providecommand{#1}[{#2}][{#3}]{#4\fca@cxt@read@line}%
}%
\def\fcaProvideContextCh@r#1[#2]#3{%
  \fca@cxt@Makechar@providecommand{#1}[{#2}]{#3\fca@cxt@read@line}%
}%
\def\fcaProvideContextChar@@#1[#2]{%
  \@ifnextchar[{\fcaProvideContextCh@r@{#1}[{#2}]}{\fcaProvideContextCh@r{#1}[{#2}]}%
}%
\def\fcaProvideContextChar@#1#2{%
  \fca@cxt@Makechar@providecommand{#1}{#2\fca@cxt@read@line}%
}%
\def\fcaProvideContextChar#1{%
  \@ifnextchar[{\fcaProvideContextChar@@{#1}}{\fcaProvideContextChar@{#1}}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\fca@cxt@M@kechar@renewcommand}
% Put a starred \cs{renewcommand*} into one single token. We will use it when we define a single character.
%    \begin{macrocode}
\def\fca@cxt@M@kechar@renewcommand{%
  \renewcommand*%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@cxt@Makechar@renewcommand}\oarg{letter}
%   Defines a macro for the \meta{letter} to be used as a single token in the \env{cxt} environment. It is equivalent to
% \cs{renewcommand*{letter}} and can take all additional arguments that \cs{renewcommand} takes.
%
% Note: the macro is not restricted to letters. It can also use command names (that are converted to strings)
%    \begin{macrocode}
\def\fca@cxt@Makechar@renewcommand#1{%
  \expandafter \fca@cxt@M@kechar@renewcommand \csname cxt@char@\string#1 \endcsname
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fcaRenewContextChar}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaRenewContextChar@}\marg{character}\marg{definition}
% \begin{macro}{\fcaRenewContextChar@@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaRenewContextCh@r}\marg{character}\oarg{arguments}\marg{definition}
% \begin{macro}{\fcaRenewContextCh@r@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
%   The macro \cs{fcaRenewContextChar} can be used to define a renew
%   character for usage in the \env{cxt} environment in the \cs{obj}
%   macro.
%   Internally it calls \cs{renewcommand*} with the given arguments.
%
%   The remaining macros \cs{fcaRenewContextChar@},
%   \cs{fcaRenewContextChar@@}, \cs{fcaRenewContextCh@r} and
%   \cs{fcaRenewContextCh@r@} are used to pass the right arguments to
%   \cs{renewcommand*}.
%    \begin{macrocode}
\def\fcaRenewContextCh@r@#1[#2][#3]#4{%
  \fca@cxt@Makechar@renewcommand{#1}[{#2}][{#3}]{#4\fca@cxt@read@line}%
}%
\def\fcaRenewContextCh@r#1[#2]#3{%
  \fca@cxt@Makechar@renewcommand{#1}[{#2}]{#3\fca@cxt@read@line}%
}%
\def\fcaRenewContextChar@@#1[#2]{%
  \@ifnextchar[{\fcaRenewContextCh@r@{#1}[{#2}]}{\fcaRenewContextCh@r{#1}[{#2}]}%
}%
\def\fcaRenewContextChar@#1#2{%
  \fca@cxt@Makechar@renewcommand{#1}{#2\fca@cxt@read@line}%
}%
\def\fcaRenewContextChar#1{%
  \@ifundefined{cxt@char@\string#1 }{%
    \PackageError{fca}{The character `\string#1' is undefined.^^J
      It must have been defined in order to be redefined.}%
    \fcaNewContextChar{#1}{}%
  }{}%
  \@ifnextchar[{\fcaRenewContextChar@@{#1}}{\fcaRenewContextChar@{#1}}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Reading context lines}
% \begin{macro}{\fca@cxt@stop}
%   This macro does nothing. It is used for checking emptiness when a
%   context line is parsed.
%    \begin{macrocode}
\def\fca@cxt@stop{}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fca@cxt@executechar}\marg{character}
%   This macro executes the command sequence associated to the meaning of a character in a context line.
%   In order to process a whole context line the macro is appended to each context character definition.
%   This gives the code the meaning of an unfolded \cs{@for} loop.
%
%   If the token is \cs{fca@cxt@stop}, the loop ends.
%    \begin{macrocode}
\def\fca@cxt@executechar#1{%
  &\@ifundefined{cxt@char@\string#1 }{%
    \PackageWarning{fca}{Undefinded character \string#1 \space in the context}%
    \let\fca@cxt@tmp=\fca@cxt@aPunkt%
  }{%
    \expandafter\let\expandafter\fca@cxt@tmp \csname
    cxt@char@\string#1 \endcsname }%
  \fca@cxt@tmp }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@cxt@read@line}\marg{character}
%   Start processing a context line. We look only at the first
%   character. If it is \cs{fca@cxt@stop}, then the line is empty and
%   nothing is to do.  Otherwise we execute the character macro. The
%   definition of the character ensures that this starts a loop until
%   eventually \cs{fca@cxt@stop} is reached.
% \begin{macrocode}
\def\fca@cxt@read@line#1{%
  \ifx#1\fca@cxt@stop \let\fca@cxt@zeile@excecutechar\@gobble \else
  \let\fca@cxt@zeile@excecutechar\fca@cxt@executechar \fi
  \fca@cxt@zeile@excecutechar{#1}%
}%
% \end{macro}
%
% \begin{macro}{\fca@cxt@Line}\marg{\line}
%   Process a whole crosstable line. We add \cs{fca@cxt@stop} at the end and start the loop by calling \cs{fca@cxt@read@line}.
% \begin{macrocode}
\def\fca@cxt@Line#1{%
  \fca@cxt@read@line#1\fca@cxt@stop }%
%    \end{macrocode}
% \end{macro}
%
% \changes{2.2}{2022/03/14}{Remove \cs{cxt@aKreuz}, \cs{cxt@aup},
% \cs{cxt@adown} and \cs{cxt@aboth}. These macros are replaced by
% calls to \cs{cxtMakeChar}.}
%
% \subsubsection{The context characters}
% Finally, we can define the predefined characters that can be used inside a formal context:
% \begin{description}
% \ItemDescribeOther[context character]{.} An empty context cell.
% \ItemDescribeOther[context character]{x} A cross in the context.
% \ItemDescribeOther[context character]{X} Alternative sign for a cross.
% \ItemDescribeOther[context character]{u} An up-arrow in the context.
% \ItemDescribeOther[context character]{d} A down-arrow in the context.
% \ItemDescribeOther[context character]{b} A cell containing both an
% up- and a down-arrow.
% \ItemDescribeOther[context character]{0} A zero in a many-valued context.
% \ItemDescribeOther[context character]{1} A one in a many-valued context.
% \ItemDescribeOther[context character]{2} Two in a many-valued context.
% \ItemDescribeOther[context character]{3} Three in a many-valued context.
% \ItemDescribeOther[context character]{4} Four in a many-valued context.
% \ItemDescribeOther[context character]{5} Five in a many-valued context.
% \ItemDescribeOther[context character]{6} Six in a many-valued context.
% \ItemDescribeOther[context character]{7} Seven in a many-valued context.
% \ItemDescribeOther[context character]{8} Eight in a many-valued context.
% \ItemDescribeOther[context character]{9} Nine in a many-valued context.
% \end{description}
%
%    \begin{macrocode}
\fcaNewContextChar .{\cxtphantom}
\fcaNewContextChar x{\fca@cxt@Kreuz}
\fcaNewContextChar X{\fca@cxt@Kreuz}
\fcaNewContextChar u{\cxtrlap{\fca@cxt@up}}
\fcaNewContextChar d{\cxtrlap{\fca@cxt@down}}
\fcaNewContextChar b{\cxtrlap{\fca@cxt@both}}
\@for\tmp:= 0,1,2,3,4,5,6,7,8,9\do{
  \edef\@tmp{
    \noexpand\fcaNewContextChar\tmp{%
      \noexpand\cxtrlap\tmp
    }%
  }%
  \@tmp
}
%    \end{macrocode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% end of cxt environment definition                                           %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \iffalse
%    \begin{macrocode}
%</fca.sty>
%    \end{macrocode}
% \fi
% \iffalse
%    \begin{macrocode}
%<*cxtinput.sty>
%    \end{macrocode}
% \fi
% \subsection{Reading Burmeister context files}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% This is the part `cxtinput.sty' : LaTeX macros for Formal Concept Analysis      %
%     input of Burmeister format contexts                                     %
%                                                                             %
%      Copyright  Tobias Schlemmer 5/09                                       %
%      Version of                  1/12                                       %
%                                                                             %
%  This program is provided under the terms of the                            %
%  LaTeX Project Public License distributed from CTAN                         %
%  archives in directory macros/latex/base/lppl.txt.                          %
%                                                                             %
%  This package defines the macro |\cxtinput|, which can input a context        %
%  file in Burmeister format                                                  %
%                                                                             %
%  Usage:                                                                      %
% \begin{verbatim}
% \begin{cxt}                                                                 %
% \cxtAlignBottom                                                             %
% \end{cxt}                                                                   %
% \end{verbatim}
%                                                                             %
% Known bugs:                                                                 %
% • The end of the .cxt file is not correctly detected.                       %
%   You will get the error message: Runaway argument?                         %
%    ! File ended while scanning use of |\fca@cxt@input@getline|.                   %
%                                                                             %
% TODO:                                                                       %
% • Make everything configurable                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% used counters
%
%    \begin{macrocode}
\newcount\fca@cxt@input@obj
\newcount\fca@cxt@input@attr
\newcount\fca@cxt@input@line
\newtoks\fca@cxt@input@contextlines
\fca@cxt@input@line0
\fca@cxt@input@contextlines{}%
%    \end{macrocode}
%
% The end user macro
%
%    \begin{macrocode}%
\newcommand\cxtinput[1]{%
%  \begingroup
  \fca@cxt@input@contextlines{}%
  \fca@cxt@input@save@nl@active%
  \fca@cxt@input@make@nl@active%
  \fca@cxt@input@input{#1}%
  \fca@cxt@input@restore@nl%
  \xdef\fca@cxt@input@tempa{\the\fca@cxt@input@contextlines}%
  %\aftergroup
  \fca@cxt@input@tempa%
%  \endgroup%
}
%    \end{macrocode}
%
% Macro holding the command for the next line
%
%    \begin{macrocode}
\def\fca@cxt@input@newline{}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\fca@cxt@input@head{%
 \fca@cxt@input@getline\fca@cxt@input@check@B
}
%    \end{macrocode}
%
% Check the “B” at the beginning of the file
%
%    \begin{macrocode}
\def\fca@cxt@input@check@B#1{%
  \def\tempa{B}\def\tempb{#1}%
  \ifx\tempa\tempb
  \typeout{Burmeister format detected}%
  \else
    \fca@cxt@input@error{No Burmeister format detected}{The \string\cxtinput macro can input Burmeister .cxt files only.}%
  \fi
  \def\fca@cxt@input@newline{%
    \fca@cxt@input@getline{\fca@cxt@input@read@cxtname}%
  }%
}
%    \end{macrocode}
%
% Check for an empty line and continue with command \#2 afterwards
%
%    \begin{macrocode}
\def\fca@cxt@input@match@mptyline#1#2{%
  \edef\tempa{#2}%
  \ifx\tempa\@empty
  \else
    \fca@cxt@input@error{Error in Burmeister format.}{At the current position an empty line is expected.}%
  \fi
  \def\fca@cxt@input@newline{%
    \fca@cxt@input@getline{#1}%
  }%
}
%    \end{macrocode}
%
%  Read the context name
%
%    \begin{macrocode}
\def\fca@cxt@input@read@cxtname#1{%
  \ifx\fca@cxtn@me\@empty
    \fcaCxtName{#1}%
  \fi
  \def\fca@cxt@input@newline{%
    \fca@cxt@input@getline{\fca@cxt@input@readobjcount}%
  }%
}
%    \end{macrocode}
%
% Read number of objects from the file
%
%    \begin{macrocode}
\def\fca@cxt@input@readobjcount#1{%
 \fca@cxt@input@obj=#1\relax
 \def\fca@cxt@input@newline{%
   \fca@cxt@input@getline\fca@cxt@input@readattrcount%
 }%
}
%    \end{macrocode}
%
% Read number of attributes
%
%    \begin{macrocode}
\def\fca@cxt@input@readattrcount#1{%
  \def\fca@cxt@input@newline{%
    \fca@cxt@input@getline{\fca@cxt@input@match@mptyline\fca@cxt@input@readobjects}%
  }%
  \fca@cxt@input@attr=#1\relax
}
%    \end{macrocode}
%
% initializes the reading of the object names
%
%    \begin{macrocode}
\def\fca@cxt@input@readobjects{%
  \ifnum\fca@cxt@input@obj>0\relax
    \def\fca@cxt@input@newline{%
      \fca@cxt@input@getline\fca@cxt@input@readobjname
   }%
   \@tempcnta=1\relax
   \let\tempa\fca@cxt@input@readobjname%
 \else
    \let\tempa\fca@cxt@input@readattributes%
  \fi
 \tempa
}
%    \end{macrocode}
%
% Read the object names
%
%    \begin{macrocode}
\def\fca@cxt@input@readobjname#1{%
   \expandafter\def\csname cxt@input@objname@\the\@tempcnta\endcsname{#1}%
   \ifnum\@tempcnta < \fca@cxt@input@obj
    \advance\@tempcnta by 1\relax
 \else
    \def\fca@cxt@input@newline{%
      \fca@cxt@input@getline\fca@cxt@input@readattributes%
    }%
  \fi
}
%    \end{macrocode}
%
% Initialize reading of attibute names
%
%    \begin{macrocode}
\def\fca@cxt@input@readattributes{%
  \ifnum\fca@cxt@input@attr>0\relax
    \def\fca@cxt@input@newline{%
      \fca@cxt@input@getline\fca@cxt@input@readattrname
    }%
    \@tempcnta=1\relax
    \def\tempa{\fca@cxt@input@readattrname}%
  \else
    \def\tempa{\fca@cxt@input@readcontext}%
  \fi
  \tempa
}
%    \end{macrocode}
% Read the attribute names and store |\atr| macros for each attribute
%    \begin{macrocode}
\def\fca@cxt@input@readattrname#1{%
  \fca@cxt@input@appendtotok{#1}\atr%
  \ifnum\@tempcnta < \fca@cxt@input@attr
    \advance\@tempcnta by 1\relax
  \else
    \def\fca@cxt@input@newline{%
      \fca@cxt@input@getline\fca@cxt@input@readcontext
    }%
  \fi
}
%    \end{macrocode}
%
% initalize reading of the cross table
%
%    \begin{macrocode}
\def\fca@cxt@input@readcontext{%
  \ifnum\fca@cxt@input@obj>0\relax
    \def\fca@cxt@input@newline{%
      \fca@cxt@input@getline
      \fca@cxt@input@readcontextline
    }%
    \@tempcnta=1\relax
    \def\tempa{\fca@cxt@input@readcontextline}%
  \else
    \def\tempa{}%
  \fi
  \tempa
}
%    \end{macrocode}
%
% Read cross table and store |\obj| macros for each object
%
%    \begin{macrocode}
\def\fca@cxt@input@readcontextline#1{%
  \expandafter\expandafter\expandafter\fca@cxt@input@appendtotok
  \expandafter\expandafter\expandafter{%
    \csname cxt@input@objname@\the\@tempcnta\endcsname}%
  {\obj{#1}}%
  \ifnum\@tempcnta < \fca@cxt@input@obj
    \advance\@tempcnta by 1\relax
  \else
    \let\fca@cxt@input@newline\relax
    \let\fca@cxt@input@endoffile\relax
  \fi
}
%    \end{macrocode}
%
% add some stuff to the token register
% needed to have some tool, which can be used with |\expandierter|
%
%    \begin{macrocode}
\def\fca@cxt@input@appendtotok#1#2{%
  \expandafter\fca@cxt@input@contextlines\expandafter{%
    \the\fca@cxt@input@contextlines
    #2{#1}%
  }%
}

\def\fca@cxt@input@error#1#2{%
  \PackageError{fca}{At line \the\fca@cxt@input@line : #1}{#2}%
  \def\fca@cxt@input@newline{}%
}%
%    \end{macrocode}
%
% Some end of file mark
%
%    \begin{macrocode}
\def\fca@cxt@input@endoffile{%
  \fca@cxt@input@error{unexpected end of file}{The context file is somehow
    inconsistent.\MessageBreak The last lines of it seem to be lost.}%
}
%    \end{macrocode}
%
% macro for usage with |\ifx|
%
%    \begin{macrocode}
\def\fca@cxt@input@@endoffile{\fca@cxt@input@endoffile}
%    \end{macrocode}
%
% swich catcode of newline to runtime mode
%
%    \begin{macrocode}
\begingroup%
\catcode`\^^M\active%
%    \end{macrocode}
%
% Define a macro to save the catcode.
% Define a macro to set the catcode.
%
%    \begin{macrocode}
\gdef\fca@cxt@input@make@nl@active{%
  \catcode`\^^M\active%
% \let\fca@cxt@input@oldcr^^M%
% \def^^M{\fca@cxt@input@newline}%
}%

\gdef\fca@cxt@input@save@nl@active{%
  \chardef\fca@cxt@input@catcode@nl=\catcode`\^^M%
% \let\fca@cxt@input@oldcr^^M%
% \def^^M{\fca@cxt@input@newline}%
}%
%    \end{macrocode}
%
% Define a macro to set the catcode.
%
%    \begin{macrocode}
\gdef\fca@cxt@input@restore@nl{%
  \catcode`\^^M\fca@cxt@input@catcode@nl\relax%
% \let\fca@cxt@input@oldcr^^M%
% \def^^M{\fca@cxt@input@newline}%
}%

\fca@cxt@input@make@nl@active%
%    \end{macrocode}
%
% reads a line from the context file.
%
%    \begin{macrocode}
\long\gdef\fca@cxt@input@getline #1#2^^M{%
  \advance\fca@cxt@input@line by 1\relax%
  \def\tempa{#2}%
  \ifx\tempa\fca@cxt@input@@endoffile%
    \tempa%
  \fi%
  #1{#2}%
  \fca@cxt@input@newline%
}%
%    \end{macrocode}
%
% read the inputfile and use its content as argument for
% |\fca@cxt@input@head|
%
%    \begin{macrocode}
\gdef\fca@cxt@input@input#1{%
  \expandafter\fca@cxt@input@head\@@input #1 %
  \fca@cxt@input@endoffile%
}
%    \end{macrocode}
%
% restore newline catcode
%
%    \begin{macrocode}
\endgroup%
%    \end{macrocode}
% \iffalse
%    \begin{macrocode}
%</cxtinput.sty>
%    \end{macrocode}
% \fi
% \iffalse
%    \begin{macrocode}
%<*fca.sty>
%    \end{macrocode}
% \fi
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \section{Environment \env{diagram} for making
%            diagrams of ordered sets, graphs and concept lattices}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% To obtain a diagram for the concept lattice of the formal
% context above, try this:
%
%
% \begin{dtxexample}{A lattice diagram}
% {\unitlength 1.2mm
% \begin{diagram}{40}{55}
%   \Node{1}{20}{10}
%   \Node{2}{35}{20}
%   \Node{3}{5}{30}
%   \Node{4}{35}{40}
%   \Node{5}{20}{50}
%   \Edge{1}{2}
%   \Edge{1}{3}
%   \Edge{2}{4}
%   \Edge{3}{5}
%   \Edge{4}{5}
%   \leftAttbox{3}{2}{2}{1.}
%   \rightAttbox{2}{2}{2}{disqualified}
%   \rightAttbox{4}{2}{2}{2.}
%   \leftObjbox{3}{2}{2}{Hamilton}
%   \rightObjbox{2}{2}{2}{Montoya}
%   \rightObjbox{4}{2}{2}{Schumacher}
% \end{diagram}}
% \end{dtxexample}
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% The syntax of the commands is                                               %
%                                                                             %
% \begin{verbatim}
% \begin{diagram}{width}{height}                                              %
%                                                                             %
%   \Node{number}{xcoordinate}{ycoordinate} % (nodenumbers from 0 to 50)      %
%                                                                             %
%   \Edge{nodenumber1}{nodenumber2}                                           %
%                                                                             %
%   \leftAttbox{nodenumber}{xoffset}{yoffset}{text1 \\ text2 \\ ... }         %
%                                                                             %
%   similarly: \rightAttbox, \centerAttbox,                                   %
%   \leftObjbox,  \centerObjbox,                                              %
%   \rightObjbox.                                                             %
%                                                                             %
% \end{diagram}
% \end{verbatim}
%                                                                             %
% The circle size can be changed with the |\fcaCircleSize| command.                %
% The value must be a positive integer, which will be mutiplied               %
% by |\unitlength|. The default is                                              %
%                                                                             %
% |\fcaCircleSize{4}|.                                                             %
%                                                                             %
% A helpful command when fine tuning a diagram is                             %
%                                                                             %
% |\Numbers|.                                                                   %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% You may wish to permanently adjust the following values to your             %
% personal preferences. They can also be changed inside each diagram          %
% environment using |\renewcommand|.                                            %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    \begin{macrocode}
\newcommand{\fca@Defaults}{% Do not change this line!  %
  \newcommand{\fcaObjectLabelStyle}{\small\baselineskip6pt\rmfamily\upshape}% %
  \newcommand{\fcaAttributeLabelStyle}{\small\baselineskip6pt\itshape}% %
  \newcommand{\fcaLabelBoxWidth}{40mm}%
  \let\Node\fca@node
  \let\Edge\fca@edge
  \iffca@compat@macros
  \else
    \let\fcaObjectLabelStyle\fcaObjectLabelStyle
    \let\AttributeLabelStyle\fcaAttributeLabelStyle
    \let\LabelBoxWidth\fcaLabelBoxWidth
    \let\EdgeThickness\fcaEdgeThickness
    \let\NodeThickness\fcaNodeThickness
    \let\Numbers\fcaNumbers
    \let\noNumbers\fcaNoNumbers
    \let\NodeColor\fcaNodeColor
    \let\ColorNode\fcaColorNode
  \fi
  \let\leftAttbox\fca@leftAttbox
  \let\centerAttbox\fca@centerAttbox
  \let\rightAttbox\fca@rightAttbox
  \let\leftObjbox\fca@leftObjbox
  \let\centerObjbox\fca@centerObjbox
  \let\rightObjbox\fca@rightObjbox
}% %
\newboolean{fca@connectors}\setboolean{fca@connectors}{true}% %
\iffca@compat@macros
  \newcommand{\diagramXoffset}{0}% %
  \newcommand{\diagramYoffset}{0}% %
  \newcommand{\fcaDiagramXoffset}{\diagramXoffset}% %
  \newcommand{\fcaDiagramYoffset}{\diagramYoffset}% %
\else
  \newcommand{\fcaDiagramXoffset}{0}% %
  \newcommand{\fcaDiagramYoffset}{0}% %
\fi
\newcommand*{\fca@xunitlength}{\unitlength}%
\newcommand*{\fca@yunitlength}{\unitlength}%
\newcommand*{\fca@edge@thickness}{.8pt}% %
\newcommand*{\fca@node@thickness}{1pt}% %
\newcommand*{\fca@transform}{}%
\newcommand*{\fca@options}{}%
\newcommand*{\fca@defaultoptions}{}%
\newcommand*{\fca@usepath}{}%
\newcommand*{\fca@node@number@prefix}{\pgfkeysvalueof{/fca/namespace}\space node\space}%
\newcommand*{\fca@node@number@suffix}{\space number}%
\newcommand*{\fca@label@edge@thickness}{\@wholewidth}%
\newcommand*{\fca@label@at}{center}% anchor of node
\newcommand*{\fca@label@shift@x}{0pt}%
\newcommand*{\fca@label@shift@y}{0pt}%
\newcommand*{\fca@label@shift@x@sign}{}
\newcommand*{\fca@label@shift@y@sign}{}
\newcommand*{\fca@label@type}{attributes}%
\newcommand*{\fca@label@position}{right}%

\newcommand*\fca@none{none}
\newcommand*\fca@firstofthree[3]{#1}
\newcommand*\fca@secondofthree[3]{#2}
\newcommand*\fca@thirdofthree[3]{#3}
\newcommand*\fca@testoption[1]{%
  \def\fca@tempa{#1}%
  \ifx\empty\fca@tempa
    \let\fca@tempb\fca@thirdofthree
  \else
    \def\fca@tempb{\pgfkeysnovalue}%
    \ifx\fca@tempa\fca@tempb
      \let\fca@tempb\fca@thirdofthree
    \else
      \ifx\fca@tempa\fca@none
        \let\fca@tempb\fca@secondofthree
      \else
        \let\fca@tempb\fca@firstofthree
      \fi
    \fi
  \fi
  \fca@tempb
}
%    \end{macrocode}
%
% Sometimes (e.g. for large contexts) it is not possible to arrange
% all nodes in such a way that the edges do not cross any nodes. In
% such case its often worse not to print any lattice than to live with
% some compromises. I such situations we must divide the lattice into
% several layers. Fortunately, \PGF{} and \TikZ{} support to assign
% certain graphical objects into layers. This allows us, to keep the
% order of defining nodes before the edges, while the nodes are drawn
% on top of the edges (see below).
%
% Please, do not confuse implementation layers (\TikZ, \PGF{} Basic
% Layer and drivers) with graphical layers. Graphical layers can be
% thought of slide overlays stacked on top of each other. You can draw
% on one layer, use the positions in another layer for drawing objects
% and return to the original layer to add further content.
%
% The formal definition and documentation of layers can be found in
% the \TikZ{} and \PGF{} manual at \url{https://tikz.dev} or in your
% local tex installation calling either texdoctk or -- on the command
% line using the command “|texdoc pgfmanual|” in the section
% \href{https://tikz.dev/base-layers}{“IX The Basic Layer”
% $\rightarrow$ “Layered Graphics”}.
%
% \begin{macro}{\fcaLayer}\marg{fca entity}\marg{layer}
%
%   This macro assigns an entity to an existing PGF layer. The layer
%   can be accessed in two ways: Ether by using the environment
%   \env{pgfonlayer} with the argument \meta{layer} or by putting the
%   material between the two macros |\fca@|\meta{entity}|layer| and
%   |\fca@end|\meta{entity}|layer|. As the at sign shows, the latter
%   form is intended for internal use in \LaTeX{} packages.
%    \begin{macrocode}
\newcommand*\fcaLayer[2]{%
  \def\@tempa{main}%
  \edef\@tempb{#2}%
  \ifx\@tempb\@empty\let\@tempb\@tempa\fi
  \ifx\@tempa\@tempb
    \def\@tempa{}%
    \def\@tempb{}%
  \else
    \def\@tempa{%
      \begin{pgfonlayer}{#2}%
      }
    \def\@tempb{%
      \end{pgfonlayer}%
    }
  \fi
  \expandafter\let\csname fca@#1layer\endcsname\@tempa
  \expandafter\let\csname fca@end#1layer\endcsname\@tempb
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@labelslayer}
% \begin{macro}{\fca@endlabelslayer}
% \begin{macro}{\fca@labelconceptslayer}
% \begin{macro}{\fca@endlabelconceptslayer}
%
% Since objects and attributes can be collected on two different
% layers, and the same is true for the object and attribute overlays
% of concepts, we use two meta layers to select the correct layer
% depending on the type of the current label. However, help lines (so
% called connectors) are always on the same layer for both object
% labels and attribute labels.
%    \begin{macrocode}
\newcommand*{\fca@labelslayer}{\csname fca@\fca@label@type layer\endcsname}
\newcommand*{\fca@endlabelslayer}{\csname fca@end\fca@label@type layer\endcsname}
\newcommand*{\fca@labelconceptslayer}{\csname fca@\fca@label@type conceptlayer\endcsname}
\newcommand*{\fca@endlabelconceptslayer}{\csname fca@end\fca@label@type conceptlayer\endcsname}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \begin{macro}{\fcaNewLayer}\marg{fca entity}\marg{layer}
%
% This macro is similar to \cs{fcaLayer}, but it creates the PGF
% layer \meta{layer} before assinging it to the macros.
%    \begin{macrocode}
\newcommand*{\fcaNewLayer}[2]{%
  \pgfdeclarelayer{#2}%
  \fcaLayer{#1}{#2}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fcaDeclareLayers} creates a standard set of
%   layers. The layers are assigned and used in the following way:
%   \begin{description}
%  \item[{nodes}]{main}
%  \item[{nodenumbers}]{\pgfkeysvalueof{/fca/namespace} node numbers}
%  \item[{attributes}]{\pgfkeysvalueof{/fca/namespace} attributes}
%  \item[{objects}]{\pgfkeysvalueof{/fca/namespace} objects}
%  \item[{attributesconcept}]{%
%    \pgfkeysvalueof{/fca/namespace} attribute concepts}
%  \item[{objectsconcept}]{%
%    \pgfkeysvalueof{/fca/namespace} object concepts}
%  \item[{edges}]{\pgfkeysvalueof{/fca/namespace} edges}
%  \item[{connectors}]{\pgfkeysvalueof{/fca/namespace} connectors}
%  \item[{}]{\pgfkeysvalueof{/fca/namespace} above nodes}
%  \item[{}]{\pgfkeysvalueof{/fca/namespace} below nodes}
%   \end{description}
%    \begin{macrocode}
\newcommand*{\fcaDeclareLayers}{%
  \fcaLayer{nodes}{main}
  \fcaNewLayer{nodenumbers}{\pgfkeysvalueof{/fca/namespace} node numbers}
  \fcaNewLayer{attributes}{\pgfkeysvalueof{/fca/namespace} attributes}
  \fcaNewLayer{objects}{\pgfkeysvalueof{/fca/namespace} objects}
  \fcaNewLayer{attributesconcept}{%
    \pgfkeysvalueof{/fca/namespace} attribute concepts}
  \fcaNewLayer{objectsconcept}{%
    \pgfkeysvalueof{/fca/namespace} object concepts}
  \fcaNewLayer{edges}{\pgfkeysvalueof{/fca/namespace} edges}
  \fcaNewLayer{connectors}{\pgfkeysvalueof{/fca/namespace} connectors}
  \pgfdeclarelayer{\pgfkeysvalueof{/fca/namespace} above nodes}
  \pgfdeclarelayer{\pgfkeysvalueof{/fca/namespace} below nodes}
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fcaSetLayers} defines the order of the layers used in
%   a diagram. The order can changed using \cs{pgfsetlayers}, if
%   necessary. Note: All used layers should occur in this
%   list. Otherwise they will be ignored by PGF.
%    \begin{macrocode}
\newcommand*{\fcaSetLayers}{%
  \pgfsetlayers{%
    \pgfkeysvalueof{/fca/namespace} edges,%
    \pgfkeysvalueof{/fca/namespace} connectors,%
    \pgfkeysvalueof{/fca/namespace} below nodes,%
    main,%
    \pgfkeysvalueof{/fca/namespace} above nodes,%
    \pgfkeysvalueof{/fca/namespace} node numbers,%
    \pgfkeysvalueof{/fca/namespace} attribute concepts,%
    \pgfkeysvalueof{/fca/namespace} object concepts,%
    \pgfkeysvalueof{/fca/namespace} attributes,%
    \pgfkeysvalueof{/fca/namespace} objects%
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fcaNoLayers} assigns all layers to the current
% layer. This means the graphic objects are drawn one on top of the
% other in the order they appear in the source code. This is the
% default behaviour of the |fca| packages.
%    \begin{macrocode}
\newcommand*\fcaNoLayers{%
  \fcaLayer{nodes}{main}%
  \fcaLayer{nodenumbers}{main}%
  \fcaLayer{attributes}{main}%
  \fcaLayer{objects}{main}%
  \fcaLayer{attributesconcept}{main}%
  \fcaLayer{objectsconcept}{main}%
  \fcaLayer{edges}{main}%
  \fcaLayer{connectors}{main}%
}
\fcaNoLayers
%    \end{macrocode}
%
% \end{macro}{\fcaLayers} instructs a diagram to collect the different
% parts of a diagram into layers. By default later parts are drawn
% above prior parts. So edges are drawn above nodes. In simple
% lattices this is not a problem, but for more complex lattice
% diagrams it may not be completely possible to draw all edges between
% nodes and labels.
%    \begin{macrocode}
\newcommand*{\fcaLayers}{%
  \fcaDeclareLayers
  \fcaSetLayers
}
%    \end{macrocode}
%
%
%   Now, two tests (one for PGF and \TikZ):
% \begin{dtxexample}*{A diagram with layers (left) and flat (right) }
%   \begin{diagram}
%     \fcaLayers
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \Node(3)(20,30)
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \Edge(1)(5)
%     \Edge(2)(4)
%     \Edge(4)(5)
%     \leftAttbox(3){1.}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \leftObjbox(3){Hamilton}
%     \rightObjbox(2){Massa}
%     \rightObjbox(4){Alonso}
%     \end{diagram}
%   \begin{diagram}
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \Node(3)(20,30)
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \Edge(1)(5)
%     \Edge(2)(4)
%     \Edge(4)(5)
%     \leftAttbox(3){1.}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \leftObjbox(3){Hamilton}
%     \rightObjbox(2){Massa}
%     \rightObjbox(4){Alonso}
%     \end{diagram}
% \end{dtxexample}
%
% \iffcatikzdoc
% \begin{dtxexample}*{A \protect\TikZ{} diagram (left: with layers,
% right: without layers)}
%   \begin{tikzdiagram}[/tikz/x=.1cm,/tikz/y=.1cm]%
%     \fcaLayers
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \Node[/tikz/opacity=0.8](3)(20,30)
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \Edge[draw=black,/tikz/opacity=0.3](1)(5)
%     \Edge[/tikz/arrows=<->](2)(4)
%     \Edge[/tikz/opacity=0.3](3)(5)
%     \Edge(4)(5)
%     \leftAttbox[/tikz/opacity=0.3](3){1.}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \leftObjbox[/tikz/opacity=0.3](3){Hamilton}
%     \rightObjbox(2){Massa}
%     \rightObjbox(4){Alonso}
%     \draw (1.center) -- (4.center);
%     \begin{pgfonlayer}{fca below nodes}
%       \draw (5.center)--(2.center);
%     \end{pgfonlayer}
%   \end{tikzdiagram}
%   \begin{tikzdiagram}[/tikz/x=.1cm,/tikz/y=.1cm]%
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \Node[/tikz/opacity=0.3](3)(20,30)
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \Edge[/tikz/draw=black,/tikz/opacity=0.3](1)(5)
%     \Edge[/tikz/arrows=<->](2)(4)
%     \Edge(4)(5)
%     \leftAttbox[/tikz/opacity=0.3](3){1.}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \leftObjbox[/tikz/opacity=0.3](3){Hamilton}
%     \rightObjbox(2){Massa}
%     \rightObjbox(4){Alonso}
%     \draw (1.center) -- (4.center);
%     \draw (5.center)--(2.center);
%   \end{tikzdiagram}
% \end{dtxexample}
% \fi
%
%    \begin{macrocode}
% We allow to select the label type and positioning independently.
% This function executes the right positioning settings.
\newcommand\fca@dolabelposition{%
  \pgfkeysgetvalue{/fca/label/type}{\@tempa}%
  \pgfkeysgetvalue{/fca/label/position}{\@tempb}%
  \ifx\pgfnovalue\@tempa
  \else
    \ifx\pgfnovalue\@tempb
    \else
      \pgfkeysalso{/fca/label/\@tempa{} position=\@tempb}%
    \fi
  \fi
}

\newcommand*\fcaNewLabelType{%
  \@ifstar{\fca@NewLabelType}{\fca@NewL@belType}%\fistar
}
\newcommand*\fca@NewLabelType[1]{%
  \pgfqkeys{/fca/label}{%
    type/#1/.style={type=#1},
    #1 position/.is choice,
  }%
}
\newcommand*\fca@NewL@belType[1]{%
  \fca@NewLabelType{#1}%
  \pgfqkeys{/fca/label}{%
    #1/.style={type=#1}%
  }%
}
\newcommand*\fcaNewLabelPosition{%
  \@ifstar{\fca@NewLabelPosition}{\fca@NewL@belPosition}%\fistar
}
\newcommand*\fca@NewLabelPosition[1]{%
  \pgfqkeys{/fca/label}{%
    position/#1/.style={position=#1},
  }%
}
\newcommand*\fca@NewL@belPosition[1]{%
  \fca@NewLabelPosition{#1}%
  \pgfqkeys{/fca/label}{%
    #1/.style={position=#1}%
  }%
}

%    \end{macrocode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% Changing the default values                                                 %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Generate some parameters which may be shared with \TikZ}
%    \begin{macrocode}
\newcommand*\fca@generate@tikz@parameter[3]{%
  \pgfqkeys{/fca/#1}{.initial={#2},.value required}
}
\newcommand*\fca@generate@tikz@parameters{%
  \@for \fca@tmp:=%
  {font}{}{\tikz@textfont},%
  {node font}{}{\tikz@node@textfont},%
  {text opacity}{}{\tikz@textopacity},%
  {text width}{\pgfkeysnovalue}{\tikz@text@width},%
  {text height}{}{\tikz@text@height},
  {text depth}{}{\tikz@text@depth},
  {text action}{}{\tikz@text@action},
  {options}{}{\tikz@options},%\newcommand*{\fca@node@fill}{white}%
  {anchor}{}{\tikz@anchor},
  {shape}{}{\tikz@shape}
  \do {
    \expandafter\fca@generate@tikz@parameter\fca@tmp
  }
}
\fca@generate@tikz@parameters
%    \end{macrocode}
% \iffalse
%</fca.sty>
%<*tikz>
% \fi
%
% \subsection{set up what we need from tikz}
%    \begin{macrocode}
\RequirePackage{fca}
\let\fca@tikz@without@library\relax
\def\fca@generate@tikz@parameter#1#2#3{%
  \pgfkeysdef{/fca/#1}{\pgfkeys{/tikz/#1=##1}}
  \pgfkeyssetvalue{/fca/#1}{#3}%
}
%    \end{macrocode}
%   \paragraph{Options that are directly forwarded to \TikZ{}} If they
%   are not documented somewhere else, their implementation needs
%   \filenm{fca.sty} fröm the \TikZ{library} \filenm{fca}.
%   \begin{description}
% \ItemDescribeOption{shape} shape of the node
% \ItemDescribeOption{text ragged} node text is ragged right with hyphenation%
% \ItemDescribeOption{text badly ragged} node text is ragged right
% nearly without hyphenation (normal \LaTeX{} mode)%
% \ItemDescribeOption{text ragged left} node text is ragged left%
% \ItemDescribeOption{text badly ragged left} node text is ragged left
% nearly without hyphenation (normal \LaTeX{} mode)%%
% \ItemDescribeOption{text justified} The text is spread to fit the
% border on both sides of the text box (typically with hyphanation)%
% \ItemDescribeOption{text centered} The node text is horizontally centered%
% \ItemDescribeOption{text badly centered}  node text is centered horizontally
% nearly without hyphenation (normal \LaTeX{} mode)%%%
% \ItemDescribeOption{even odd rule} self overlapping paths are filled
% so that every border is an outside border (an even number of borders
% in each direction means outside and an odd number means inside.
% \ItemDescribeOption{nonzero rule} The default rule of \TikZ{} for
% filling paths. The algorithm is described in the
% \href{https://tikz.dev/tikz-actions#sec-15.5.2}{\TikZ{} documentation}
% (see \cmd{texdoc pgfmanual.pdf}).
% \ItemDescribeOption{fill opacity} The opacity of the filled copy of
% the path or node
% \ItemDescribeOption{opacity} General option of the opacity%
% \ItemDescribeOption{blend mode} This option defines, how thransparency
% changes the colors of semitransparent objects. See the
% \href{https://tikz.dev/tikz-transparency#sec-23.3}{\TikZ{}
%   documentation} for further details.
% \ItemDescribeOption{color} Sets stroke and fill color (border and
% interior) to the same color
% \ItemDescribeOption{rotate} rotate some path%
% \ItemDescribeOption{solid} draw lines solid%
% \ItemDescribeOption{dotted} draw lines dotted%
% \ItemDescribeOption{loosely dotted} draw lines dotted with more space
% between the dots%
% \ItemDescribeOption{densely dotted} draw lines dotted with less space
% between the dots%
%   \end{description}
%    \begin{macrocode}
\fca@generate@tikz@parameters
\@for \@tempa:=%
shape,
text ragged,%
text badly ragged,%
text ragged left,%
text badly ragged left,%
text justified,%
text centered,%
text badly centered,%
even odd rule,%
nonzero rule,%
fill opacity,%
opacity,%
blend mode,%
color,%
rotate,%
solid,%
dotted,%
loosely dotted,%
densely dotted%
\do {
  \edef\@tempb{%
    \noexpand\pgfkeysdef{/fca/\@tempa}{\noexpand\pgfqkeys{/tikz}{\@tempa={##1}}}%
  }%
  \@tempb
}
\pgfkeysdef{/fca/options}{\tikz@addoption{#1}}
\pgfkeysdef{/fca/stroke}{%
  \pgfqkeys{/tikz}{draw={#1}}%
  \fca@testoption{#1}{%
    \fca@append\fca@usepath{stroke,}%
  }{}{%
    \fca@append\fca@usepath{stroke,}%
  }%
}
\pgfkeysdef{/fca/fill}{%
  \pgfqkeys{/tikz}{fill={#1}}%
  \fca@testoption{#1}{%
    \fca@append\fca@usepath{fill,}%
  }{}{%
    \fca@append\fca@usepath{fill,}%
  }%
}
\def\fca@options{\tikz@options}%
\def\fca@defaultoptions{\tikz@options}%
\def\fca@transform{\tikz@transform}%
\@ifundefined{tikz@transform}{\let\tikz@transform\empty}{}
\let\fca@ifintikz\@secondoftwo
\tikzaddtikzonlycommandshortcutlet\fca@ifintikz\@firstoftwo
\fcaset{%
  attributes left/.append style={
    align=flush right
  },
  attributes center/.append style={
    align=flush center
  },
  attributes right/.append style={
    align=flush left
  },
  objects left/.append style={
    align=flush right
  },
  objects center/.append style={
    align=flush center
  },
  objects right/.append style={
    align=flush left
  }
}

%    \end{macrocode}
%
%    \begin{macrocode}
\let\fca@notikz@parse@paren@vector\fca@parse@paren@vector
\newcommand\fca@tikz@parse@paren@vector[3]{%
  \def\tikz@coordinate@caller{%
    \fca@notikz@parse@paren@vector{#1}{#2}{#3}%
  }%
  \tikz@scan@one@point \tikz@@coordinate@at@math
}

\newcommand\fca@tikz@oldnode[4]{%
  \begin{pgfscope}%
    \fca@nodeslayer
    \path (#3,#4) node[
      anchor=center,
      shape=circle,
      /fca/.cd,
      /fca/every node/.try,
      /fca/every concept/.try,
      #1]
      (#2) {} ;%
    \fca@endnodeslayer
    \ifthenelse{\boolean{fca@CircledNumbers}}{%
      \fca@nodenumberslayer
      \path (#2)
        node[
        shape=circle,
        anchor=center,
        /fca/.cd,
        /fca/every node/.try,
        /fca/every concept/.try,
        #1
        /fca/.cd,
        /fca/node number,
        draw=none]%
        (#2 number)
        {#2};%
      \fca@endnodenumberslayer
    }{}%
  \end{pgfscope}%
  \ignorespaces
}
\newcommand{\fca@tikz@oldedge}[3]{%
  \fca@edgeslayer
  \path[draw,/fca/.cd,#1] (#2) -- (#3);%
  \fca@endedgeslayer
  \ignorespaces
}

\newcommand\fca@tikz@labelBox[1]{%
  \begin{scope}%
    \fcaset{every node/.try,every label/.try,#1}%
    \edef\@tempa{\pgfkeysvalueof{/fca/pgfnode}}%
    \xdef\fca@temp@node@name{%
      \expandafter\fca@remove@anchor\expandafter{\@tempa}%
    }%
    \fca@labelslayer
      \path[/fca/.cd,every node/.try,every label/.try,#1]
      (\fca@temp@node@name.\fca@label@at)
      ++(\fca@label@shift@x,\fca@label@shift@y)
      node[shape=rectangle] (%
        \pgfkeysvalueof{/fca/label/name prefix}%
        \pgfkeysvalueof{/fca/node}%
        \pgfkeysvalueof{/fca/label/name suffix}%
      ){%
        \pgfkeysvalueof{/fca/node contents}%
      };%
    \fca@endlabelslayer
    \iffca@connectors
      \begin{scope}
        \fca@connectorslayer
        \path[draw,/fca/.cd,#1,every label edge/.try,/tikz/.cd]
        (\pgfkeysvalueof{/fca/node}) --
        (%
        \pgfkeysvalueof{/fca/label/name prefix}%
        \pgfkeysvalueof{/fca/node}%
        \pgfkeysvalueof{/fca/label/name suffix}%
        .\pgfkeysvalueof{/fca/anchor}) ;
        \fca@endconnectorslayer
      \end{scope}%
    \fi
    \begin{scope}
      \fcaset{shape=coordinate,#1}%
      \fcaset{%
        every label concept/.try}%
      \fcaset{%
        label concept/.try
      }%
      \def\@tempa{coordinate}%
      \ifx\@tempa\tikz@shape
      \else
        \fca@labelconceptslayer
        %\edef\fca@tempa{
        \path
          (\fca@temp@node@name.\fca@label@at)%
          node[draw,
          /fca/.cd,
          shape=coordinate,
          #1,
          every label concept/.try,
          label concept/.try]
        (\pgfkeysvalueof{/fca/label/name prefix}%
          \pgfkeysvalueof{/fca/node}%
          \pgfkeysvalueof{/fca/label/name suffix}%
          ){};
        % \pgfsetstrokecolor{\fca@node@color}%
        %\pgfnode{}{\pgfkeysvalueof{/fca/anchor}}{}{}%
        \fca@endlabelconceptslayer
      \fi
    \end{scope}
  \end{scope}%
  \ignorespaces
}
\newcommand\fca@tikz@startdiagram[1][]{%
  \fca@notikz@startdiagram%
  \fca@tikz@diagram@
}
\newcommand\fca@tikz@Defaults{
  \fca@notikz@Defaults
  \pgfkeysgetvalue{/tikz/name prefix}{\fca@tikz@origprefix}%
  \pgfkeysgetvalue{/fca/name prefix}{\@tempb}%
  \let\@tempa\fca@tikz@origprefix
  \fca@concat\@tempa\@tempb%
  \pgfqkeys{/tikz}{%
    name prefix/.expand once=\@tempa
  }%
  \pgfkeysgetvalue{/fca/name suffix}{\@tempa}%
  \pgfkeysgetvalue{/tikz/name suffix}{\@fca@tikz@origsuffix}%
  \fca@concat\@tempa\@fca@tikz@origsuffix%
  \pgfqkeys{/tikz}{%
    name suffix/.expand once=\@tempa
  }%
  \pgfkeyssetvalue{/fca/name prefix}{%
    \pgfkeysvalueof{/tikz/name prefix}%
  }%
  \pgfkeyssetvalue{/fca/name suffix}{%
    \pgfkeysvalueof{/tikz/name suffix}%
  }%
}
\tikzaddtikzonlycommandshortcutlet\fca@oldnode\fca@tikz@oldnode
\tikzaddtikzonlycommandshortcutlet\fca@oldedge\fca@tikz@oldedge
\tikzaddtikzonlycommandshortcutlet\fca@@labelBox\fca@tikz@labelBox
\tikzaddtikzonlycommandshortcutlet\fca@parse@paren@vector\fca@tikz@parse@paren@vector
\tikzaddtikzonlycommandshortcutlet\fca@notikz@Defaults\fca@Defaults
\tikzaddtikzonlycommandshortcutlet\fca@Defaults\fca@tikz@Defaults
%    \end{macrocode}
% \iffalse
%</tikz>
%<*fca.sty>
% \fi
%
% \begin{macro}{\fcaset}\marg{key value list}
%   Sets the options for the following operations. Possible options
%   are listed below. The beginning \optn{/fca/} can be omitted as it
%   is provieded by the macro \cs{fcaset}. \cs{fcaset}\marg{key value
%   list} is expanded to \cs{pgfqkeys}\optn{{/fca}}\marg{key value list}.
%
%   This macro is similar to \cs{pgfkeys}, except that it
%   sets \filenm{/fca} as default path. This is a powerful macro that
%   cannot be described here in full detail. The full documentation
%   can be found in the \href{https://tikz.dev/pgfkeys}{\PGF/\TikZ{}
%   Manual} in \filenm{pgfmanual.pdf} of your \PGF{} documentation.
%
%
%    \begin{macrocode}
\newcommand*\fcaset{\pgfqkeys{/fca}}
%    \end{macrocode}
% \end{macro}
%
% Options can be set globally outside
%
% \begin{description}
% \ItemDescribeOption{/fca/font} font selection macros used inside
% nodes (forwarded to \optn{/tikz/font} when loaded as TikZ library).
% \ItemDescribeOption{/fca/node font} The font selection macros that
% are used during node size calculation
% (forwarded to \optn{/tikz/node font} when loaded as TikZ library).
% \ItemDescribeOption{/fca/text opacity} Opacity of the text in nodes
% (forwarded to \optn{/tikz/text opacity} when loaded as TikZ library).
% \ItemDescribeOption{/fca/text width} Width of the text in nodes
% (allows multiline nodes e.g. multi-line labels)
% (forwarded to \optn{/tikz/text width} when loaded as TikZ library).
% \ItemDescribeOption{/fca/text height} height of the text box of
% \PGF{} nodes
% (forwarded to \optn{/tikz/text height} when loaded as TikZ library).
% \ItemDescribeOption{/fca/text depth} depth of the text box of \PGF{}
% nodes
% (forwarded to \optn{/tikz/text depth} when loaded as TikZ library).
% \ItemDescribeOption{/fca/text action} \textbf{Undocumented extension
% to \TikZ} Stores the alignment setup macros \TikZ{} nodes.
% \ItemDescribeOption{/fca/options}  \textbf{Undocumented extension
% to \TikZ} direct access to \cs{tikz@options}.
% \ItemDescribeOption{/fca/anchor} specifies the anchor of a node to
% be used for placement
% (forwarded to \optn{/tikz/anchor} when loaded as TikZ library).
% \ItemDescribeOption{/fca/shape} the shape of a node (concept or label)
% (forwarded to \optn{/tikz/shape} when loaded as TikZ library).
% \ItemDescribeOption{/fca/connector} Draw a connector line between the node
% and the label. Values are \optn{true} and \optn{false}.
% \ItemDescribeOption{/fca/namespace} Namespace used in name prefixes and
% layer names, Default: fca, \textbf{value required}
% \ItemDescribeOption{/fca/name prefix} Pattern to be added before node
% names. This can be interesting when a diagram is inside a
% \env{tikzpicture} or \env{pgfpicture} environment in order to
% address the diagram nodes. Default: |\pgfkeysvalueof{/fca/namespace}\space node\space|,
%   \textbf{value required}
% \ItemDescribeOption{/fca/name suffix} Default: empty,
%   \textbf{value required}
% \ItemDescribeOption{/fca/every node/.style} Style to be executed at the
% beginning of every node (both labels as well as concepts). Default: empty
% \ItemDescribeOption{/fca/every concept/.style} Style to be executed at
% every concept node (when calling \cs{Node}).
% Default:
% \begin{verbatim}
% {%
%   radius = 2,
%   fill=white,
%   draw=black
% },
% \end{verbatim}
% \ItemDescribeOption{/fca/every attributes/.style} Style that is executed
% whenever an attribute label is typeset. Default:
% \begin{verbatim}
% {%
%   font=\small\baselineskip1em\rmfamily\itshape
% }%
% \end{verbatim}
% \ItemDescribeOption{/fca/every objects/.style} Style that is executed
% whenever an object label is placed in the diagram. Defaul:
% \begin{verbatim}
% {%
%   font=\small\baselineskip1em\rmfamily\upshape
% }
% \end{verbatim}
% \ItemDescribeOption{/fca/every edge/.style} Style that is executed
% whenever an edge betwee two concepts is drawn using
% \cs{Edge}. Default: empty.
% \ItemDescribeOption{/fca/every label edge/.style}
%   Style that is drawn whenever a connector between a concept and one
%   of its labels is drawn. Default:
% \begin{verbatim}
% {
%   dotted, draw=black
% }
% \end{verbatim}
%   \ItemDescribeOption{/fca/font}
%   Font to be used inside labels. This is the actually set font.
%   Default: |\small\baselineskip1em\rmfamily|
%
% \watchout the font is applied after the node size has been
% calculated. The font size for the size calculations must be set
% using the option \optn{node font}.
% \ItemDescribeOption{/fca/shape} Shape of the nodes. Default: circle,
% \ItemDescribeOption{/fca/minimum width} Set the minimum width of a node
% or label.
% This is an alias of \optn{/pgf/minimum width}.
% \ItemDescribeOption{/fca/minimum height} set the minimum height of a node
% or label. This is an alias of /pgf/minimum height.
% \ItemDescribeOption{/fca/minimum size} Set both \optn{minimum width} and
% \optn{minimum height}. This is an alias of /pgf/minimum size.
% \ItemDescribeOption{/fca/inner xsep} Minimum horizontal distance between
% node content and node border (same for labels). This is an alias of /pgf/inner xsep.
% \ItemDescribeOption{/fca/inner ysep} Minimum vertical distance between
% node content and node border (same for labels). This is an alias of /pgf/inner ysep.
% \ItemDescribeOption{/fca/inner sep} Sets both \optn{inner xsep} and
% \optn{inner ysep}. This is an alias of /pgf/inner sep.
% \ItemDescribeOption{/fca/outer xsep} Minimum horizontal distance between
% node border and the next elements. This is an alias of /pgf/outer xsep.
% \ItemDescribeOption{/fca/outer ysep} Minimum vertical distance between
% node border and the next elements. This is an alias of /pgf/outer ysep.
% \ItemDescribeOption{/fca/outer sep} Sets both \optn{inner xsep} and
% \optn{inner ysep}. This is an alias of /pgf/outer sep.
% \ItemDescribeOption{/fca/radius} Set the radius of circled nodes in |\unitlength|
% \ItemDescribeOption{/fca/anchor} Determines which anchor should be
% represented by the given coordinates.
%   \textbf{value required}
% \ItemDescribeOption{/fca/node number/.style} Style of the node names
% (traditionally numbers) of the diagram when \cs{fcaNumbers} is used.
% Default:
% \begin{verbatim}
% {
%   node font=\tiny,
%   font=\tiny
% }
% \end{verbatim}
% \ItemDescribeOption{/fca/color} Change the color of the things to be drawn
% \ItemDescribeOption{/fca/stroke} Draw the line in the current object. If
% a value is given it is interpreted to be the line colour.
% \ItemDescribeOption{/fca/draw} This is an alias of \optn{/fca/stroke}.
% \ItemDescribeOption{/fca/fill} Fill the current object with the colour
% given as value or the default fill colour.
% \ItemDescribeOption{/fca/text} The colour that is used for texts in
% nodes. Default: |pgfstrokecolor|, that is the line colour.
%   \textbf{value required}
% \ItemDescribeOption{/fca/label type} This is an alias of \optn{/fca/label/type}.
% \ItemDescribeOption{/fca/label position} This is an alias of \optn{/fca/label/position}.
% \ItemDescribeOption{/fca/pgfnode} Pattern used to construct node names
% (if \TikZ{} is not loaded). \textbf{value required} Default:
% \begin{verbatim}
% \pgfkeysvalueof{/fca/name prefix}\pgfkeysvalueof{/fca/node}\pgfkeysvalueof{/fca/name suffix}a
% \end{verbatim}
% \ItemDescribeOption{/fca/node} Name of the node where the label should be
% attached to. Default: {},
%   \textbf{value required}
% \ItemDescribeOption{/fca/node contents} Contents of the new node to be
% drawn. This is mainly used for labels. Default: {},
%   \textbf{value required}
% \ItemDescribeOption{/fca/shift/x} \textbf{value required}
% \ItemDescribeOption{/fca/shift/y} \textbf{value required}
% \ItemDescribeOption{/fca/shift=\{\parg{x,y}\}} Offset values for
% shifting labels from their default position. Usually the offset is
% added to the coordinates where the anchor would be. Prior to version
% 3.0 \filenm{fca.sty} used distences to shift the nodes. Both Schemes
% are valid and have their benefits. The current implementation
% follows the scheme of \TikZ{}.
%
% \watchout[changes in 3.0] For compatibility reasons the sign of the
% shift parameter is changed when the old syntax for labels is used.
%
% \ItemDescribeOption{/fca/shift/x/signv2.1} \textbf{value required}
% \ItemDescribeOption{/fca/shift/y/signv2.1} \textbf{value required}
% These parameters define how the distance values in the old syntax
% should be interpreted by \LaTeX{}. You should change this parameter
% only, if you really know what you are doing. Otherwise you could
% easily mess up the diagram.
%
% \ItemDescribeOption{/fca/rotate} rotate the current object
% \ItemDescribeOption{/fca/solid} Draw lines as solid lines
% \ItemDescribeOption{/fca/dotted} Draw lines as dotted lines
% \ItemDescribeOption{/fca/loosely dotted} Draw lines as dotted lines with
% more space between the dots
% \ItemDescribeOption{/fca/densely dotted} Draw lines as dotted lines with
% less space between the dots
% \ItemDescribeOption{/fca/every label/.style} A style that describes how
% object and attribute labels should be decorated. Default:
% \begin{verbatim}
% {
%   text=pgfstrokecolor,
%   /pgf/outer sep=0pt,
%   /pgf/inner sep=0pt,
% }
% \end{verbatim}
%
% \ItemDescribeOption{/fca/node/thickness} line width of the nodes
%   \textbf{value required}
% \ItemDescribeOption{/fca/node/radius} Node radius
%  \ItemDescribeOption{/fca/node/layer} Layer where the node shall be
%  put in.
% \ItemDescribeOption{/fca/node/numbers}  \meta{true} or \meta{false},
% defaults to \meta{true}, if given without value.  Draw \PGF{} node names of the
% concepts in the diagram.
%
% \ItemDescribeOption{/fca/node/number prefix}
%   \textbf{value required} Prefix to be added to the node name for
%   the name of the node that contains the node name
% \ItemDescribeOption{/fca/node/number suffix}
%   \textbf{value required} Prefix to be added to the node name for
%   the name of the node that contains the node
%   name
% \watchout[Confused?] The printed node name is a node
%   itself. And every node in \PGF{} must have a unique name. This is
%   constructed by appending this prefix to the already existing
%   prefix and prepending this suffix to the already existing suffix.
%
% \watchout[TODO!] Or are prefix and suffix simply replaced?
% \ItemDescribeOption{/fca/label/name prefix} Default: |\pgfkeysvalueof{/fca/namespace}\space node\space|,
%   \textbf{value required}
% \ItemDescribeOption{/fca/label/name suffix} Default: |\space\fca@label@type\space\fca@label@position|,
% \textbf{value required}
% Prefix and suffix to be added to the node name for
%   the name of the label
%
% \watchout[TODO!] Or are prefix and suffix simply replaced?
% \ItemDescribeOption{/fca/label/fill}
%   \textbf{value required}, fill the label with the given colour,
% \ItemDescribeOption{/fca/label/text width},
%   \textbf{value required} Width of the text of the node. This option
%   enables multiline labels.
% \ItemDescribeOption{/fca/label/node font}
%   \textbf{value required}, Font macros to be applied to the label content
%   before the size of the node is calculated.
% \ItemDescribeOption{/fca/label/edge thickness}
%   \textbf{value required}, thickness of the edge of the label node
%   (typically the border size)
% \ItemDescribeOption{/fca/label/at}
% \textbf{value required} Information for anchoring labels on nodes
% \watchout[TODO!!!] look up what is really done
% \ItemDescribeOption{/fca/label/type}
% Defines the type of the given label. Every subobject of
% \optn{/fca/label/type} can be chose as label type. The predefined
% options are \optn{attributes} and \optn{objects}.
%
% New types can be defined by adding it to this path. In that case
% also a styles named \optn{/fca/label/\meta{type} \meta{position}}
% should be defined that do the actual formatting of the new label
% type. These types are immediately executed whenever a label type or
% a label position is changed (see below).
%
% \ItemDescribeOption{/fca/label/type/attributes/.style}
% Makes the label type \optn{attributes} available and defines styles
% for all attribute labels.
% \ItemDescribeOption{/fca/label/type/objects/.style}
% Makes the label type \optn{objects} available and defines styles
% for all object labels.
%
% \ItemDescribeOption{/fca/label/position}
% Defines the positon of the given label. Every subobject of
% \optn{/fca/label/positon} can be chose as position. The predefined
% options are \optn{left}, \optn{center} and \optn{right}.
%
% \ItemDescribeOption{/fca/label/position/left/.style}
% Makes the label position \optn{left} available and defines styles
% for all left labels.
% \ItemDescribeOption{/fca/label/position/center/.style}
% Makes the label position \optn{center} available and defines styles
% for all centered labels.
% \ItemDescribeOption{/fca/label/position/right/.style}
% Makes the label position \optn{right} available and defines styles
% for all right labels.
%
% \ItemDescribeOption{/fca/label/attributes left/.style}
% Describes how attribute labels on the left hand side of the concept
% should be formatted. By default this affects placement and text
% alignment.
% \ItemDescribeOption{/fca/label/attributes center.style}
% Describes how attribute labels that are horizontally centered to the concept
% should be formatted. By default this affects placement and text
% alignment.
% \ItemDescribeOption{/fca/label/attributes left/.style}
% Describes how attribute labels on the right hand side of the concept
% should be formatted. By default this affects placement and text
% alignment.
% \ItemDescribeOption{/fca/label/objects left/.style}
% Describes how object labels on the left hand side of the concept
% should be formatted. By default this affects placement and text
% alignment.
% \ItemDescribeOption{/fca/label/objects center.style}
% Describes how object labels that are horizontally centered to the concept
% should be formatted. By default this affects placement and text
% alignment.
% \ItemDescribeOption{/fca/label/objects left/.style}
% Describes how object labels on the right hand side of the concept
% should be formatted. By default this affects placement and text
% alignment.
% \end{description}
%
%    \begin{macrocode}

\newcommand\fca@append[2]{%
  \expandafter\def\expandafter#1\expandafter{#1#2}%
}
\newcommand\fca@concat[2]{%
  \expandafter\fca@append\expandafter#1\expandafter{#2}%
}


\fcaset{%
  connector/.is if=fca@connectors,
  namespace/.initial=fca,
  namespace/.value required,
  name prefix/.initial=\pgfkeysvalueof{/fca/namespace}\space node\space,
  name prefiv/.value required,
  name suffix/.initial={},
  name suffix/.value required,
  every node/.style = {},
  every concept/.style = {
    radius = 2,
    fill=white,
    draw=black
  },
  every attributes/.style = {
    font=\small\baselineskip1em\rmfamily\itshape
  },%\newcommand*{\fca@node@fill}{white}%%\newcommand*{\fca@node@fill}{white}%
  every objects/.style = {
    font=\small\baselineskip1em\rmfamily\upshape
  },
  every edge/.style = {},
  every label edge/.style = { dotted, draw=black },
  font=\small\baselineskip1em\rmfamily,
  shape/.initial=circle,
  minimum width/.forward to=/pgf/minimum width,
  minimum height/.forward to=/pgf/minimum height,
  minimum size/.forward to=/pgf/minimum size,
  inner xsep/.forward to=/pgf/inner xsep,
  inner ysep/.forward to=/pgf/inner ysep,
  inner sep/.forward to=/pgf/inner sep,
  outer xsep/.forward to=/pgf/outer xsep,
  outer ysep/.forward to=/pgf/outer ysep,
  outer sep/.forward to=/pgf/outer sep,
  radius/.code={
    \fca@parselength\@tempdima{#1}\unitlength
    \@tempdima=.70710678118654752440084436210484\@tempdima
    \edef\@tempa{\noexpand\pgfkeysalso{/pgf/inner sep=\the\@tempdima}}%
    \@tempa
  },
  % anchor/.store in=\fca@label@anchor,
  % anchor/.value required,
  node number/.style = { node font=\tiny, font=\tiny },
  color/.code={\fca@append\fca@options{#1}},
  stroke/.code={%
    \fca@testoption{#1}{%
      \fca@append\fca@options{%
        \pgfsetstrokecolor{#1}%
      }%
      \fca@append\fca@usepath{stroke,}%
    }{%
      \fca@append\fca@options{%
        \let\pgf@up@stroke\pgfutil@empty
      }%
    }{%
      \fca@append\fca@usepath{stroke,}%
    }%
  },
  draw/.forward to=/fca/stroke,
  fill/.code={%
    \fca@testoption{#1}{%
      \fca@append\fca@options{%
        \pgfsetfillcolor{#1}%
      }%
      \fca@append\fca@usepath{fill,}%
    }{%
      \fca@append\fca@options{%
        \let\pgf@up@fill\pgfutil@empty
      }%
    }{%
      \fca@append\fca@usepath{fill,}%
    }%
  },
  text/.initial=pgfstrokecolor,
  text/.value required,
  label type/.forward to=/fca/label/type,
  label position/.forward to=/fca/label/position,
  pgfnode/.initial={%
    \pgfkeysvalueof{/fca/name prefix}%
    \pgfkeysvalueof{/fca/node}%
    \pgfkeysvalueof{/fca/name suffix}%
  },
  pgfnode/.value required,
  node/.initial={},
  node/.value required,
  node contents/.initial={},
  node contents/.value required,
  shift/x/.store in=\fca@label@shift@x,
  shift/x/.value required,
  shift/y/.store in=\fca@label@shift@y,
  shift/y/.value required,
  shift/.value required,
  shift/.style args={(#1,#2)}{%
    /fca/shift/x=#1,
    /fca/shift/y=#2
  },%
  shift/x/signv2.1/.store in=\fca@label@shift@x@sign,
  shift/x/signv2.1/.value required,
  shift/y/signv2.1/.store in=\fca@label@shift@y@sign,
  shift/y/signv2.1/.value required,
  rotate/.code={%
    \fca@append\fca@transform{%
      \pgftransformrotate{#1}%
    }%
  },
  solid/.code={%
    \fca@append\fca@options{%
      \pgfsetdash{}{0pt}%
    }%
  },%
  dotted/.code={%
    \fca@append\fca@options{%
      \pgfsetdash{{\pgflinewidth}{2pt}}{0pt}%
    }%
  },%
  loosely dotted/.code={%
    \fca@append\fca@options{%
      \pgfsetdash{{\pgflinewidth}{4pt}}{0pt}%
    }%
  },%
  densely dotted/.code={%
    \fca@append\fca@options{%
      \pgfsetdash{{\pgflinewidth}{4pt}}{0pt}%
    }%
  }%
}
\fcaset{%
  every label/.style = {
    text=pgfstrokecolor,
    /pgf/outer sep=0pt,
    /pgf/inner sep=0pt,
  }
}

\pgfqkeys{/fca/node}{%
  thickness/.store in=\fca@node@thickness,
  thickness/.value required,
  radius/.style={
    /pgf/inner sep=#1
  },
  layer/.code=\fcalayer{node},%
  numbers/.is if=fca@CircledNumbers,
  number prefix/.store in=\fca@node@number@prefix,
  number prefix/.value required,
  number suffix/.store in=\fca@node@number@suffix,
  number suffix/.value required,
}

% Line thickness in standard \LaTeX{}:
% thin lines are .4pt
% thick lines are 0.8pt

% Dotted: \pgfsetdash{{\pgflinewidth}{2pt}}

\pgfqkeys{/fca/label}{%
  name prefix/.initial=\pgfkeysvalueof{/fca/namespace}\space node\space,
  name prefix/.value required,
  name suffix/.initial=\space\fca@label@type\space\fca@label@position,
  name suffix/.value required
  fill/.store in=\fca@node@fill,
  fill/.value required,
  text width/.store in=\fca@label@text@width,
  text width/.value required,
  node font/.store in=\fca@label@node@font,
  node font/.value required,
  edge thickness/.store in=\fca@label@edge@thickness,
  edge thickness/.value required,
  at/.store in=\fca@label@at,
  at/.value required,
  type/.store in=\fca@label@type,
  type/.is choice,
  type/.append code={%
    \def\fca@label@type{#1}% the choice does not store the value
    \pgfqkeysalso{/fca}{every #1/.try}%
    \pgfqkeysalso{/fca/label}{\fca@label@type\space\fca@label@position}%
  },
  type/attributes/.style={},
  type/objects/.style={},
  position/.store in=\fca@label@position,
  position/.is choice,
  position/.append code={%
    \def\fca@label@position{#1}% the choice does not store the value
    \pgfqkeysalso{/fca/label}{\fca@label@type\space\fca@label@position}%
  },
  position/left/.style={},
  position/right/.style={},
  position/center/.style={},
  %
  attributes left/.style={
    at=north west,
    /fca/anchor=south east,
    /fca/shift={(-0,0)},
    /fca/shift/x/signv2.1=-,
    /fca/shift/y/signv2.1={},
    /fca/font/.append=\raggedleft
  },
  attributes center/.style={
    at=north,
    /fca/anchor=south,
    /fca/shift={(0,0)},
    /fca/shift/x/signv2.1={},
    /fca/shift/y/signv2.1={},
    /fca/font/.append=\centering
  },
  attributes right/.style={
    at=north east,
    /fca/anchor=south west,
    /fca/shift={(0,0)},
    /fca/shift/x/signv2.1={},
    /fca/shift/y/signv2.1={},
    /fca/font/.append=\raggedright
  },
  objects left/.style={
    at=south west,
    /fca/anchor=north east,
    /fca/shift={(-0,-0)},
    /fca/shift/x/signv2.1=-,
    /fca/shift/y/signv2.1=-,
    /fca/font/.append=\raggedleft
  },
  objects center/.style={
    at=south,
    /fca/anchor=north,
    /fca/shift={(0,-0)},
    /fca/shift/x/signv2.1={},
    /fca/shift/y/signv2.1=-,
    /fca/font/.append=\centering
  },
  objects right/.style={
    at=south east,
    /fca/anchor=north west,
    /fca/shift={(0,-0)},
    /fca/shift/x/signv2.1={},
    /fca/shift/y/signv2.1=-,
    /fca/font/.append=\raggedright
  }
}

\newcommand*\fca@tikz@without@library{%
  \PackageWarning{fca}{FCA TikZ integration is not activated.^^J
    You should consider \tikzlibrary{fca} instead of
    \string\usepackage{fca}
  }%
}

\AtBeginDocument{%
  \@ifundefined{tikz@color}{}{\fca@tikz@without@library}
}


\newcommand*{\fcaNodeThickness}[1]{\pgfkeyssetvalue{/fca/node/thickness}{#1}}% %
\newcommand*{\fcaEdgeThickness}[1]{\def\fca@edge@thickness{#1}}% %
\newcommand*{\fcaNodeColor}[1]{\pgfkeyssetvalue{/fca/node/color}{#1}}% %
\newcommand*{\fcaNumbers}{%
  \setboolean{fca@CircledNumbers}{true}%
}%
\newcommand*{\fcaNoNumbers}{%
  \setboolean{fca@CircledNumbers}{false}%
}%
\newcommand*{\fcaCircleSize}[1]{\pgfqset{/pgf/node}{inner sep=(#1)*0.5\unitsize}}%
\iffca@compat@macros
  \def\fcaObjectLabelStyle{\fcaObjectLabelStyle}%
  \def\fcaAttributeLabelStyle{\AttributeLabelStyle}%
  \def\fcaLabelBoxWidth{\LabelBoxWidth}%
  \def\EdgeThickness{\fcaEdgeThickness}%
  \def\NodeThickness{\fcaNodeThickness}%
  \def\NodeColor{\fcaNodeColor}%
  \def\Numbers{\fcaNumbers}%
  \def\noNumbers{\fcaNoNumbers}
  \def\CircleSize{\fcaCircleSize}%
  \def\NoDots{\fcaNoDots}
  \def\Dots{\fcaDots}
\fi
\pgfqkeys{/fca/edge}{%
  thickness/.code=\fcaEdgeThickness
  layer/.code=\fcaLayer{edge}%
}%
%    \end{macrocode}
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    \begin{macrocode}
\newcounter{fca@minNode}%
\newcounter{fca@maxNode}%
\newcounter{fca@runNode}%
\newboolean{fca@CircledNumbers}%
\newcounter{fca@CircleDiameter}%
\newcounter{fca@AuxCounter}%
\newcounter{fca@BuxCounter}%
\def\fca@adjNode#1{%
  \ifthenelse{#1<\value{fca@minNode}}{\setcounter{fca@minNode}{#1}}{}%
  \ifthenelse{\value{fca@maxNode}<#1}{\setcounter{fca@maxNode}{#1}}{}}%
\newcommand\fca@node[1][]{%
  \@ifnextchar\bgroup{\fca@oldnode{#1}}{%
      \@ifnextchar({\fca@pictnode{#1}}{\fca@tikznode{#1}}%)
    }%
% \egroup
}
\newcommand\fca@typeset@node@content[1]{%
  \pgfkeysgetvalue{/fca/text width}\@tempa
  \edef\@tempb{\@tempa}%
  \expandafter\fca@testoption\expandafter{\@tempb}{%
    \def\fca@node@end@content{\end{minipage}}%
    \fca@parselength\@tempdima{\fca@tempa}\fca@xunitlength
    \begin{minipage}{\@tempdima}%
  }{%
    \let\fca@node@end@content\egroup
    \makebox\bgroup%
  }{%
    \let\fca@node@end@content\egroup
    \makebox\bgroup
  }%
  \pgfkeysvalueof{/fca/font}%
  \color{\pgfkeysvalueof{/fca/text}}%
  #1%
  \fca@node@end@content%
}
\newcommand\fca@oldnode[4]{%
  \begin{pgfscope}%
    \fcaset{shape=circle}%
    \fcaset{every node/.try}%
    \fcaset{every concept/.try}%
    \fcaset{#1}%
    \fca@nodeslayer
    \pgfkeysvalueof{/fca/node font}%
    \fca@parselength\@tempdima{#3}\unitlength
    \fca@parselength\@tempdimb{#4}\unitlength
    \pgftransformshift{\pgfpoint{\@tempdima}{\@tempdimb}}%
    \fca@options
    % \pgfsetstrokecolor{\fca@node@color}%
    \pgfnode{\pgfkeysvalueof{/fca/shape}}{center}{}{%
      \pgfkeysvalueof{/fca/name prefix}#2\pgfkeysvalueof{/fca/name suffix}%
    }{\expandafter\pgfusepath\expandafter{\fca@usepath}}%
    \fca@endnodeslayer
    \ifthenelse{\boolean{fca@CircledNumbers}}{%
      \fca@nodenumberslayer
      \def\fca@usepath{}%
      \fcaset{node number}%
      \fca@options
      \pgfnode{\pgfkeysvalueof{/fca/shape}}{center}{%
        \fca@typeset@node@content
        {%
          \centering
          \pgfkeysvalueof{/fca/font}%
          #2%
        }%
      }{%
        \pgfkeysvalueof{/fca/name prefix}#2\pgfkeysvalueof{/fca/name
          suffix} number%
      }{\expandafter\pgfusepath\expandafter{\fca@usepath}}%
      \fca@endnodenumberslayer
    }{}%
  \end{pgfscope}%
  \ignorespaces
}
\newcommand\fca@pictnode[1]{%
  \fca@parse@parenlabel{\fca@pictn@de{#1}}%
}
\newcommand\fca@pictn@de[2]{%
  \fca@parse@paren@vector{%
    \edef\fca@tempa{{\the\@tempdima}{\the\@tempdimb}}%
    \def\fca@tempb{\fca@oldnode{#1}{#2}}%
    \expandafter\fca@tempb\fca@tempa
  }\@tempdima\@tempdimb
}
\newcommand{\fca@edge}[1][]{%
  \@ifnextchar\bgroup{\fca@oldedge{#1}}{\fca@newedge{#1}}%
% \egroup
}
\newcommand\fca@newedge[1]{%
  \fca@parse@parenlabel{\fca@new@dge{#1}}%
}
\newcommand\fca@new@dge[2]{%
  \fca@parse@parenlabel{\fca@oldedge{#1}{#2}}%
}
\newcommand{\fca@oldedge}[3]{%
  \begin{pgfscope}%
    \fca@edgeslayer
    \fcaset{#1}%
    \fca@options
    \fca@transform
    \pgfsetlinewidth{\fca@edge@thickness}%
    \pgfpathmoveto{%
      \pgfpointshapeborder{%
        \pgfkeysvalueof{/fca/name prefix}#2\pgfkeysvalueof{/fca/name suffix}%%
      }{%
        \pgfpointanchor{%
          \pgfkeysvalueof{/fca/name prefix}#3\pgfkeysvalueof{/fca/name suffix}%%
        }{center}%
      }%
    }%
    \pgfpathlineto{%
      \pgfpointshapeborder{%
        \pgfkeysvalueof{/fca/name prefix}#3\pgfkeysvalueof{/fca/name suffix}%%
      }{%
        \pgfpointanchor{%
        \pgfkeysvalueof{/fca/name prefix}#2\pgfkeysvalueof{/fca/name suffix}%%
        }{center}%
      }%
    }%
    \pgfusepath{stroke}%
    \fca@endedgeslayer
  \end{pgfscope}%
  \ignorespaces
}
%
\def\fca@changeaValue#1#2#3{\setcounter{fca@AuxCounter}{#1}%
  \addtocounter{fca@AuxCounter}{#2}\def#3{\value{fca@AuxCounter}}}%
\def\fca@changebValue#1#2#3{\setcounter{fca@BuxCounter}{#1}%
  \addtocounter{fca@BuxCounter}{#2}\def#3{\value{fca@BuxCounter}}}%
\newcommand{\fcaNoDots}{\setboolean{fca@connectors}{false}}
\newcommand{\fcaDots}{\setboolean{fca@connectors}{true}}
%    \end{macrocode}
%    \begin{macrocode}
\def\fca@parse@parenlabel#1(#2){#1{#2}}
\def\fca@parse@paren@vector#1#2#3(#4,#5){%
  \fca@parse@brace@vector{#1}{#2}{#3}{#4}{#5}%
}
%    \end{macrocode}
% \begin{macro}{\fca@parse@label}\marg{true material}\marg{else
%   material}\parg{label}
% \begin{macro}{\fca@parse@label}\marg{true material}\marg{else
%   material}\marg{label}
% \begin{macro}{\fca@parse@label}\marg{true material}\marg{else
%   material}
% The argument \meta{label} is parsed if it is given. In that case it
% is fed to \meta{true path} as ordinary argument. If it is not
% given, the code in \meta{else material} is executed.
%    \begin{macrocode}
\newcommand*\fca@parse@label[2]{%
  \@ifnextchar\bgroup{%\egroup
    #1%
  }{%
    \@ifnextchar(%)
    {%
      \fca@parse@parenlabel{#1}%
    }{%
      #2%
    }%
  }%
}
\newcommand*\fca@parse@vector[4]{%
  \@ifnextchar(%)
  {%
    \fca@parse@paren@vector{#1}{#3}{#4}%
  }{%
    \@ifnextchar\bgroup{%\egroup
      \fca@parse@brace@vector{#1}{#3}{#4}%
    }{#2}%
  }%
}
\newcommand*\fca@parse@brace@vector[5]{%
  \fca@parselength#2{#4}\fca@xunitlength
  \fca@parselength#3{#5}\fca@yunitlength
  #1%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@labelBox}\oarg{options}
% \begin{macro}{\fca@labelBox}\oarg{options}\marg{label}
% \begin{macro}{\fca@labelBox}\oarg{options}\marg{label}\marg{content}
% \begin{macro}{\fca@labelBox}\oarg{options}\marg{label}\marg{xoffset}\marg{yoffset}\marg{content}
% \begin{macro}{\fca@labelBox}\oarg{options}\marg{label}\parg{xoffset,yoffset}\marg{content}
% \begin{macro}{\fca@labelBox}\oarg{options}\parg{label}\marg{content}
% \begin{macro}{\fca@labelBox}\oarg{options}\parg{label}\parg{xoffset,yoffset}\marg{content}
% \begin{dtxexample}{Syntax test for labels}
%   {\unitlength 1.2mm\relax
%   \begin{diagram}{40}{55}
%     \Numbers
%     \Node{1}{20}{10}
%     \Node{2}{35}{20}
%     \Node{3}{5}{30}
%     \Node{4}{35}{40}
%     \Node{5}{20}{50}
%     \Edge{1}{2}
%     \Edge{1}{3}
%     \Edge{2}{4}
%     \Edge{3}{5}
%     \Edge{4}{5}
%     \fcaNoDots
%     \leftAttbox(1)(-5,4){also not connected}
%     \fcaDots
%     \rightAttbox[node=2,node contents={first}]
%     \rightAttbox[node contents=second]{4}
%     \leftObjbox{3}{third}
%     \rightObjbox{2}{2}{2}{fourth}
%     \rightObjbox{4}(2,2){fifth}
%     \leftAttbox(5){sixth}
%     \rightAttbox(5)(3,3){sevenths}
%     \rightAttbox[connector=false](1)(10,2){not connected}
%   \end{diagram}
% }
% \end{dtxexample}
%    \begin{macrocode}
\newcommand*\fca@labelBox[1][]{%
  \fca@parse@label{\fca@l@belBox{#1}}{\fca@@labelBox{#1}}%
}
\newcommand*\fca@l@belBox[2]{%
  \@ifnextchar\bgroup{%
    \fca@lab@lBox{#1}{#2}%
  }{%
    \@ifnextchar({%)
      \fca@parse@vector{%
        \def\fca@tempa{outer sep=1pt,#1,node=#2,shift=}%
        \edef\fca@tempb{{(\the\@tempdima,\the\@tempdimb)}}%
        \fca@concat\fca@tempa\fca@tempb%
        \@ifnextchar\bgroup{%
          \expandafter\fca@l@b@lBox\expandafter{\fca@tempa}%
        }{%
          \expandafter\fca@@labelBox\expandafter{\fca@tempa}%
        }%
      }{}{\@tempdima}{\@tempdimb}%
    }{%
      \fca@@labelBox{#1,node={#2}}%
    }%
  }%
}
\newcommand*\fca@lab@lBox[3]{%
  \@ifnextchar\bgroup{%
    \fca@parse@vector{%
      \@ifnextchar\bgroup{%
        \fca@oldlabelBox{#1,node=#2}{\the\@tempdima}{\the\@tempdimb}%
      }{%
        \fca@oldlabelBox{#1,node=#2}{\the\@tempdima}{\the\@tempdimb}{}%
      }%
    }{}{\@tempdima}{\@tempdimb}{#3}%
  }{%
    \fca@@labelBox{#1,node={#2},node contents={#3}}%
  }%
}
\newcommand*\fca@l@b@lBox[2]{%
  \fca@@labelBox{#1,node contents=#2}
}
\newcommand*\fca@label@shift@sign@{}%
\expandafter\newcommand\expandafter*\csname fca@label@shift@sign@+\endcsname[1]{+(#1)}
\expandafter\newcommand\expandafter*\csname fca@label@shift@sign@-\endcsname[1]{-(#1)}
\newcommand*\fca@addshiftsign[1]{%
  \expandafter\fca@@ddshiftsign\expandafter{\csname
  fca@label@shift@#1@sign\endcsname}
}
\newcommand*\fca@@ddshiftsign[1]{%
  \csname fca@label@shift@sign@#1\endcsname
}

\newcommand\fca@oldlabelBox[4]{%
  \def\fca@tempa{%
    #1,
    label/at=center,
    shift=
  }%
  \edef\fca@tempb{%
    {({\noexpand\fca@addshiftsign x{#2}},{\noexpand\fca@addshiftsign y{#3}})}%
  }%
  \expandafter\expandafter\expandafter\fca@@labelBox
  \expandafter\expandafter\expandafter{%
    \expandafter\fca@tempa
    \fca@tempb,
    node contents={#4}%
  }%
}
%    \end{macrocode}
%
% \begin{macro}{\fca@remove@anchor}\marg{point}
%   This macro removes the anchor part of a node name.
%    \begin{macrocode}
\newcommand\fca@remove@anchor[1]{%
  \fca@remove@anch@r#1.\fca@remove@anchor%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fca@remove@anch@r}
%
\def\fca@remove@anch@r#1.#2\fca@remove@anchor{#1}
%
% \end{macro}
%
% \begin{macro}{\fca@prepare@node}\marg{point}\marg{direction}\marg{prefix}\marg{suffix}\marg{node}
%
% This macro is used to find the correct anchor point and the point a
% vector from another node will likely point to. This follows the
% following logic: If \marg{node} is not passed in braces and contains
% a dot (|.|), then \marg{point} will contain a macro that crates a
% point pointing to some other |\pgfpoint| on the border of
% \marg{prefix}\marg{node}\marg{suffix}. And \marg{direction} will be
% the \marg{default anchor} of that node. Otherwise we assume that an
% anchor is given and we should draw lines directly from that
% anchor. So both macros \marg{point} and \marg{direction} will be
% defined to return the same point
% |\pgfpointanchor{|\marg{prefix}\marg{node
% name}\marg{suffix}|}{|\marg{node anchor}|}|.
%    \begin{macrocode}
\newcommand\fca@prepare@node[5]{%
  \def\@tempa{\fca@split@node@{#1}{#2}{#3}{#4}}%
  \edef\@tempb{#5.center.}%
  \fca@concat\@tempa{\@tempb\fca@split@node@}%
  \@tempa
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@split@node@}\marg{point}\marg{direction}\marg{prefix}\marg{suffix}\marg{node}|.|\marg{default
%   anchor}|.\fca@split@node@|
%
% This macro is called by \cs{fca@prepare@node}. It should not be
% called directly.
%
% This macro is used to find the correct anchor point and the point a
% vector from another node will likely point to. This follows the
% following logic: If \marg{node} is not passed in braces and contains
% a dot (|.|), then \marg{point} will contain a macro that crates a
% point pointing to some other |\pgfpoint| on the border of
% \marg{prefix}\marg{node}\marg{suffix}. And \marg{direction} will be
% the \marg{default anchor} of that node. Otherwise we assume that an
% anchor is given and we should draw lines directly from that
% anchor. So both macros \marg{point} and \marg{direction} will be
% defined to return the same point
% |\pgfpointanchor{|\marg{prefix}\marg{node
% name}\marg{suffix}|}{|\marg{node anchor}|}|.
%
%    \begin{macrocode}
\def\fca@split@node@#1#2#3#4#5.#6.#7\fca@split@node@{%
  \def\@tempa{#7}%
  \ifx\@tempa\empty\relax
    \def#1##1{\pgfpointshapeborder{#3#5#4}{##1}}%
  \else
    \def#1##1{\pgfpointanchor{#3#5#4}{#6}}%
  \fi
  \def#2{%
    \pgfpointanchor{#3#5#4}{#6}%
  }%
}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\def\fca@def@expanded@node#1#2#3#4{%
  \edef\@tempa{\noexpand\def\noexpand#1\noexpand\fca@node@full@node{#2}{#3}#4..\fca@node@fullnode}%
  \@tempa
}
%    \end{macrocode}
% \begin{macro}{\fca@node@anchor}\marg{node}|.|\marg{anchor}|\fca@node@anchor|
%   Create a pgfpoint from a string of the form |node.anchor| as in
%   \TikZ. The anchor must be given, no default can be defined.
%    \begin{macrocode}
\def\fca@node@anchor#1.#2\fca@node@anchor{%
  \pgfpointanchor{#1}{#2}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@node@border}\marg{node1}|,|\marg{node2}|.|\marg{anchor2}|.|\marg{garbage}|\fca@node@border|
% This macro finds the |\pgfpoint| on the border of \marg{node1} that
% goes towards \marg{node2}|.|\marg{anchor2}. The argument
% \marg{garbage} is thrown away. This allows to select a default
% anchor in case no anchor is given for the \marg{node2}.
%    \begin{macrocode}
\def\fca@node@border#1,#2.#3.#4\fca@node@border{%
  \pgfpointshapeborder{#1}{\pgfpointanchor{#2}{#3}}%
}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\newcommand\fca@calculate@edgepoint[3]{%
  \edef\@tempa{\noexpand\pfgutil@in@{.}{#2}}%
  \@tempa
  \ifpfgutil@in@
    \def#1{%
      \fca@node@anchor#2\fca@node@anchor
    }%
  \else
    \def#1{%
      \fca@node@border#2,#3.center.\fca@node@border
    }%
  \fi
}
%    \end{macrocode}
%
% \fcaset{conexpstyle/.style={%
%    every attributes/.append style={
%      label concept/.append style={
%        shape=semicircle,
%        fill=blue,
%        draw=black,
%        anchor=south,
%        outer sep=0pt,
%        minimum height=2\unitlength,
%        label/name suffix=attribute concept,
%        label/at=center,
%        solid
%      }
%    },
%    every objects/.append style={
%      label concept/.append style={
%      shape=semicircle,
%      outer sep=0pt,
%        fill=black,
%        draw=black,
%        anchor=south,
%        minimum height=2\unitlength,
%        label/name suffix=attribute concept,
%        label/at=center,
%        solid,
%        rotate=180
%      }
%    }}}
%
%\fbox{\unitlength 1.2mm
%  \definecolor{darkgreen}{rgb}{0.05,0.5,0.}
% \begin{diagram}
%  \Node[draw=red, fill=green](1)(20,10)
%  \Node[fill=black]{2}{35}{20}
%  \Node{3}{5}{30}
%  \Node[fill=darkgreen]{4}{35}{40}
%  \Node{5}{20}{50}
%  {\color{red}\Edge{1}{2}}
%  \Edge[draw=blue,dotted]{1}{3}
%  {\thicklines\Edge{2}{4}}
%  \Edge[draw=darkgreen](3)(5)
%  \Edge{4}{5}
%  \leftAttbox{3}{2}{2}{1}
%   \rightAttbox{2}{2}{2}{disqualified}
%  \rightAttbox{4}{2}{2}{2.}
%  \leftObjbox{3}{2}{2}{Verstappen}
%  \rightObjbox{2}{2}{2}{Leclerc}
%  \rightObjbox{4}{2}{2}{Hamilton}
%\end{diagram}
%
%\begin{diagram}[conexpstyle]
%  \Node(1)(20,10)
%  \Node(2)(35,20)
%  \Node(3)(5,30)
%  \Node(4)(35,40)
%  \Node(5)(20,50)
%  \Edge(1)(2)
%  \Edge(1)(3)
%  \Edge(2)(4)
%  \Edge(3)(5)
%  \Edge(4)(5)
%  \leftAttbox{3}{2}{2}{1}
%   \rightAttbox{2}{2}{2}{disqualified}
%  \rightAttbox{4}{2}{2}{2.}
%  \leftObjbox{3}{2}{2}{Verstappen}
%  \rightObjbox{2}{2}{2}{Leclerc}
%  \rightObjbox{4}{2}{2}{Hamilton}
%\end{diagram}
%}
%
% Using the style only for special nodes
%\fbox{\unitlength 1.2mm
%\begin{diagram}
%  \Node(1)(20,10)
%  \Node(2)(35,20)
%  \Node(3)(5,30)
%  \Node(4)(35,40)
%  \Node(5)(20,50)
%  \Edge(1)(2)
%  \Edge(1)(3)
%  \Edge(2)(4)
%  \Edge(3)(5)
%  \Edge(4)(5)
%  \leftAttbox[conexpstyle]{3}{2}{2}{1}
%  \rightAttbox[conexpstyle]{2}{2}{2}{disqualified}
%  \rightAttbox{4}{2}{2}{2.}
%  \leftObjbox[conexpstyle]{3}{2}{2}{Verstappen}
%  \rightObjbox{2}{2}{2}{Leclerc}
%  \rightObjbox[conexpstyle]{4}{2}{2}{Hamilton}
%\end{diagram}
%}
%
% \begin{diagram}[conexpstyle]
%   \Node(1)(20,10)
%   \Node(2)(35,20)
%   \Node(3)(5,30)
%   \Node(4)(35,40)
%   \Node(5)(20,50)
%   \Edge(1)(2)
%   \Edge(1)(3)
%   \Edge(2)(4)
%   \Edge(3)(5)
%   \Edge(4)(5)
%   \leftAttbox(3)(-20,20){1}
%   \rightAttbox(2)(20,20){disqualified}
%   \rightAttbox(4)(20,20){2.}
%   \leftObjbox(3)(-20,-2){Verstappen}
%   \rightObjbox(2)(2,-2){Leclerc}
%   \rightObjbox(4)(20,-2){Hamilton}
% \end{diagram}
%
%    \begin{macrocode}
\newcommand\fca@@labelBox[1]{%
  \begin{pgfscope}%
    \fcaset{every node/.try,every label/.try,#1}%
    \fca@labelslayer
    \pgfkeysvalueof{/fca/node font}%
    \fca@options
    \edef\@tempa{\pgfkeysvalueof{/fca/pgfnode}}%
    \xdef\fca@temp@node@name{%
      \expandafter\fca@remove@anchor\expandafter{\@tempa}%
    }%
    \pgftransformshift{%
      \pgfpointanchor{%
        \fca@temp@node@name
      }{\fca@label@at}%
    }%
    \fca@parselength\@tempdima{\fca@label@shift@x}\unitlength
    \fca@parselength\@tempdimb{\fca@label@shift@y}\unitlength
    \pgftransformshift{\pgfpoint{\@tempdima}{\@tempdimb}}%
    \fca@transform
    \pgfnode{rectangle}{\pgfkeysvalueof{/fca/anchor}}{%
      \fca@typeset@node@content
      {%
        \pgfkeysvalueof{/fca/node contents}%
      }%
    }{%
      \pgfkeysvalueof{/fca/label/name prefix}%
      \pgfkeysvalueof{/fca/node}%
      \pgfkeysvalueof{/fca/label/name suffix}%
    }{%
      \expandafter\pgfusepath\expandafter{\fca@usepath}%
    }%
    \fca@endlabelslayer
    % pin edge
    \iffca@connectors
      \fca@connectorslayer
      \pgftransformreset
      \let\fca@options\fca@defaultoptions
      \fcaset{every label edge/.try}%
      \fcaset{#1}%
      \fca@options
      \fca@transform
      \pgfsetlinewidth{\fca@edge@thickness}%
      \fca@prepare@node\fca@temp@start@point\fca@temp@start@point@{}{}{\pgfkeysvalueof{/fca/pgfnode}}%
      \fca@prepare@node\fca@temp@end@point\fca@temp@end@point@
      {\pgfkeysvalueof{/fca/label/name prefix}}%
      {\pgfkeysvalueof{/fca/label/name suffix}}%
      {\pgfkeysvalueof{/fca/node}.\pgfkeysvalueof{/fca/anchor}}%
      \pgfpathmoveto{\fca@temp@start@point\fca@temp@end@point@}%
      \pgfpathlineto{\fca@temp@end@point\fca@temp@start@point@}%
      \pgfusepath{stroke}%
      \fca@endconnectorslayer
    \fi
    % overlay concept
    \pgftransformreset
    \let\fca@options\fca@defaultoptions
    \pgfsetdash{}{0pt}%
    \fcaset{shape=coordinate,#1}%
    \fcaset{every label concept/.try}%
    \fcaset{label concept/.try}%
    \ifx\pgfkeysvalueof{/fca/shape}\pgfkeysnovalue
    \else
      \fca@labelconceptslayer
      \pgftransformshift{%
        \pgfpointanchor{%
          \fca@temp@node@name
        }{\fca@label@at}%
      }%
      \fca@transform
      \fca@options
      % \pgfsetstrokecolor{\fca@node@color}%
      \pgfnode{\pgfkeysvalueof{/fca/shape}}{\pgfkeysvalueof{/fca/anchor}}{}{%
        \pgfkeysvalueof{/fca/label/name prefix}%
        \pgfkeysvalueof{/fca/node}%
        \pgfkeysvalueof{/fca/label/name suffix}%
      }{\expandafter\pgfusepath\expandafter{\fca@usepath}}%
      \fca@endlabelconceptslayer
    \fi
  \end{pgfscope}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \changes{2.2}{2022/09/12}{Rename \cs{ColorNode} into \cs{fcaColorNode}}
%    \begin{macrocode}
\newcommand\fca@leftAttbox[1][]{%
  \fca@labelBox[label type=attributes,label position=left,#1]
}
\newcommand\fca@centerAttbox[1][]{%
  \fca@labelBox[label type=attributes,label position=center,#1]
}
\newcommand\fca@rightAttbox[1][]{%
  \fca@labelBox[label type=attributes,label position=right,#1]
}
\newcommand\fca@leftObjbox[1][]{%
  \fca@labelBox[label type=objects,label position=left,#1]
}
\newcommand\fca@centerObjbox[1][]{%
  \fca@labelBox[label type=objects,label position=center,#1]
}
\newcommand\fca@rightObjbox[1][]{%
  \fca@labelBox[label type=objects,label position=right,#1]
}
%
\def\fca@ResetDefaults{\setcounter{fca@minNode}{60}%
  \setcounter{fca@maxNode}{0}%
  \setcounter{fca@CircleDiameter}{4}%
  \setboolean{fca@CircledNumbers}{false}%
  \fca@Defaults}%
%
\def\fcaColorNode#1{{%
    \PackageWarning{fca}{The \string\ColorNode\space macro is
      deprecated.^^J
      Use `\string\Node[fill=#1]` instead}
    \linethickness{\fca@node@thickness}%
    \color{#1}{\circle*{\value{fca@CircleDiameter}}}%
    \color{black}{\circle{\value{fca@CircleDiameter}}}}}%
%
\def\fca@circle{{%
    \linethickness{\fca@node@thickness}%
    \color{\fca@node@fill}{\circle*{\value{fca@CircleDiameter}}}%
    \color{black}{\circle{\value{fca@CircleDiameter}}}}}%
%
\def\fca@DrawCircles{\setcounter{fca@runNode}{\value{fca@minNode}}%
  \stepcounter{fca@maxNode}%
  \whiledo{\value{fca@runNode}<\value{fca@maxNode}}%
  {\fca@getNode{\value{fca@runNode}}%
    \put(\fca@x,\fca@y){\fca@circle}%
    \ifthenelse{\boolean{fca@CircledNumbers}}%
    {\put(\fca@x,\fca@y){\makebox(0,0){\tiny\arabic{fca@runNode}}}}{}%
    \stepcounter{fca@runNode}}}%
%

\newcommand*\fca@setb@undingbox{%
}%
\newcommand*\fca@ignoreboundingbox{}%

% set bounding box using brace notation
\newcommand*\fca@olddiagram[2]{%
  \fca@parselength\@tempdima{#1}\unitlength
  \edef\fca@right@border{\the\@tempdima}%
  \fca@parselength\@tempdimb{#2}\unitlength
  \edef\fca@top@border{\the\@tempdimb}%
  \let\fca@boundingbox\fca@setboundingbox
  \fca@parselength\@tempdima{-(\fcaDiagramXoffset)}\unitlength%
  \edef\fca@left@border{\the\@tempdima}%
  \fca@parselength\@tempdima{-(\fcaDiagramYoffset)}\unitlength%
  \edef\fca@bottom@border{\the\@tempdima}%
  \fca@startdiagram
  \fca@setboundingbox{\fca@left@border}{\fca@bottom@border}
  {\fca@right@border}{\fca@top@border}%
}
\newcommand*\fca@diagram{%
  \@ifnextchar(\fca@diagr@m\fca@di@gram
% )
}
% set bounding box using parentheses
\newcommand*\fca@diagr@m{%(#1,#2)
  \PackageError{fca}{not implemented}{not implemented}%
}
% set bounding box using defaults
\newcommand*\fca@di@gram{%
  \fca@startdiagram
}
\newcommand*\fca@startdiagram{%
  \fca@begindiagram
  \fca@Defaults
}
\newcommand*\fca@setboundingbox[4]{%
  \pgfpathrectangle{\pgfpoint{#1}{#2}}{\pgfpoint{#3}{#4}}%
  \pgfusepath{use as bounding box}%
}
% \todo{Lattice diagrams inside pgf pictures should be drawn inside
% their own scope}
\newenvironment{diagram}[1][]
{%
  \ifpgfpicture
    \def\fca@begindiagram{%
      \begin{pgfscope}%
        \fcaset{#1}%
        \unitlength=\dimexpr\pgf@xx+\pgf@yx\relax
        \def\fca@enddiagram{%
          \end{pgfscope}%
        }%
    }%
  \else
    \def\fca@begindiagram{%
      \begin{pgfpicture}%
        \fcaset{#1}%
        \def\fca@enddiagram{\end{pgfpicture}}%
    }%
  \fi
  \noindent
  \@ifnextchar\bgroup\fca@olddiagram\fca@diagram% This line must be
                                % executed before \begin{pgfpicture}
}%
{%
  %\fca@DrawCircles
  \fca@enddiagram%
}%
%    \end{macrocode}
% \changes{2.2}{2022/05/06}{Rename \cs{EdgeThickness} to
% \cs{fcaEdgeThickness} and \cs{NodeThickness} to \cs{fcaNodeThickness}}
%
% \iffalse
%</fca.sty>
%<*tikz>
% \fi
%
% \begin{environment}{tikzdiagram}
%   This environment places a diagram in a \TikZ{} picture.
%    \begin{macrocode}
\newenvironment{tikzdiagram}[1][]{%
  \def\fca@begindiagram{%
    \begin{tikzpicture}%
      \fcaset{#1}%
      \unitlength=\dimexpr\pgf@xx+\pgf@yx\relax
    }%
    \noindent
    \@ifnextchar\bgroup\fca@olddiagram\fca@diagram% This line must be
    % executed before \begin{pgfpicture}
  }{%
  \end{tikzpicture}%
}
%    \end{macrocode}
% \end{environment}
% \iffalse
%</tikz>
%<*fca.sty>
% \fi
% End of diagram environment definition.                                      %
%
%
%
% \subsection{Some simple macros for FCA texts}
%
%
%    \begin{macrocode}
\providecommand{\GMI}{(G,M,\relI)}
\newcommand{\context}[1][K]{\ensuremath{\mathbb{#1}}}
\providecommand{\'}{\ensuremath{\sp\prime}}% derivation operator
\providecommand{\extent}[1]{\textrm{ext}(#1)}
\providecommand{\intent}[1]{\textrm{int}(#1)}
\providecommand{\extents}[1]{\textrm{Ext}(#1)}
\providecommand{\intents}[1]{\textrm{Int}(#1)}
\providecommand{\BV}{\underline{{\mathfrak B}}}
\providecommand{\CL}{\BV}
\providecommand{\BGMI}{{\mathfrak B} (G,M,\relI)}
\providecommand{\CGMI}{\BGMI}
\providecommand{\BVGMI}{\BV (G,M,\relI)}
\providecommand{\CLGMI}{\BVGMI}
\providecommand{\HNI}{(H,N,\relI \cap\; H{\times}N)}
\providecommand{\relI}{\mathrel{I}}
\providecommand{\notI}{\mathrel{\mbox{\rlap{\char'40}%
      {\it I}\hspace*{-0.09em}\raisebox{.27ex}{\char'40}}}}%
%
\providecommand{\bigtimes}{\mathop{%
    \mathchoice{\raisebox{-2pt}{\huge$\times$}}{\mbox{\LARGE$\times$}}%
    {\raisebox{0pt}{\Large$\times$}}{\times}}\displaylimits}%
%
\providecommand{\Runterpfeil}{\mathrel{\swarrow}}
\providecommand{\DownArrow}{\Runterpfeil}
\providecommand{\Hochpfeil}{\mathrel{\nearrow}}
\providecommand{\UpArrow}{\Hochpfeil}
\providecommand{\IRunterpfeil}{\mathrel{\searrow}}
\providecommand{\IDownArrow}{\IRunterpfeil}
\providecommand{\IHochpfeil}{\mathrel{\nwarrow}}
\providecommand{\IUpArrow}{\IHochpfeil}
\providecommand{\Doppelpfeil}{\mathrel{\!\!\rlap{$\;\nearrow$}\swarrow}}
\providecommand{\DoubleArrow}{\Doppelpfeil}
%
\newcommand{\DDPfeil}{\mathrel{\mathchoice%
    {\mbox{$\displaystyle\swarrow\hspace{-.7em}\swarrow$}}
    {\mbox{$\textstyle\swarrow\hspace{-.7em}\swarrow$}}
    {\mbox{$\scriptstyle\swarrow\hspace{-.5em}\swarrow$}}
    {\mbox{$\scriptscriptstyle\swarrow\hspace{-.35em}\swarrow$}}}}
%
\newcommand{\NDDPfeil}{\mathrel{\mathchoice%
    {\mbox{$\displaystyle\swarrow\hspace{-.7em}\swarrow%
        \hspace{-1.2em}\backslash\hspace{.4em}$}}
    {\mbox{$\textstyle\swarrow\hspace{-.7em}\swarrow
        \hspace{-1.1em}\backslash\hspace{.4em}$}}
    {\mbox{$\scriptstyle\swarrow\hspace{-.5em}\swarrow
        \hspace{-.6em}\backslash\hspace{.2em}$}}
    {\mbox{$\scriptscriptstyle\swarrow\hspace{-.35em}\swarrow
        \hspace{-.5em}\backslash\hspace{.1em}$}}}}
%
\providecommand{\DPfeil}{\DDPfeil}
\providecommand{\NDPfeil}{\NDDPfeil}
\newcommand{\DDArrow}{\DDPfeil}
\newcommand{\NDDArrow}{\NDDPfeil}
\providecommand{\Semi}{\mathrel{\mbox{\tiny\rlap{\raisebox{2.0ex}%
        {$\bigtriangledown$}}\raisebox{-0.0ex}{$\bigtriangleup$}}}}
\def\ovee{\mbox{\small$\mathrel{\hspace{.35em}\raisebox{-1pt}%
      {$\smash{\vee}$}\hspace*{-.835em}\bigcirc\hspace{.2em}}$}}
\def\owedge{\mbox{\small$\mathrel{\hspace{.35em}\smash{\wedge}%
      \hspace*{-.835em}\bigcirc\hspace{.2em}}$}}
%
\providecommand{\ptimes}[1]{\mathrel{\stackrel{#1}{\times}}}
%
\providecommand{\FCA}{Formal Concept Analysis\xspace}
\providecommand{\FBA}{Formale Begriffsanalyse\xspace}
\providecommand{\FnBA}{Formalen Begriffsanalyse\xspace}
%    \end{macrocode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% End of fca.sty style file definitions                                       %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \iffalse
%    \begin{macrocode}
%</fca.sty>
%    \end{macrocode}
% \fi
% \section{The PGF Coordinate system}
% \begin{pgfpicture}%
%   \pgfmoveto{\pgfpoint{0}{0}}%
%   \pgflineto{\pgfpoint{1cm}{0}}%
%   \pgfmoveto{\pgfpoint{0}{0}}%
%   \pgflineto{\pgfpoint{0}{1cm}}%
% {%
%   \pgftransformshift{\pgfpoint{1cm}{0}}%
%   \pgfnode{rectangle}{west}{(1,0)}{x}{\pgfusepath{stroke}}%
% }{%
%   \pgftransformshift{\pgfpoint{0}{1cm}}%
%   \pgfnode{rectangle}{south}{(0,1)}{y}{\pgfusepath{stroke}}%
% }%
% \end{pgfpicture}
% \iffalse
%    \begin{macrocode}
%<*formula1.cxt>
%    \end{macrocode}
% \fi
% \section{Formal contexts for demonstrating \cs{cxtinput}}
% The following formal context file is saved as \filenm{formula1.dtx}
% in the documentation folder.
%    \begin{macrocode}
B
Formula 1
3
3

Verstappen
Hamilton
Leclerc
1.
2.
disqualified
X..
.X.
.XX
%    \end{macrocode}
% \iffalse
%    \begin{macrocode}
%</formula1.cxt>
%<*formula0.cxt>
%    \end{macrocode}
% \fi
%    \begin{macrocode}
B

3
3

Verstappen
Hamilton
Leclerc
1.
2.
disqualified
X..
.X.
.XX
%    \end{macrocode}
% \iffalse
%    \begin{macrocode}
%</formula0.cxt>
%    \end{macrocode}
% \fi
% \Finale
% \PrintChanges
%
% \endinput
% Local Variables:
% mode: doctex
% TeX-master: t
% End:
