% \iffalse meta-comment
% vim: textwidth=75
%<*internal>
\iffalse
%</internal>
%<*readme>
        |
-------:| -----------------------------------------------------------------
    fca:| Typesetting Formal Concept Analysis with LaTeX
 Author:| Bernhard Ganter
        | Tobias Schlemmer <keinstein@users.sf.net>
 E-mail:| keinstein@users.sf.net
License:| Released under the LaTeX Project Public License v1
    See:| http://www.latex-project.org/lppl.txt


Short description:

Formal Concept Analysis (FCA) is a field of mathematics based on the
theory of ordered sets and complete lattices, with applications to
data analysis and knowledge processing. To simplify typesetting of
FCA-related text, \fcastyle  provides two environments and some simple
macros. The two environments are

  - cxt     : for typesetting small formal contexts as cross-tables, and
  - diagram : for making line diagrams of concept lattices.
              This environment may be of some interest for other
              surposes as well, since it can also be used for
              arbitrary ordered sets and graphs.

A list of macros is given in an extra section.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip

\iffalse

 This program is provided under the terms of the                             %
 LaTeX Project Public License distributed from CTAN                          %
 archives in directory macros/latex/base/lppl.txt.                           %
\ else

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

\fi

\preamble
 latex-fca.dtx
 Copyright ℂ 2022 Ernst-Schröder-Zentrum
                  für Begriffliche Wissensverarbeitung
 Authors: Bernhard Ganter
          Tobias Schlemmer

 This program is provided under the terms of the
 LaTeX Project Public License distributed from CTAN
 archives in directory macros/latex/base/lppl.txt.

 This work is "maintained" (as per LPPL maintenance status) by
 Tobias Schlemmer <keinstein@users.sf.net>.

 This work consists of the files
   latex-fca.dtx and
   latex-fca.ins

 and the derived files
   fca.sty,
   formula0.cxt,
   formula1.cxt.

\endpreamble

\askforoverwritefalse

\usedir{tex/latex/fca}
\generate{%
        \file{fca.sty}{%
                \usepreamble\defaultpreamble
                \usepostamble\defaultpostamble
                \from{latex-fca.dtx}{fca.sty,cxtinput.sty,package}}
            }
\usedir{tex/generic/fca}
\generate{%
        \file{tikzlibraryfca.code.tex}{%
                \usepreamble\defaultpreamble
                \usepostamble\defaultpostamble
                \from{latex-fca.dtx}{tikz,package}}
            }
\usedir{doc/latex/fca}
\generate{%
  \file{formula0.cxt}{
    \nopreamble\nopostamble
    \from{latex-fca.dtx}{formula0.cxt}}
  \file{formula1.cxt}{
    \nopreamble\nopostamble
    \from{latex-fca.dtx}{formula1.cxt}}
  \file{notikzfcadoc.tex}{%
    \usepreamble\defaultpreamble
    \usepostamble\defaultpostamble
    \from{latex-fca.dtx}{notikzdriver}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/fca}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/fca}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
% \fi
% \iffalse
%<*package>
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%</package>
% \fi
% \iffalse
% Doc-Source file to use with LaTeX2e
% Copyright (C) 2022 Tobias Schlemmer, all rights reserved.
% \fi
% \iffalse
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<*driver>
\ProvidesFile{latex-fca.dtx}
%</driver>
%<notikzdriver>\ProvidesFile{notikzfcadoc.tex}
%<fca.sty>\ProvidesPackage{fca}
%<tikz>\ProvidesFile{tikzlibraryfca.code.tex}
%<*package|driver|notikzdriver>
    [2022/09/17 v3.0
%</package|driver|notikzdriver>
%<*fca.sty|driver|notikzdriver>
Formal Concept Analysis macros]
%</fca.sty|driver|notikzdriver>
%<tikz> TikZ support for Formal Concept Analysis]
%<*driver|notikzdriver>
% In the DocInput part this code is blocked by the preceeding
% \backslash iffalse.
% However, TeX scans for all \backslash if statements in a fast
% forward mode in order to find nested ifs. Thus it also sees
% the following statement, if it is written in assembled form.
% That's why we use |csname|, here.
\expandafter\newif\csname iffcatikzdoc\endcsname
%</driver|notikzdriver>
%<notikzdriver>  \fcatikzdocfalse
%<*driver>
% Check whether we should disable \TikZ for documentation generation
\fcatikzdoctrue
%</driver>
%<*driver|notikzdriver>
% Hack around the convention to use the vertical bar for macro names.
% This clashes with the tabular environment.
\newcommand\VertStroke{|}
\edef\catcodebarlatex{\noexpand\catcode`|=\the\catcode`|\relax}%
\documentclass[a4paper]{ltxdoc}
\def\catcodebarltxdoc{\noexpand\catcode`|=\active\relax}%
%\usepackage{a4}
\usepackage{dtxdescribe}
% |\tikz| gets overwritten when we load TikZ later. So we have to save
% it somehow else
\newcommand\TikZ{Ti\emph{k}Z}
%\let\TikZ\tikz
\newcommand\PGF{\acro{PGF}}
\usepackage{iftex}
\makeatletter
\@ifundefined{ifluatex}{
  \usepackage{ifluatex}
}{}
\makeatother
\usepackage{fca}
\iffcatikzdoc
  \usepackage{tikz}
  \ifLuaTeX
    \usetikzlibrary{luamath}
  \fi
  \usetikzlibrary{calc}
\else
  \ifLuaTeX
    \usepgflibrary{luamath}
  \fi
\fi
%
\let\fcadtxexample\dtxexample
\makeatletter
\def\fca@dtxexample#1#2{%
  \typeout{Example: #2}%
  \tsdtxexample#1{#2}%
}
\def\fcadtxexample{\@ifstar{\fca@dtxexample*}{\fca@dtxexample{}}}
\makeatother

% we hack the cxt environment so that it deactivates the vertical
% bar. Otherwise it would break vertical column rules in context.
% Since \LaTeXe from 2020-08-21 we can use hooks for that
%
%
\iftrue
  \NeedsTeXFormat{LaTeX2e}[1999/12/01]
  \expandafter\def\expandafter\cxt
  \expandafter{\expandafter\catcodebarlatex\cxt}%
  \expandafter\def\expandafter\endcxt
  \expandafter{\endcxt\catcodebarltxdoc}%
\else
  \NeedsTeXFormat{LaTeX2e}[2020/08/21]
  \AddToHook{env/cxt/before}{%
    \catcodebarlatex
  }
  \AddToHook{env/cxt/after}{%
    \catcodebarltxdoc
  }
\fi

% We want to keep the version information of the whole package at one
% and the same place in the file. So we extract the version
% information from the version string.
\makeatletter
\newcommand\fca@parseversion{}
\def\fca@parseversion#1 #2 #3\fca@parseversion{%
  \def\fcacurrentversiondate{#1}%
  \def\fcacurrentversionversion{#2}%
  \def\fcacurrentversiondescription{#3}%
}
\newcommand\fcaparseversion[1]{%
  \edef\@tempa{\noexpand\fca@parseversion\csname ver@#1\endcsname{}
    \noexpand\fca@parseversion}%
  \@tempa
}
\makeatother

% \selectlanguage{english}
%
\usepackage{iftex}
\ifLuaTeX
\else
  \usepackage[utf8]{inputenc}
  \usepackage[T1]{fontenc}
\fi
\usepackage[english]{babel}
\usepackage{lmodern}
\usepackage{xcolor}
% \usepackage[%
%   colorlinks=false,
%   allbordercolors={0.9 0.9 0.9},
%   breaklinks=true,
%   ]{hyperref}

\RequirePackage{stmaryrd,bm}
\usepackage[numbered]{hypdoc}
\hypersetup{
   pdfauthor = {Bernhard Ganter, Tobias Schlemmer},
   pdfkeywords = {FCA LaTeX style diagram context},
   pdftitle = {fca.sty – LaTeX macros for Formal Concept Analysis},
   pdfsubject = {LaTeX style file for typesetting formal contexts and
     concept lattices},
   linkcolor = blue
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\def\fcastyle{\texttt{fca.sty}\xspace}
%<*driver>
\fcaparseversion{\jobname.dtx}
%</driver>
%<notikzdriver>\fcaparseversion{\jobname.tex}
\title{\fcastyle\protect\\\LaTeX--macros for Formal Concept Analysis\protect\\
  \fcacurrentversionversion}
\author{Bernhard Ganter\thanks{TU Dresden, Ernst-Schröder-Zentrum
    f\"ur Begriff{}liche Wissensverarbeitung}\protect\\
  Tobias Schlemmer\thanks{TU Dresden}}
\date{\fcacurrentversiondate}
\begin{document}
\errorcontextlines=1000\relax
\edef\latexfcajobname{\jobname}%
\edef\latexfcasourcefile{\detokenize{latex-fca}}%
\ifx\latexfcajobname\latexfcasourcefile
  \DocInput{latex-fca.dtx}
\else
  \DocInput{../../../source/latex/fca/latex-fca.dtx}
\fi
\end{document}
%</driver|notikzdriver>
%<*fcadoc>
% \fi
% \maketitle
% \begin{abstract}
% \FCA is a field of mathematics based on the theory of ordered sets
% and complete lattices, with applications to data analysis and
% knowledge processing.
% To simplify typesetting of FCA-related text, \fcastyle  provides two
% environments and some simple text macros. The two environments are
% \begin{description}
% \item[cxt] for typesetting small formal contexts as cross-tables, and
% \item[diagram] for making line diagrams of concept lattices. This environment
%   may be of some interest for other purposes as well, since it can also be
%   used for ordered sets and graphs.
% \end{description}
% A list of \textbf{text macros} is given in Section~\ref{sec:macros}
% below.
% \medbreak\par\noindent
% A recent version of \texttt{fca.sty} should be available from
% \begin{center}
%  \url{https://github.com/keinstein/latex-fca}
% \end{center}
% \end{abstract}
%
% \tableofcontents
%
% \section{Loading the package}
%
% The package |fca| is loaded by adding
% \begin{verbatim}\usepackage{fca}\end{verbatim}
% to the preamble.
%
% There is a package option, \texttt{compat}, to be used for files
% which were written for older versions up to Version 2.1 of
% \texttt{fca.sty}. See Section~\ref{subsec:compat} for details.
%
% The \texttt{newdrawline.sty} package is no longer needed.
%
% \section{Typesetting formal contexts with \env{cxt}}
% Formal contexts can be typeset using the |cxt| environment. What
% this (very simple) environment does can be guessed from an example.
% \begin{dtxexample}{A formal context.}
%   \begin{cxt}
%     \cxtName{Formula 1}
%   %
%     \att{1.}
%     \att{2.}
%     \atr{disqualified}
%   %
%     \obj{x..}{Verstappen}
%     \obj{.x.}{Hamilton}
%     \obj{.xx}{Leclerc}
%   \end{cxt}
% \end{dtxexample}
% \subsection{Basic usage of the \env{cxt} environment}
% \DescribeEnv{cxt}
%
% \DescribeMacro{\begin\{cxt\}} begins typesetting a formal context table.
%
% The commands within a \env{cxt} environment are
%
% \DescribeMacro{\cxtName}\marg{text}  Define the text for the upper
% left cell of the table. Optional. The default is no text.
%
% \DescribeMacro{\att}\marg{text} Give an attribute name. These names
% are processed in the order in which they are given. Attribute names
% given after an |\obj|  command are ignored.
%
% \DescribeMacro{\atr}\marg{text} Same as |\att|, but with rotated text.
%
% \DescribeMacro{\obj}\marg{text}\marg{text} Give an object's name and
% its incidence vector, consisting of dots and `x'es. The incidences
% come first, for better alignment. The length of each incidence
% vector must be the number of attributes.
%
% Each  instance of |\obj| is directly translated to a row of the
% |tabular|-environment. It is therefore possible to mix  |\obj|
% commands with usual  |tabular|-commands.
%
% \DescribeMacro{\end\{cxt\}} Completes typesetting the context table.
%
% \texttt{cxt} can handle an arbitrary number of attributes.
%
% \subsubsection{Other predefined entries}
% An incidence vector for an object consists of dots and crosses
% (``\texttt{x}'' or ``\texttt{X}'').
% The arrow relations may also be noted. Instead of \texttt{x} and \texttt{.},
% type \texttt{d} (for ``down''), \texttt{u} (``up''), or \texttt{b} (``both'').
% In the following example, we also change the colour of these symbols:
%
% \begin{dtxexample}{Some predefined context characters, colour changed.}
% \begin{cxt}%
% \renewcommand{\fcaCxtArrowStyle}{\footnotesize\color{red}}%
% \cxtName{Formula 1}
% \att{1.}
% \att{2.}
% \atr{disqualified}
% \obj{xbd}{Verstappen}
% \obj{uxb}{Hamilton}
% \obj{bxx}{Leclerc}
% \end{cxt}
% \end{dtxexample}
%
% The default for |\fcaCxtArrowStyle| is |\footnotesize|. In the above
% example we have changed it using |\renewcommand| in order to make the
% arrows red. The default colour is black.
%
% The digits 0 to 9 may be used as well.
%
% \subsection{Advanced usage of the \env{cxt} environment}
% \subsubsection{Defining context characters}
%
% You can define your own markers using |\fcaNewContextChar|. It
% works like |\newcommand| but defines a single character. For
% single signs use |\cxtrlap| in order to give it an appropriate
% size. We give two examples. The first introduces a single new
% context character for so-called ``tight'' incidences. These are
% indicated by a boldface cross (for which the \texttt{bm} package was
% used).
% The second example is discussed below.
%
% \begin{dtxexample}{(Re-)defining context characters.}
% \begin{cxt}
% \fcaNewContextChar{t}{\cxtrlap{$\bm{\times}$}}
% \cxtName{cxt 1}
% \att{1.}
% \att{2.}
% \atr{disqualified}
% \obj{t..}{Verstappen}
% \obj{.t.}{Hamilton}
% \obj{.xt}{Leclerc}
% \end{cxt}
% \qquad
% \begin{cxt}
% \fcaNewContextChar{v}{\cxtrlap{$\vee$}}
% \fcaProvideContextChar{\wedge}{\cxtrlap{$\wedge$}}
% \fcaProvideContextChar{d}{ -- ignored -- }
% \fcaRenewContextChar{d}{\cxtrlap{$i$}}
% \cxtName{cxt 2}
% \att{1.}
% \att{2.}
% \atr{disqualified}
% \obj{x.v}{Verstappen}
% \obj{\wedge xb}{Hamilton}
% \obj{dxx}{Leclerc}
% \end{cxt}
% \end{dtxexample}
%
% The second example (with context name ``cxt 2'') shows different ways
% to define context characters. First |\fcaNewContextChar| is used so that
% the symbol |$\vee$| is inserted whenever the letter ``v'' occurs in
% the the incidence vector of an object. The next line associates the
% ``token'' |\wedge| to the symbol |$\wedge$|, using
% |\fcaProvideContextChar|, which does the same as |\fcaNewContextChar|,
% except that no error message is given when the context character was
% already defined. Instead, the command will then be ignored. If you
% want to force the redefinition of a context character, you should use
% |\fcaRenewContextChar|.
%
% There is one more possibility:
%
% \DescribeMacro{\freeobj}{\marg{text}}
% You may define a marker with a single
% argument that typesets its argument. There also is a macro
% |\freeobj| that takes a tabular row  as argument instead of the
% usual markers.  The following example illustrates these:
%
% \noindent\begin{minipage}[t]{.45\textwidth}
% \textit{\footnotesize \ Code:}
% \begin{verbatim}
% \begin{cxt}
% \fcaNewContextChar{w}[1]{#1}
% \cxtName{Formula 1}
% \att{1.}
% \att{2.}
% \atr{disqualified}
% \obj{5bw1}{Verstappen}
% \obj{w2xw{77}}{Hamilton}
% \freeobj{1&2&3}{Leclerc}
% \end{cxt}
% \end{verbatim}
% \end{minipage}
% \hfill
% \begin{minipage}[t]{.40\textwidth}
% \textit{\footnotesize \ Result:}\par\noindent
% \begin{cxt}%
% \fcaNewContextChar{w}[1]{\cxtrlap{#1}}%
% \cxtName{Formula 1}%
% \att{1.}%
% \att{2.}%
% \atr{disqualified}%
% \obj{5bw1}{Verstappen}
% \obj{w2xw{77}}{Hamilton}
% \freeobj{\cxtrlap{1}&2&3}{Leclerc}
% \end{cxt}
% \end{minipage}
%
%
% \subsubsection{\env{cxt} alignment}
%
% |cxt| takes an optional alignment parameter, which can be one of
% \texttt{t, c} or \texttt{b}. It is passed to the tabular
% environment (see there for further documentation).
%
% \begin{dtxexample}{Alignment parameter for a \env{cxt}-environment}
%   \makebox{
%   \begin{cxt}[t]
%     \cxtName{Formula t}
%     %
%     \att{1.}
%     \att{2.}
%     \atr{disqualified}
%     %
%     \obj{x..}{Verstappen}
%     \obj{.x.}{Hamilton}
%     \obj{.xx}{Leclerc}
%   \end{cxt}\quad
%   \begin{cxt}[c]
%     \cxtName{Formula c}
%     %
%     \att{1.}
%     \att{2.}
%     \atr{disqualified}
%     %
%     \obj{x..}{Verstappen}
%     \obj{.x.}{Hamilton}
%     \obj{.xx}{Leclerc}
%   \end{cxt}\quad
%   \begin{cxt}[b]
%     \cxtName{Formula b}
%     %
%     \att{1.}
%     \att{2.}
%     \atr{disqualified}
%     %
%     \obj{x..}{Verstappen}
%     \obj{.x.}{Hamilton}
%     \obj{.xx}{Leclerc}
%   \end{cxt}
%   }
% \end{dtxexample}
%
%
%
% \subsubsection{Including Burmeister context files}
%
% \DescribeMacro{\cxtinput}\marg{filname.cxt} The package |fca| allows
% to use context files in Burmeister format (which usually have the
% \texttt{.cxt} file name extension) to be included directly in a
% \LaTeX{} document. Its usage is as simple as possible.
%
% \begin{dtxexample}{Including a Burmeister context file}
% \begin{cxt}
% \cxtinput{formula1.cxt}
% \end{cxt}
% \end{dtxexample}
%
% The name of the context can be overwritten by using |\cxtName|
% inside the \env{cxt} environment.
% \begin{dtxexample}{Overwriting the context name}
% \begin{cxt}
% \cxtName{Formula 2}
% \cxtinput{formula1.cxt}
% \end{cxt}
% \end{dtxexample}
%
% To get non-rotated attribute names, redefine the \texttt{atr} command
% as in the following example:
% \begin{dtxexample}{Including contexts with unrotated attributes}
% \begin{cxt}[b]
% \renewcommand{\atr}{\att}
% \cxtinput{formula1.cxt}
% \end{cxt}\quad
% \begin{cxt}[b]
% \cxtName{Formula 2}
% \cxtinput{formula1.cxt}
% \end{cxt}
% \end{dtxexample}
%
% \section{Drawing lattices with \env{diagram}}
% The \texttt{diagram} environment helps typesetting diagrams of concept
% lattices, but can be used for ordered sets and graphs as well.
% As of version 3.0, the \env{diagram} environment uses the
% \emph{Portable Graphics Format} \PGF\ and, if loaded, its
% user-friendly syntax layer called \TikZ.
%
% Again we start with a small example (for which we set |\unitlength 1.2mm|):
%
% \begin{dtxexample}{A lattice diagram\label{dtx:diagram}}
%   {\unitlength 1.2mm
%   \begin{diagram}
%   \Node(1)(20,10)
%   \Node(2)(35,20)
%   \Node(3)(5,30)
%   \Node(4)(35,40)
%   \Node(5)(20,50)
%   \Edge(1)(2)
%   \Edge(1)(3)
%   \Edge(2)(4)
%   \Edge(3)(5)
%   \Edge(4)(5)
%   \leftAttbox(3){1.}
%   \rightAttbox(2){disqualified}
%   \rightAttbox(4){2.}
%   \leftObjbox(3){Verstappen}
%   \rightObjbox(2){Leclerc}
%   \rightObjbox(4){Hamilton}
% \end{diagram}}
% \end{dtxexample}
%
% \subsection{Basic usage of the \env{diagram} environment}
% \label{subsec:diagram-basic}
% \DescribeEnv{diagram}
%
% \DescribeMacro{\begin\{diagram\}} begins a \PGF{}-picture.
% Unlike the previous versions, width and height of the diagram no
% longer need to be specified. The old syntax
%
% |\begin{diagram}{width}{height}|
%
% is still supported and determines the bounding box, which is                %
% otherwise calculated automatically.
%
% A major advantage of using \PGF{}-pictures is that one can use the many
% possibilities offered by \PGF, even without knowing much about \PGF.
% The |diagram| environment and its macros allow  optional parameters,
% e.g. for colour, line thickness, etc. These will be described in
% Section~\ref{subsec:fine}.
%
% The commands within a \env{diagram} environment (in their basic form) are
%
% \DescribeMacro{\Node}\parg{nodenumber}\parg{xpos,ypos}
% Puts a circle at position \texttt{(xpos,ypos)} of the picture. The default
% diameter of the circles is 4 (times |\unitlength|). It can be changed
% (for all circles) with |\fcaCircleSize{}|. The argument must be an integer.
% The node names must be different, but in contrast to previous
% versions, they do not have to be numbers, although this is
% recommended for clarity.
%
% The old syntax |\Node{nodenumber}{xpos}{ypos}| is also supported.
%
% \DescribeMacro{\Edge}\marg{nodenumber1}\marg{nodenumber2}
% Puts a line between the two nodes with the given numbers. These must
% have been declared earlier with a |\Node|--command.
%
% \DescribeMacro{\leftAttbox}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\centerAttbox}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\rightAttbox}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\leftObjbox}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\centerObjbox}\parg{nodenumber}\marg{text}\\
% \DescribeMacro{\rightObjbox}\parg{nodenumber}\marg{text}
%
% These are used to put
% text to diagram nodes. The |Attbox|--commands place the text above the
% corresponding node, the |Objbox| below. Similarly, the text can be placed
% to the left, be centered, or be placed to the right of the labelled node.
%
% For a better positioning of the label text an optional shift can be
% specified. For example,
%
% |\rightObjbox(4)(3,5){Hamilton}|
%
% moves the object label ``Hamilton'' at node number 4 by
% 3\,|\unitlength| in x-direction and by 5\,|\unitlength| in y-direction.
%
% The old syntax |\rightObjbox{nodenumber}{xoffset}{yoffset}{labeltext}|
% is also supported. However, there is a small difference: while in
% the old syntax the shift |{xoffset}{yoffset}| is understood relative
% to the node, the shift |(xoffset,yoffset)| is interpreted relative
% to the diagram. This means that, e.g., |\leftAttbox{4}{3}{5}{text}|
% corresponds to |\leftAttbox(4)(-3,5){text}|.
%
% \DescribeMacro{\end\{diagram\}} This concludes the diagram.
%
%
% A helpful command when fine tuning a diagram is
%
% \DescribeMacro{\Numbers} Puts numbers inside circles.  While working on a
%  diagram it can be helpful to have a picture with numbered nodes.
%
% \begin{dtxexample}{Plotting numbers inside of nodes}
%   \fbox{\unitlength .7mm
%   \begin{diagram}{40}{55}
%     \Numbers
%     \Node{5}{20}{10}
%     \Node{6}{35}{20}
%     \Node{4}{5}{30}
%     \Node{8}{35}{40}
%     \Node{7}{20}{50}
%   \end{diagram}}
% \end{dtxexample}
%
% We recommend to remove the |\Numbers|--command when the diagram is
% ready. In most cases it is not a good idea to put text inside the
% nodes of a diagram.
%
% {\color{red} |\Numbers| sollte den Radius vergrößern.}
%
% \DescribeMacro{\NoNumbers} can be used to exclude individual nodes
% from the numbering.
%
% \subsection{Changes to the style of the graphics}
% \label{subsec:diagram-adv}
% The connection with \PGF\  and \TikZ\ results in many design tools,
% some of which will be presented in Section~\ref{sec:advanced}.
% Before that we show how to change colour and other graphics
% parameters in simple diagrams.
%
% \subsubsection{Optional parameters}
% All macros of the \env{diagram} environment, except for
% |\end{diagram}|, allow optional parameter. These can be specified
% within square brackets. For example,
%
% |\Node[draw=red, fill=blue](4)(20,10)|
%
% specifies that a red circle, filled with blue, is to be drawn
% at position (20,10), representing the node with nodenumber 4.
%
% The impatient reader may infer some of the possibilities from
% Example~10. For details see Subsection~\ref{subsec:fine}.
%
% \iffcatikzdoc
% \begin{dtxexample}{A \env{diagram} with some optional \TikZ{}
% parameters}
% {\unitlength 1.2mm
% \definecolor{darkgreen}{rgb}{0.05,0.5,0.}
% \begin{diagram}
%  \Node[draw=red, fill=green,line width=.5mm](1)(20,10)
%  \Node[fill=black, radius=1.5mm](2)(35,20)
%  \Node[opacity=0.3,fill=red](3)(5,30)
%  \Node[fill=darkgreen](4)(35,40)
%  \Node[/tikz/rectangle](5)(20,50)
%  {\color{red}\Edge(1)(2)}
%  \Edge[draw=blue,dotted,line width=1.5pt](1)(3)
%  \Edge(2)(4)
%  \Edge[draw=green,line width=1mm](3)(5)
%  \Edge(4)(5)
%   \leftAttbox(3){1.}
%   \rightAttbox(2){disqualified}
%   \rightAttbox(4){2.}
%   \leftObjbox(3){Verstappen}
%   \rightObjbox(2){Leclerc}
%   \rightObjbox(4){Hamilton}
% \end{diagram}}
% \end{dtxexample}
% \fi
%
% \subsubsection{Fine tuning}\label{subsec:fine}
% In Version 2.1 and before some macros that allow you to change
% certain parameters of the diagrams.
%
% For compatibility reasons these
% still do work in diagrams that use bare \PGF\ (i.e., that are not
% inside the argument to the \cs{tikz} macro or one of the
% environments \env{tikzpicture} or \env{tikzdiagram}).
%
% \DescribeMacro{\fcaCircleSize}\marg{size}
% The diameter of the circles that represent the concept nodes.
% The default is 4~(times |\unitlength|).
% Can be changed for single nodes by specifying the radius
% as an optional parameter (e.g., |[radius=3mm]|).
%
% \DescribeMacro {\fcaNodeColor}\marg{color} The color with which the
% concept nodes are filled.  The default is \textit{white}. Can be
% changed for single nodes by using |fill=|\textit{color} as an option.
%
% \DescribeMacro {\NodeColor}\marg{color} is an alias to
% \cs{fcaNodeColor} inside the \env{diagram} environment.
%
% \DescribeMacro {\fcaNodeThickness}\marg{thickness}
% The width of the annulus representing the circumferential line of a
% concept node. The default is 1.2pt.
% Can be changed for single nodes by specifying the line width
% as an optional parameter (e.g., |[line width=3pt]|).
%
% \DescribeMacro {\NodeThickness}\marg{thickness} an alias to
% \cs{fcaNodeThickness} inside a \env{diagram} environment.
%
% \DescribeMacro {\fcaEdgeThickness}\marg{thickness}
% The default is .8pt. It can be changed for all or for single edges by
% specifying |line width| as an optional parameter.
%
% \DescribeMacro {\EdgeThickness}\marg{thickness} an alias to
% \cs{fcaEdgeThickness} inside a \env{diagram} environment.
%
% These \watchout macros do not work reliably inside the \env{tikzpicture}
% and  \env{tikzdiagram} envronments. Please use the key/value syntax
% there.
%
% \subsection{Labels}
% Some of the nodes in a concept lattice diagram have text labels.
% Typically, object and attibute concepts are labeled with the
% associated object or attibute names. This is done using the
% |\**box(){}|-macros, which were introduced in
% Subsection~\ref{subsec:diagram-basic}.  Font size and font colour of
% such labels can be
% changed, and the label boxes as well. By default each label box is
% connected to the respective concept node by a dotted line. This can
% be switched off:
%
% \DescribeMacro {\fcaNoDots} Causes no dotted line to be drawn  from
% the concept node to the label boxes.
%
% \DescribeMacro {\NoDots} is an alias to
% \cs{fcaNoDots} inside a \env{diagram} environment.
%
% These macros can be focussed to single instances, using braces. For
% example,
% \begin{center}
% |{\fcaNoDots\centerObjbox(node){labeltext}}|
% \end{center}
% generates a single centered object label without a dotted line.
%
% Usually the label text is put into a
% one-line box  (i.e. hbox), the width of which is automatically
% detected. To allow  for line breaks, the parameter |text width| can
% be used. It affects  the type and size of the label boxes.
%
% When |text width| is set to a length, then the text of the label is put
% in a |\parbox|. It can be broken into several lines using |\\|. The
% width of the |\parbox| is the value of the |text width|
% parameter. It is unset by default.
%
% Setting |text width| to a length can either be done as an optional
% parameter to the diagram, such as
%
% |\begin{diagram}[text width=6mm]|
%
% or globally (for all diagrams) by
%
% |\fcaset{text width=6mm}|
%
% or for single labels only, again as an optional parameter.
%
% Label boxes may be framed with the \texttt{draw} option, which may also
% be used to set a color for the text and the frame. Their
% background color can be set with \texttt{fill}.
%
% The text properties of the lables are given by the next two
% commands, which  can be changed with |\renewcommand|.
%
%   \DescribeMacro{\fcaObjectLabelStyle} Used to define the font
%   of object labels \emph{outside} of \env{diagram} environments.
%   Default: |\small\baselineskip1em\rmfamily\upshape|
%
%   \DescribeMacro{\fcaAttributeLabelStyle} Used to define the font
%   of object labels \emph{outside} of \env{diagram} environments.
%   Default: |\small\baselineskip1em\rmfamily\itshape|.
%
%   \DescribeMacro{\ObjectLabelStyle} and
%   \DescribeMacro{\AttributeLabelStyle}
%
%   are aliases of the above commands which can only be used
%   \emph{inside} of \env{diagram} environments.
%
% {\unitlength .7mm
% \begin{dtxexample}{Concept node labels\label{ex:concept node
%   labels}}
%   \begin{diagram}[text width=3.4cm]
%     \Node(0)(20,10)
%     \leftAttbox[draw](0)(-1,1){left\\ attribute\\ label}
%     \rightAttbox[fill=red!50!blue!20](0)(10,10){right
%     attri-\\ bute label}
%     \rightObjbox[draw=brown](0)(20,5){right\\ object\\ label}
%     {\fcaNoDots\centerObjbox(0)(0,-5){centered\\ object label}}
%   \end{diagram}
% \end{dtxexample}
% }
%
%
%
%
% \section{Some macros for text}
% \label{sec:macros}
% Abbreviating macros are defined for some strings that occur
% regularly in FCA texts. See Figure~\ref{fig:macros} for quick
% overview.
% \begin{figure}[p]
%   \begin{center}
%    \begin{tabular}{\VertStroke c\VertStroke l\VertStroke l\VertStroke}\hline
% Result&command& German variant\\\hline
% $\GMI$&|\GMI|&\\
% $\context$&|\context|&\\
% $\context[L]$&|\context[L]|&\\
% $\CL$ &|\CL| &|\BV| \\
% $\BVGMI$  &|\CLGMI| &|\BVGMI| \\
% $\BGMI$  & |\CGMI|& |\BGMI|\\
% $\extent{}$&|\extent{}|&\\
% $\intent{}$&|\intent{}|&\\
% $\extents{}$&|\extents{}|&\\
% $\intents{}$&|\intents{}|&\\
% $\HNI$   &|\HNI| & \\
% $\relI$   &|\relI| & \\
% $\notI$   &|\notI| & \\
% $\bigtimes$   &|\bigtimes| & \\
% $\Semi$   &|\Semi| & \\
% $\DownArrow$   &|\DownArrow|&|\Runterpfeil| \\
% $\UpArrow$   &|\UpArrow| &|\Hochpfeil| \\
% $\DoubleArrow$   &|\DoubleArrow| &|\Doppelpfeil| \\
% $\DDArrow$   &|\DDArrow| &|\DDPfeil| \\
% $\NDDArrow$   &|\NDDArrow| &|\NDDPfeil| \\
% \FCA   &|\FCA| & \\
% \FBA   & &|\FBA| \\
% \FnBA   & &|\FnBA| \\\hline
%      \end{tabular}
% \caption{Table of \texttt{fca.sty} text macros.}\label{fig:macros}
%  \end{center}
% \end{figure}
% \begin{figure}[p]
%  \begin{center}
%      \begin{tabular}{\VertStroke l\VertStroke l\VertStroke l\VertStroke }\hline
% Symbol&command&package required\\\hline
% $\vee$&|\vee|&\\
% $\wedge$&|\wedge|&\\
% $\bigvee$&|\bigvee|&\\
% $\bigwedge$&|\bigwedge|&\\
% $\sqcup$&|\sqcup|&\\
% $\sqcap$&|\sqcap|&\\
% $\bigsqcup$&|\bigsqcup|&\\
% $\bigsqcap$&|\bigsqcap|&stmaryrd\\\hline
% \end{tabular}
% \caption{Other symbols that are used in \FCA, and the commands that generate
%  them.}\label{fig:2}\end{center}
% \end{figure}
%
% \begin{description}
% \item[]|\GMI|\quad The formal context $\GMI$.
% \item[]|\context|\quad The symbol $\context$, a frequently used name for
%  a formal context.
% \item[]|\context[S]|\quad Other letters, such as $\context[S]$, may also
%  be used.
% \item[]|\CL|\quad The symbol $\CL$ for the concept lattice operator. If
%  ${\mathbb K}$ is a formal context, then $\CL({\mathbb K})$ denotes its
%  concept lattice.
% \item[]|\BV|\quad same as |\CL|.
% \item[]|\CLGMI|\quad The concept lattice $\CLGMI$ of the formal context
%  $(G,M,I)$.
% \item[]|\BVGMI|\quad Same as |\CLGMI|.
% \item[]|\CGMI|\quad The set $\CGMI$ of all formal concepts of the formal
%  context   $(G,M,I)$.
% \item[]|\BGMI|\quad Same as |\CGMI|.
% \item[]|\extent|\quad The extent $\extent{\mathfrak{c}}$ of the formal
%  concept $\mathfrak{c}:=(A,B)$ is  $A$.
% \item[]|\intent|\quad The intent $\intent{\mathfrak{c}}$ of the formal
%  concept $\mathfrak{c}:=(A,B)$ is  $B$.
% \item[]|\extents|\quad The set $\extents{\context}$ of extents of the
%  formal context $\context$.
% \item[]|\intents|\quad The set $\intents{\context}$ of intents of the
%  formal context $\context$.
% \item[]|\HNI|\quad The subcontext $\HNI$.
% \item[]|\relI|\quad The incidence relation $\relI$.
% {\color{red}\item[]|\notI|\quad The negation $\notI$ of the incidence
%  relation.}
% \item[]|\bigtimes|\quad The product symbol $\bigtimes$.
% \item[]|\DownArrow|\quad The $\Runterpfeil$ of the arrow relations.
% \item[]|\Runterpfeil|\quad Same as |\DownArrow|.
% \item[]|\UpArrow|\quad The $\Hochpfeil$ of the arrow relations.
% \item[]|\Hochpfeil|\quad   Same as |\UpArrow|.
% \item[]|\DoubleArrow|\quad  The $\Doppelpfeil$ of the arrow relations.
% \item[]|\Doppelpfeil|\quad   Same as |\DoubleArrow|.
% \item[]|\DDArrow|\quad Gives $\DDArrow$, the symbol for the transitive
%  closure of the arrow relations.
% \item[]|\DDPfeil|\quad  Same as |\DDArrow|.
% \item[]|\NDDArrow|\quad Gives $\NDDArrow$ the symbol for the negation of
%  $\DDPfeil$.
% \item[]|\NDDPfeil|\quad  Same as |\NDDArrow|.
% \item[]|\Semi|\quad Gives $\Semi$, the symbol for the semi-product.
% \item[]|\FCA|\quad Prints ``\FCA''.  In most cases, this command does not
%  eat the space following it (thanks to |\xspace|).
% \item[]|\FBA, \FnBA|\quad Print ``Formale(n) Begriffsanalyse''. These
%  commands also use |\xspace| so that blanks are preserved.
% \item[]Some symbols that are provided by \LaTeX\ are listed in
%  Figure~\ref{fig:2}.
% \end{description}
%
% \par\noindent
% Here is a sample text:
% \begin{verbatim}
% \FCA provides an elegant way to determine the congruence relations of
% a complete lattice. The congruence lattice of a doubly founded
% concept lattice $\CLGMI$ is isomorphic to $\CL(G,M,\NDDArrow)$.
% \end{verbatim}
% This translates to:
% \begin{center}
%  \begin{minipage}{.88\textwidth}
%  \FCA provides an elegant way to determine the congruence relations of a
%  complete lattice. The congruence lattice of a doubly founded concept lattice
%  $\CLGMI$ is isomorphic to $\CL(G,M,\NDDArrow)$.
%  \end{minipage}
% \end{center}
%
% \section{Advanced usage of the \env{diagram}
% environment} \label{sec:advanced}
% \subsection{Make your own diagram style}
% With some knowledge about \PGF\ and \TikZ\ you can define your own style
% for concept lattice diagrams. For multiple use such definitions can
% be outsourced using the  |\fcaset{}| macro.
%
% We demonstrate this with an example where we define and then use a
% style called conexp style. It is based on Serhiy Yevtushenko's
% \texttt{Concept Explorer}, in which object and attribute concepts
% are color-coded, by a black lower semicircle and a blue upper
% semicircle, respectively. The version presented in this example does
% not behave well when the radius of concept nodes is changed.
%
% \begin{dtxexample}{Defining a \env{diagram} style}
% \fcaset{conexp style/.style={%
%     every attributes/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=blue,
%         anchor=south,
%         outer sep=0pt,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid
%       }
%     },
%     every objects/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=black,
%         anchor=south,
%         outer sep=0pt,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid,
%         rotate=180
%       }
%       }}}
% \end{dtxexample}
%
% To apply the defined style, use its name as an optional argument of
% \texttt{$\backslash$begin\{diagram\}}, or, if it shall be applied to
% single nodes only, as an optional argument for the respective node
% declarations.
%
% \begin{dtxexample}{Using a \env{diagram} style}
% {\unitlength 1.2mm
% \begin{diagram}[conexp style]
%   \Node(1)(20,10)
%   \Node(2)(35,20)
%   \Node(3)(5,30)
%   \Node(4)(35,40)
%   \Node(5)(20,50)
%   \Edge(1)(2)
%   \Edge(1)(3)
%   \Edge(2)(4)
%   \Edge(3)(5)
%   \Edge(4)(5)
%   \leftAttbox(3)(-1,1){1}
%   \rightAttbox(2)(1,1){disqualified}
%   \rightAttbox(4)(1,1){2.}
%   \leftObjbox(3)(-1,-1){Verstappen}
%   \rightObjbox(2)(1,-1){Leclerc}
%   \rightObjbox(4)(1,-1){Hamilton}
% \end{diagram}
% }
% \end{dtxexample}
%
% \subsection{\fcastyle, \PGF, and \TikZ}
% \fcastyle\ requires \PGF, the \emph{Portable Graphics Format}, but not
% necessarily its syntax layer \TikZ. That means that \PGF\ will be
% loaded automatically with \fcastyle, but \TikZ\ is not.  When you do
% not need any of \TikZ’s special features, you may slightly increase
% the processing speed by loading \fcastyle\ without \TikZ. Since
% \TikZ\ is built on \PGF, you can get from \PGF\ whatever you get from
% \TikZ, though often with difficulty.
%
% Most users will load both \fcastyle\ and \TikZ. In that case, and
% provided that you want to use \TikZ-features, you should also put
% |\usetikzlibrary{fca}| in the preamble.
%
% Even when both \TikZ\ and \fcastyle\ are loaded, there are still two
% possibilities. The |diagram| environment may be used inside or
% outside a |tikzpicture| (or a |\tikz| command).
% Table~\ref{tab:diagram-environments} gives an impression of the
% differences.
%
% To make sure that you are using |diagram| inside a |tikzpicture|,
% you may write |\begin{tikzdiagram}| \ldots |\end{tikzdiagram}|
% instead of |\begin{diagram}| \ldots |\end{diagram}|.
%
% \begin{table}[htbp]
%   \centering\footnotesize
% \newcommand{\Platz}{\rule[0pt]{0pt}{12pt}}
%   \fbox{\begin{tabular}{p{1.8cm}p{2.3cm}p{3cm}p{3cm}}
%       &\centering\env{diagram} environment with
%           \cs{usepackage\{fca\}}
%       &\centering\env{diagram} environment with
%           \cs{usetikzlibrary\{fca\} outside of \cs{tikz} or
%           \env{tikzpicture} environments}
%       &\centering\env{diagram} environment with
%           \cs{usetikzlibrary\{fca\}} inside \cs{tikz}
%           or a \env{tikzpicture} environment, or \env{tikzdiagram}\tabularnewline\hline\Platz
%      \raggedright Main command in~\cs{Node}
%         &\centering\cs{pgfnode}
%         &\centering\cs{pgfnode}
%         &\centering\cs{node} \tabularnewline\Platz
%       \raggedright Main command(s) in~\cs{Edge}
%         &\centering\cs{pgfmoveto},
%             \cs{pgflineto},
%             \cs{pgfusepath}
%         &\centering\cs{pgfmoveto},
%             \cs{pgflineto},
%             \cs{pgfusepath}
%         &\centering\cs{draw(...) edge (...);}\tabularnewline\Platz
%       \raggedright Available options
%         &\centering all \optn{/fca/...}
%             &\centering all \optn{/fca/...} and\\
%       some \optn{/tikz/...}\footnotemark
%         &\centering all \optn{/fca/...}\\ and all
%         \optn{/tikz/...}\tabularnewline\Platz
%       \raggedright Macros from Section~\ref{subsec:fine}
%         &\centering working
%         &\centering working
%       &\centering not supported\tabularnewline\Platz
%           Compatibility with version 2.1 and below
%       &\centering yes
%       & \centering yes
%           &\centering partial\tabularnewline\Platz
%               \raggedright Initial unit lengths
%           & (\cs{unitlength}, \makebox{{} \cs{unitlength}})
%           & (\cs{unitlength}, \makebox{{} \cs{unitlength}})
%           & \centering Current \TikZ{} transformation matrix for coordinates
%               and
%             \cs{unitlength} for other sizes (line width, node
%             radius, etc.)
%     \end{tabular}}
%   \caption[diagram environments]{Comparison of the different diagram
%   environments}
%   \label{tab:diagram-environments}
% \end{table}
% \footnotetext{options for \cs{pgfusepath} are limited to those from
%             \filenm{fca.sty}}
%
% You can put your \env{diagram} into a \env{pgfpicture} or a
% \env{tikzpicture}. It will get a new ``scope'' in order to prevent
% bleeding of options into later graphics operations. Putting more
% than one diagram into one \env{pgf-} or \env{tikzpicture} may
% require giving each of these diagrams its own namespace by setting
% the \optn{namespace=\meta{name}} option for each \env{diagram}
% environment to a different \meta{name}.
%
% \iffcatikzdoc
%
% \PGF\ and \TikZ\ may be used inside a \env{diagram} environment, but
% with some caution.  \PGF\ uses canvas transformations, and these can
% collide with the \env{diagram} commands. To avoid such collisions,
% \PGF\ or \TikZ\ command sequences should be encapsulated. The
% \emph{pgfscope} environment is used for this purpose.
% Example~\ref{dtx:pgf-diagram} illustrates this. The same diagram is
% drawn as in our earlier examples (e.g., Example~\ref{dtx:diagram}),
% but is decorated using \PGF. First a red circle with center
% $(20,10)$|\unitlength| is drawn around the word ``Example''.  Then a
% green line is drawn from the north east of Node 1 to the west of
% Node 5, and finally a blue line bisecting Node 2.
%
%   {\unitlength 1.2mm\relax
%   \begin{dtxexample}*{Using \PGF\ inside a diagram
%   environment \label{dtx:pgf-diagram}}
%   \begin{diagram}
%     \begin{pgfscope}
%       \color{red}
%       \pgftransformshift{\pgfpoint{20\unitlength}{30\unitlength}}%
%       \pgfnode{circle}{center}{\Large Example}{example
%       text}{\pgfusepath{stroke}}%
%     \end{pgfscope}
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \Node(3)(5,30)
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \Edge(1)(3)
%     \Edge(2)(4)
%     \Edge(3)(5)
%     \Edge(4)(5)
%     \leftAttbox(3){1.}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \leftObjbox(3){Verstappen}
%     \rightObjbox(2){Leclerc}
%     \rightObjbox(4){Hamilton}
%     \begin{pgfscope}
%       \edef\tempa{%
%       \noexpand\pgftransformshift{%
%       \noexpand\pgfpointanchor{\pgfkeysvalueof{/fca/name%
%       prefix}2\pgfkeysvalueof{/fca/name suffix}}{west}}%
%     }%
%       \tempa
%       \pgfmoveto{\pgfpoint{0pt}{0pt}}%
%       \pgflineto{\pgfpoint{4\unitlength}{0pt}}
%       \pgfsetstrokecolor{blue}
%       \pgfusepath{stroke}
%     \end{pgfscope}%
%     {
%       \pgfmoveto{\pgfpointanchor{fca node 5}{west}}
%       \pgflineto{\pgfpointanchor{fca node 1}{north east}}
%       \pgfsetstrokecolor{green}
%       \pgfusepath{stroke}
%     }
%     \end{diagram}
% \end{dtxexample}
% }
%
% \fi
%
% \textcolor{red}{\bf Bernhards Arbeitsende}
%
% \iffalse
%
% \section {weiter im normalen Text}
%
% \begin{dtxexample}*{A \protect\TikZ diagram}
%   \begin{tikzpicture}[x=0.1cm, y=0.1cm]
%    %     x and y should have the same size, here
%     \node[red,shape=circle,anchor=center,draw=red] (example
%     text) at (20,30) {\Huge Example};
%     \begin{diagram}[
%       every attributes/.append style={
%         label concept/.append style={
%           shape=semicircle,
%           fill=blue,
%           anchor=south,
%           minimum height=2\unitlength,%
%           label/name suffix=attribute concept,
%           label/at=center,%
%           solid
%         }
%       },
%       every objects/.append style={%
%         label concept/.append style={%
%           shape=semicircle,
%           fill=black,
%           anchor=south,
%           minimum height=2\unitlength,
%           rotate=180,
%           label/name suffix=attribute concept,
%           label/at=center,
%           solid,
%         }
%       },
%         shift={(0pt,0pt)}]
%       \Node[/tikz/draw=orange](1)(20,10)
%       \Node(2)(35,20)
%       \Node[/tikz/opacity=0.3](3)(5,30)%
%       \Node(4)(35,40)
%       \Node(5)(20,50)
%       \Edge(1)(2)
%       \Edge[/tikz/opacity=0.3](1)(3)
%       \Edge[/tikz/arrows=<->](2)(4)
%       \Edge[/tikz/opacity=0.3](3)(5)
%       \Edge(4)(5)
%       \leftAttbox[/tikz/opacity=0.3](3){1.}
%       \rightAttbox(2){disqualified}
%       \rightAttbox(4){2.}
%       \leftObjbox[/tikz/opacity=0.3](3){Hamilton}
%       \rightObjbox(2){Massa}
%       \rightObjbox(4){Alonso}
%       \path[draw,red] (\pgfkeysvalueof{/fca/name
%       prefix}2\pgfkeysvalueof{/fca/name suffix}.west)
%       -- +(4\unitlength,0pt);
%       \path[draw,red!50!yellow] (2.west)
%       -- +(4\unitlength,0pt);
%       \draw[green] (fca node 5.west)--(fca node 1.north east);
%     \end{diagram}
%   \end{tikzpicture}
% \end{dtxexample}
%
% The same diagram can be typeset using \PGF:
%
% {\unitlength 1.2mm\relax
% \begin{dtxexample}*{A \PGF\  enhanced diagram}
%   \begin{diagram}[
%     every attributes/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=blue,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid
%       }
%     },
%     every objects/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=black,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid,
%         rotate=180
%       }
%       }]
%     \begin{pgfscope}
%       \color{red}
%       \pgftransformshift{\pgfpoint{20\unitlength}{30\unitlength}}%
%       \pgfnode{circle}{center}{\Huge Example}{example
%       text}{\pgfusepath{stroke}}%
%     \end{pgfscope}
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \begin{pgfscope}
%       \pgfsetstrokeopacity{0.3}
%       \pgfsetfillopacity{0.3}
%       \Node(3)(5,30)
%     \end{pgfscope}
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \begin{pgfscope}
%       \pgfsetstrokeopacity{0.3}
%       \Edge(1)(3)
%     \end{pgfscope}
%     \begin{pgfscope}
%       \pgfsetarrows{<->}
%       \Edge(2)(4)
%     \end{pgfscope}
%     \begin{pgfscope}
%       \pgfsetstrokeopacity{0.3}
%       \Edge(3)(5)
%     \end{pgfscope}
%     \Edge(4)(5)
%     \begin{pgfscope}
%       \pgfsetstrokeopacity{0.3}
%       \pgfsetfillopacity{0.3}
%       \leftAttbox(3){1.}
%     \end{pgfscope}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \begin{pgfscope}
%       \pgfsetstrokeopacity{0.3}
%       \pgfsetfillopacity{0.3}
%       \leftObjbox(3){Verstappen}
%    \end{pgfscope}
%     \rightObjbox(2){Leclerc}
%     \rightObjbox(4){Hamilton}
%     \begin{pgfscope}%
%       \edef\tempa{%
%       \noexpand\pgftransformshift{%
%       \noexpand\pgfpointanchor{\pgfkeysvalueof{/fca/name prefix}2\pgfkeysvalueof{/fca/name suffix}}{west}}%
%     }%
%       \tempa
%       \pgfmoveto{\pgfpoint{0pt}{0pt}}%
%       \pgflineto{\pgfpoint{4\unitlength}{0pt}}
%       \pgfsetstrokecolor{red}
%       \pgfusepath{stroke}
%     \end{pgfscope}%
%     {
%       \pgfmoveto{\pgfpointanchor{fca node 5}{west}}
%       \pgflineto{\pgfpointanchor{fca node 1}{north east}}
%       \pgfsetstrokecolor{green}
%       \pgfusepath{stroke}
%     }
%   \end{diagram}
% \end{dtxexample}
% }
%
%
%   The old syntax is also supported:
%
% {\unitlength 1.2mm\relax
% \begin{dtxexample}*{A diagram}
%   \begin{diagram}[
%     every attributes/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=blue,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         solid
%       }
%     },
%     every objects/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=black,
%         anchor=south,
%         minimum height=2\unitlength,
%         label/name suffix=attribute concept,
%         solid,
%         rotate=180
%       }
%     }]{40}{55}
%     \Node{1}{20}{10}
%     \Node{2}{35}{20}
%     \Node{3}{5}{30}
%     \Node{4}{35}{40}
%     \Node{5}{20}{50}
%     \Edge{1}{2}
%     \Edge{1}{3}
%     \Edge{2}{4}
%     \Edge{3}{5}
%     \Edge{4}{5}
%     \Numbers
%     \leftAttbox{3}{2}{2}{1.}
%     \rightAttbox{2}{2}{2}{disqualified}
%     \rightAttbox{4}{2}{2}{2.}
%     \leftObjbox{3}{2}{2}{Verstappen}
%     \rightObjbox{2}{2}{2}{Leclerc}
%     \rightObjbox{4}{2}{2}{Hamilton}
%     \begin{pgfscope}%
%       \edef\tempa{%
%       \noexpand\pgftransformshift{%
%       \noexpand\pgfpointanchor{\pgfkeysvalueof{/fca/name prefix}2\pgfkeysvalueof{/fca/name suffix}}{west}}%
%     }%
%       \tempa
%       \pgfmoveto{\pgfpoint{0pt}{0pt}}%
%       \pgflineto{\pgfpoint{4\unitlength}{0pt}}
%       \pgfsetstrokecolor{red}
%       \pgfusepath{stroke}
%     \end{pgfscope}%
%   \end{diagram}
% \end{dtxexample}
% }
%
% \subsection{Which environment to choose?}
% There are several options how to start and end a \env{diagram}
% environment. Table~\ref{tab:diagram-environments} gives a short
% overview of \TeX{}nical differences between them.
%
% You can put your \env{diagram} into a \env{pgfpicture} or a
% \env{tikzpicture}. In that case the diagram is drawn in a new scope
% in order to prevent bleeding of options into later graphics
% operations. This option also allows to put several diagrams into one
% picture. You can keep each of the diagrams in its own namespace by
% setting the \optn{namespace=\meta{name}} option for each
% \env{diagram} environment to a different \meta{name}.
%
% When you don't need any of \TikZ{}'s special features, you can
% slightly increase the processing speed when you load
% \filenm{fca.sty} directly instead through \TikZ{}.
%
% When \TikZ{} is unsed elsewhere in your document (or if you need
% some of \TikZ{} special features in your diagram), you have still
% the choice whether \env{diagram} should access \PGF{} directly or
% via \TikZ{}. Direct access to \PGF{} is probably faster and provides
% more compatibility to prior versions of \filenm{fca.sty}. When
% \TikZ{} is loaded, implementation uses some \TikZ{} internals, so
% that some improvements of \TikZ{} are also accessible in the when \PGF{}
% is directly accessed.
%
% When put into a \TikZ{} graphics a \env{diagram} acesses \PGF{}
% through the \TikZ{} frontend layer. The environment
% \env{tikzdiagram} behaves in the same way. This provides even deeper
% integration with \TikZ{} graphics. As a drawback the macros from
% Section~\ref{subsec:fine} do not work reliably anymore. So you must
% use options and styles for fine tunging the diagram.
%
% Due to the way \watchout\TikZ{} is internally implemented, a
% \env{diagram} or a \env{pgfpicture} environment inside the argument
% to \cs{tikz} or inside a \env{tikzpicture} environment is always
% processd as \TikZ{} graphics, independent from whether the graphics
% has been interrupted or not.
%
% \fi
% \section{About the current version of \env{fca.sty}}
% The original version of fca.sty had been written by Bernhard Ganter,
% mainly for his personal use. With the further development of \TeX,
% especially the introduction of \TikZ, this package became
% obsolete. Then, in 2022, Tobias Schlemmer, on behalf of the Ernst
% Schröder Center, set up the completely revised version that is now
% available.
% \subsection{Compatibility with earlier versions}\label{subsec:compat}
%
% In order to reduce incompatibilities with other packages,
% since version 2.2 of |fca.sty| nearly all macros of |fca.sty|
% belong to a so called namespace. That means most of them start with
% |\fca...|. Only within |cxt| and |diagram| environments this rule is
% relaxed.
%
% \DescribeOption{compat}
% There is a package option |compat| that also defines the old names
% which have been used before Version 2.2 of \fcastyle.
%
% The \watchout current implementation of |compat| should be only used
% to compile unmodified \LaTeX\ code written before Version~2.2. It
% maps the new macros to use the old ones. As soon as the new
% macros are redefined, the old ones are ignored. So make sure to replace all
% occurrences of the old macros by the corresponding new ones at once.
%
% \DescribeOption{nocompat}
% This option reverts the effect of |compat|.
%
% \subsection{Error messages}
% Package error messages are not yet implemented.
%
%
% \iftrue
%   \subsection{A caveat  for future implementations}
% \else
%   \subsection{Some warning about future implementations}
% \fi
%
% It is  discouraged to change |\unitlength| inside the \env{diagram}
% environment.
% Currently |\unitlength| is used inside in the \env{diagram}
% environment. However, since \PGF\  already comes with support for
% coordinate and canvas transformations, a future version might
% completely rely on them and abandon the usage of |\unitlength|.
% Then, |\unitlength| may be used only to initially set up the
% coordinate system and be ignored later.
%
% For the same reason, it is recommended to use only Euclidean
% coordinates for diagrams. Other coordinate systems should work,
% too. However, in that case the output may change with future
% versions of this package. In particular the algorithm for the
% calculation of the node radius may change, and changes to
% |\unitlength| inside the environment will have no effect.
%
% The newly added option to encapsulate a \env{diagram} environment
% inside a \env{tikzpicture} or \env{pgfpicture} already goes into
% that direction. In this usage the |\unitlength| register is set to
% the sum of the horizontal unit lengths of the x and the y
% coordinates as provided by the surrounding environment.
%
%
% \section{Some demonstrations}
% \iffcatikzdoc
% % \begin{dtxexample}{Changes of the bounding box with big numbers}
%   \fbox{\unitlength .7mm
%   \begin{diagram}
%     \Numbers
%     \Node[node number/.style={font=\huge\color{red},node font=\huge,
%     fill=orange},opacity=0.5]{5}{20}{10}
%     \Node[font=\color{red}]{6}{35}{20}
%     \Node{4}{5}{30}
%     \Node{8}{35}{40}
%     \Node{7}{20}{50}
%   \end{diagram}}
%   \fbox{\unitlength .7mm
%   \begin{diagram}
%     \Node{5}{20}{10}
%     \Node{6}{35}{20}
%     \Node{4}{5}{30}
%     \Node{8}{35}{40}
%     \Node{7}{20}{50}
%   \end{diagram}}
% \end{dtxexample}
% \fi
% \begin{figure}[htbp]
%   \centering
% \fcaset{conexp style/.style={%
%     every attributes/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=blue,
%         anchor=south,
%         outer sep=0pt,
%         minimum height=0.2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid
%       }
%     },
%     every objects/.append style={
%       label concept/.append style={
%         shape=semicircle,
%         fill=black,
%         anchor=south,
%         outer sep=0pt,
%         minimum height=0.2\unitlength,
%         label/name suffix=attribute concept,
%         label/at=center,
%         solid,
%         rotate=180
%       }
%       }}}
% \iffcatikzdoc
%    \begin{tikzdiagram}[
%       conexp style,
%       every concept/.append style={%
%         radius=0.2
%       },
%       /tikz/documentation/.style={
%         color=red,
%         font=\tiny,
%         outer sep=0pt,
%         inner sep=0pt,
%         anchor=east,
%         ->
%       }
%     ]
%     \Node(top)(0,2)
%     \Node(join)(0,1)
%     \Node(left)(-1,0)
%     \Node(right)(1,0)
%     \Node(meet)(0,-1)
%     \Node(bottom)(0,-2)
%     \Edge(join)(left)
%     \Edge(join)(top)
%     \Edge(left)(meet)
%     \Edge(join)(right)
%     \Edge(right)(meet)
%     \Edge(meet)(bottom)
%     \centerAttbox(top){top Attribute}
%     \leftAttbox(left){left Attribute}
%     \rightAttbox(right){right Attribute}
%     \centerObjbox(bottom){bottom object}
%     \leftObjbox(left){left object}
%     \rightObjbox(right){right object}
%     %     documentation
%     \draw[documentation,<-] (fca node join) -- +(6,0.25)
%       node[anchor=south west] (doku)
%       {\textbackslash Node(join)(0,-1)};
%     %     Other nodes are right aligned to the first docu node
%     \draw[documentation]
%       (fca node top attributes center -| doku.east)
%       node(centerAttBox)
%       {\textbackslash centerAttBox(join)\{top Attribute\}}
%       (centerAttBox) -- (fca node top attributes center);
%     \draw[documentation]
%       (fca node left attributes left -| doku.east) + (0,0.5)
%       node(leftAttBox)
%       {\textbackslash leftAttBox(join)\{left Attribute\}}
%       (leftAttBox.west) -- (fca node left attributes left.north east);
%     \draw[documentation] (fca node right attributes right -| doku.east)
%     node(rightAttBox){\textbackslash rightAttBox(join)\{right Attribute\}}
%     (rightAttBox) -- (fca node right attributes right);
%     \draw[documentation] (fca node left objects left -| doku.east) + (0,-0.5)
%     node(leftObjBox)
%     {\textbackslash leftObjBox(join)\{left Object\}}
%     (leftObjBox.west) -- (fca node left objects left.south east);
%     \draw[documentation] (fca node right objects right -| doku.east)
%     node(rightObjBox){\textbackslash rightObjBox(join)\{right
%     Object\}} (rightObjBox) -- (fca node right objects right);
%     \draw[documentation] (fca node bottom objects center -|
%     doku.east) node(centerObjBox){\textbackslash
%     centerObjBox(meet)\{bottom Object\}} (centerObjBox) -- (fca node
%     bottom objects center) ; \coordinate (edgepoint) at
%     ($(bottom)!0.5!(meet)$); \draw[documentation] (edgepoint -|
%     doku.east) node(centerObjBox){\textbackslash Edge(meet)(bottom)}
%     (centerObjBox) -- (edgepoint) ;
%   \end{tikzdiagram}
% \else
%   \fbox{This example needs \TikZ}
% \fi
%   \caption[diagram elements]{Elements of a  \env{diagram}
%   environment.}\label{fig:diagram-elements}
% \end{figure}
%
% \begin{fsourceverb}
% \begin{tikzdiagram}[
%     conexp style,
%     every concept/.append style={%
%       radius=0.2
%     },
%     /tikz/documentation/.style={
%       color=red,
%       font=\tiny,
%       outer sep=0pt,
%       inner sep=0pt,
%       anchor=east,
%       ->
%     }
%   ]
%   \Node(top)(0,2)
%   \Node(join)(0,1)
%   \Node(left)(-1,0)
%   \Node(right)(1,0)
%   \Node(meet)(0,-1)
%   \Node(bottom)(0,-2)
%   \Edge(join)(left)%
%   \Edge(join)(top)
%   \Edge(left)(meet)
%   \Edge(join)(right)
%   \Edge(right)(meet)
%   \Edge(meet)(bottom)
%   \centerAttbox(top){top Attribute}
%   \leftAttbox(left){left Attribute}
%   \rightAttbox(right){right Attribute}
%   \centerObjbox(bottom){bottom object}
%   \leftObjbox(left){left object}
%   \rightObjbox(right){right object}
%   %   documentation
%   \draw[documentation,<-] (fca node join) -- +(6,0.25)
%     node[anchor=south west] (doku)
%     {\textbackslash Node(join)(0,-1)};
%   %     Other nodes are right aligned to the first docu node
%     \draw[documentation]
%     (fca node top attributes center -| doku.east)
%     node(centerAttBox){%
%     \textbackslash centerAttBox(join)\{top Attribute\}%
%   } (centerAttBox) -- (fca node top attributes center);
%     \draw[documentation]
%     (fca node left attributes left -| doku.east) + (0,0.5)
%     node(leftAttBox){%
%     \textbackslash leftAttBox(join)\{left Attribute\}%
%   } (leftAttBox.west) -- (fca node left attributes left.north east);
%   \draw[documentation]
%     (fca node right attributes right -| doku.east)
%     node(rightAttBox){\textbackslash rightAttBox(join)\{right Attribute\}}
%     (rightAttBox) -- (fca node right attributes right);
%   \draw[documentation]
%     (fca node left objects left -| doku.east) + (0,-0.5)
%     node(leftObjBox){\textbackslash leftObjBox(join)\{left Object\}}
%     (leftObjBox.west) -- (fca node left objects left.south east);
%   \draw[documentation]
%     (fca node right objects right -| doku.east)
%     node(rightObjBox){\textbackslash rightObjBox(join)\{right Object\}}
%     (rightObjBox) -- (fca node right objects right);
%   \draw[documentation]
%     (fca node bottom objects center -| doku.east)
%     node(centerObjBox){%
%       \textbackslash centerObjBox(meet)\{bottom Object\}}
%     (centerObjBox) -- (fca node bottom objects center) ;
%   \coordinate (edgepoint) at ($(bottom)!0.5!(meet)$);
%   \draw[documentation] (edgepoint -| doku.east)
%     node(centerObjBox){%
%       \textbackslash Edge(meet)(bottom)}
%     (centerObjBox) -- (edgepoint) ;
%   \end{tikzdiagram}
% \end{fsourceverb}
%
% \StopEventually{\PrintChanges}
% \clearpage
% \section{The Code}\label{sec:the-code}
% \iffalse
%    \begin{macrocode}
%</fcadoc>
%<*fca.sty>
%    \end{macrocode}
% \fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% This is file `fca.sty' : LaTeX macros for Formal Concept Analysis           %
%                                                                             %
% Copyright  Bernhard Ganter   5/03                                           %
% Version of                   10/07                                          %
%                                                                             %
% This program is provided under the terms of the                             %
% LaTeX Project Public License distributed from CTAN                          %
% archives in directory macros/latex/base/lppl.txt.                           %
%                                                                             %
% This package contains two environments, called cxt and diagram,             %
% for typesetting formal contexts and order diagrams,                         %
% and a few macros for frequently used symbols in FCA.                        %
%                                                                             %
% Short descriptions are given below. A recent version of this file           %
% as well as a file named fcadoc.tex                                          %
% should be available at http://tu-dresden.de/Members/bernhard.ganter         %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%
% \subsection{Package options for fca.sty}
%
%    \begin{macrocode}
\newif\iffca@compat@macros
\fca@compat@macrosfalse
\DeclareOption{compat}{%
  \fca@compat@macrostrue
}
\DeclareOption{nocompat}{%
  \fca@compat@macrosfalse
}
%    \end{macrocode}
%    \begin{macrocode}
\ProcessOptions\relax
%    \end{macrocode}
%
% \subsection{Loading other packages and general helpers}
%    \begin{macrocode}
\RequirePackage{pgf}
\usepgflibrary{shapes.geometric}
\RequirePackage{amssymb,graphics,color,ifthen,rotating,xspace}%%
\@ifundefined{AfterPackage}{%
  \RequirePackage{afterpackage}%
}{}%
\AfterPackage{tikz}{%
  \usetikzlibrary{fca}%
}%
%    \end{macrocode}
%
% \begin{macro}{\fca@parselength}\marg{register}\marg{expression}\marg{default unit}
%   Evaluates \meta{expression}. If it has no unit the \meta{default
%   unit} is use instead. The result is stored in \meta{register}.
%    \begin{macrocode}
\newcommand*\fca@parselength[3]{%
  \pgfmathparse{#2}%
  \ifpgfmathunitsdeclared
    #1=\pgfmathresult pt\relax
  \else
    #1=\pgfmathresult#3%
  \fi
}
%    \end{macrocode}
%
% \end{macro}
%
% \subsection{The context environment \env{cxt}}
% \subsubsection{Some configurations}
%
% \begin{macro}{\fca@cxt@Kreuz}
% \begin{macro}{\fca@cxt@Punkt}
% \begin{macro}{\fcaCxtArrowStyle}
% \begin{macro}{\cxtArrowStyle}
% \changes{2.2}{2022/03/8}{rename \cs{cxtArrowStyle} to \cs{fcaCxtArrowStyle}}
% \begin{macro}{\fca@cxt@down}
% \begin{macro}{\fca@cxt@up}
% \begin{macro}{\fca@cxt@both}
%   First we define some symbols that are used in formal contexts.
%    \begin{macrocode}
\newcommand{\fca@cxt@Kreuz}{$\times$}%
\newcommand{\fca@cxt@Punkt}{}%
\iffca@compat@macros
  \newcommand{\cxtArrowStyle}{\footnotesize}
  \def\fcaCxtArrowStyle{\cxtArrowStyle}
\else
  \newcommand{\fcaCxtArrowStyle}{\footnotesize}
\fi
\newcommand{\fca@cxt@down}{\fcaCxtArrowStyle$\Runterpfeil$}%
\newcommand{\fca@cxt@up}{\fcaCxtArrowStyle$\Hochpfeil$}%
\newcommand{\fca@cxt@both}{\fcaCxtArrowStyle$\Doppelpfeil$}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \DescribeCounter{fca@cxt@mAnz}%
%   Count the number of attributes in the current context.
%    \begin{macrocode}
\newcounter{fca@cxt@mAnz}%
%    \end{macrocode}
%
% \DescribeBoolean{fca@cxt@ttributes}
% Record whether we ar still in
% the attributes section or whether we have already started the object
% section of a formal context.
%
% \changes{2.2}{2022/03/08}{Rename \bool{@ttributes} to \bool{fca@cxt@ttributes}}
%    \begin{macrocode}
\newboolean{fca@cxt@ttributes}%
%    \end{macrocode}
%
% \DescribeLength{\fca@cxt@nameraise}
% Helper length for vertical alignment of the context and attribute names.
% \DescribeLength{\fca@cxt@ttnameheight}
% Helper length for vertical alignment of the context and attribute names.
%
% \changes{2.2}{2022/03/08}{Rename \cs{@ttnameheight} to \cs{fca@cxt@ttnameheight}}
%
%    \begin{macrocode}
\newlength{\fca@cxt@nameraise}%
\newlength{\fca@cxt@ttnameheight}%
%    \end{macrocode}
%
%
% \begin{macro}{\adjcxt@name}
% Adjusts the the vertical alignment of the attributes.
%    \begin{macrocode}
\newcommand{\adjcxt@name}{%
  \ifthenelse{\fca@cxt@nameraise<\fca@cxt@ttnameheight}%
  {\setlength{\fca@cxt@nameraise}{\fca@cxt@ttnameheight}}{}}%
%    \end{macrocode}
%
% \end{macro}
%
% \begin{macro}{\alignBottom}
% \begin{macro}{\fcaCxtAlignBottom}
%   Align the current context to the bottom. Inside the \env{cxt}
%   environment the macro \cs{fcaCxtAlignBottom} is available in its
%   short form \cs{alignBottom}.
%
%   \changes{2.2}{2022/03/08}{add \cs{cxtAlignBottom}}
%    \begin{macrocode}
\newcommand{\fcaCxtAlignBottom}{\def\fca@cxt@align{b}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\alignCenter}
% \begin{macro}{\fcaCxtAlignCenter}
%   Align the current context to the top. Inside the \env{cxt}
%   environment the macro \cs{fcaCxtAlignCenter} is available in its
%   short form \cs{alignCenter}.
%
%   \changes{2.2}{2022/03/08}{add \cs{cxtAlignCenter}}
%    \begin{macrocode}
\newcommand{\fcaCxtAlignCenter}{\def\fca@cxt@align{t}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\alignTop}
% \begin{macro}{\fcaCxtAlignTop}
%   Align the current context to the top. Inside the \env{cxt}
%   environment the macro \cs{fcaCxtAlignTop} is available in its
%   short form \cs{alignTop}.
%
%   \changes{2.2}{2022/03/08}{add \cs{cxtAlignTop}}
%    \begin{macrocode}
\newcommand{\fcaCxtAlignTop}{\def\fca@cxt@align{t}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{The main structure of a formal context}
%
% Typically a context is created in the following way:
% \begin{enumerate}
% \item The environment \env{cxt} is opened. This sets up the basic
%   configuration. An empty name is constructed.
% \item Attributes are added to the context. They are added as tokens
%   to \cs{fca@cxt@tabtop}.
% \item When the control arrives at the first call to \cs{obj}, the
%   \env{tabular} environment is opened and \cs{att} and \cs{atr} are
%   disabled.
% \end{enumerate}
%
% \begin{macro}{\cxtName}
% \begin{macro}{\fcaCxtName}
%   Set the name of the current formal context. If used outside of a
%   \env{cxt} environment it sets the name for all following contexts.
%   Inside a \env{cxt} environment \cs{fcaCxtName} can be accessed
%   also with the shorter name \cs{cxtName}.
%   \changes{2.2}{2022/03/08}{rename \cs{cxtName} to \cs{fcaCxtName},
%   \cs{cxtName} is still accessible inside the \env{cxt} environment,
%   ignore spaces after the macro call}
%    \begin{macrocode}
\newcommand{\fcaCxtName}[1]{%
  \def\fca@cxtn@me{%
    \multicolumn{1}{|c||}{%
      \settoheight{\fca@cxt@ttnameheight}{#1}%
      \addtolength{\fca@cxt@nameraise}{-1\fca@cxt@ttnameheight}%
      \raisebox{.5\fca@cxt@nameraise}{#1}%
    }%
  }%
  \ignorespaces
}%
\iffca@compat@macros
  \newcommand{\cxtName}{\fcaCxtName}
\fi
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \begin{macro}{\fca@cxt@att}\marg{name}
% Implementation for \cs{att}. The corresponding alias is set up
% during \cs{begin}\marg{\env{cxt}}.
% \begin{macro}{\att}\marg{name}
%
% For each attribute the user must provide us a name either with
% \cs{att} or with \cs{atr}. Both save the prvided name as heading.
% For horizontally oriented attribute names (typically very short
% ones) the user should use \cs{att}.
%
% \changes{2.2}{2022/03/08}{rename \cs{att} to \cs{fca@cxt@att} and
% make it available as \cs{att} in the \env{cxt} environment, only.}
%    \begin{macrocode}
\newcommand{\fca@cxt@att}[1]{%
  \ifthenelse{\boolean{fca@cxt@ttributes}}{%
    \settoheight{\fca@cxt@ttnameheight}{#1}\adjcxt@name%
    \expandafter\def\expandafter\fca@cxt@tabtop\expandafter{%
      \fca@cxt@tabtop&#1}%
    \stepcounter{fca@cxt@mAnz}%
  }{%
    \PackageWarning{fca}{Attribute following object in
      cxt-environment%
      has been ignored}{}}%
  \ignorespaces }%
%    \end{macrocode}

% \end{macro}
% \end{macro}
% \begin{macro}{\fca@cxt@atr}\marg{name}
% Implementation for \cs{atr}. The corresponding alias is set up
% during \cs{begin}\marg{\env{cxt}}.
% \begin{macro}{\atr}\marg{name}
%   The macro \cs{atr} is available only in the \env{cxt} environment.
%   it calls \cs{att} with its name rotated by 90 degrees, so that the
%   name is typeset vertically.
% \changes{2.2}{2022/03/08}{rename \cs{atr} to \cs{fca@cxt@atr} and
% make it available as \cs{atr} in the \env{cxt} environment, only.}
%    \begin{macrocode}
\newcommand{\fca@cxt@atr}[1]{\att{\rotatebox{90}{#1~~}}}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fca@cxt@obj}\marg{crosses}\marg{objectname}
%   Implementation for \cs{obj}. The corresponding alias is set up
%   during \cs{begin}\marg{\env{cxt}}.
% \begin{macro}{\obj}\marg{crosses}\marg{objectname}
%   This macro typesets an object line of a formal context inside the
%   \env{cxt} environment. The second argument \marg{objectname} is
%   the name of the objects. The first argument \marg{crosses} is a
%   line of tokens. Each token represents the contents of one cell in
%   the context table. Typically tokens contain spaces, arrows,
%   crosses. But they can be defined to represent other material as
%   well. Even multi character tokens are possible. However these are
%   not documented.%
%   \changes{2.2}{2022/03/08}{rename \cs{obj} to \cs{fca@cxt@obj} and
%   make it available as \cs{obj} in the \env{cxt} environment,
%   only.}%
%   \changes{2.2}{2022/03/11}{avoid usage of \cs{setboolean} in
%   \cs{fca@cxt@obj}}%
%    \begin{macrocode}
\newcommand{\fca@cxt@obj}[2]{%
  \fca@cxt@tabdef
  #2\strut
  \fca@cxt@Line{#1}%
  \\
}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fca@cxt@freeobj}\marg{columns}\marg{name}
%   Implementation for \cs{freeobj}. The corresponding alias is set up
%   during \cs{begin}\marg{\env{cxt}}.
% \begin{macro}{\freeobj}\marg{columns}\marg{name}
%   This macro allows to typeset any material in the incidence area of the
%   context. The second argument is typeset in the name column of the
%   context, while the first one occures inside the incidence area of the
%   context. The different fields in the first argument must be
%   separated as usual by |&|.
% \changes{2.2}{2022/03/08}{rename \cs{freeobj} to \cs{fca@cxt@freeobj} and
% make it available as \cs{freeobj} in the \env{cxt} environment, only.}
%
%    \begin{macrocode}
\newcommand{\fca@cxt@freeobj}[2]{%acrocod}
  \fca@cxt@tabdef%
  #2&#1\\\hline }%
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\fca@cxt@tabtop}
%   Material that is typeset above a context line.
%
%   At the beginning this macro contains the table header. Later it is
%   used to typeset the lines between the objects.
%
%   The Table heading for the attributes will be filled by |\att| and
%   |\atr| during the attribute section of the formal context. The
%   first |\obj| will use it.
%   \changes{2.2}{2022/03/11}{use \cs{fca@cxt@tabtop} also for storing
%   the \cs{hline} between the objects.}
%    \begin{macrocode}
\def\fca@cxt@tabtop{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fca@cxt@tabdef}
% \begin{macro}{\fca@cxt@tabdef@@}
%   Expand \cs{fca@cxt@align} as argument to \cs{fca@cxt@tabdef@}.
%
%   At the begin of a \env{cxt} environment \cs{fca@cxt@tabdef} set to
%   be an alias of \cs{fca@cxt@tabdef@@}. As soon as
%   \cs{fca@cxt@tabdef} is executed, this macro is set to \cs{relax}.
%
%   It is executed at the end of the cxt environment so that we can
%   typeset contexts without any objects.
%
%   \changes{2.2}{2022/03/11}{move generation of 1st line into \cs{fca@cxt@tabdef@@}}
%    \begin{macrocode}
\def\fca@cxt@tabdef@@{%
  \expandafter\fca@cxt@tabdef@\fca@cxt@align
  \fca@cxtn@me%&%
  \fca@cxt@tabtop\strut\\\hline\hline
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fca@cxt@tabdef@}\marg{alignment}
%   Do the work of \cs{fca@cxt@tabdef}: Open the tabular
%   environment. The parameter \marg{alignment} will be used to set
%   the vertiacal alignment of the context. See the documentation of
%   the |tabular| environment for further documentation.
%
%   Note: We must do all definitions outside of the tabular
%   environment.
%    \begin{macrocode}
\def\fca@cxt@tabdef@#1{%
  \def\fca@cxt@tabdef{\hline}%
  \tabcolsep0.5ex\relax%
  \begin{tabular}[#1]{|l||*{\value{fca@cxt@mAnz}}{c|}}%
    \hline%
    }%
%    \end{macrocode}
% \end{macro}
% \begin{environment}{cxt}\oarg{alignment}
%
%   The \env{cxt} environment. During setup a set of macros are
%   defined, and a new group is opened. The alignment argument is
%   saved. During the the first call to \cs{obj} a tabular environment
%   will be opened by calling \cs{fca@cxt@tabdef}.
%    At the end of the environment the tabular environment
%    is closed.
%
%   Here we test empty contexts. They should work, but don't need to
%   be documented:
% \begin{dtxexample}{A formal context without objects.}
%   \begin{cxt}
%     \cxtName{Formula 1}
%   %
%     \att{1.}
%     \att{2.}
%     \atr{disqualified}
%   %
%   \end{cxt}
% \end{dtxexample}
% \begin{dtxexample}{A formal context without attributes.}
%   \begin{cxt}
%     \cxtName{Formula 1}
%   %
%     \obj{}{Verstappen}
%     \obj{}{Hamilton}
%     \obj{}{Leclerc}
%   \end{cxt}
% \end{dtxexample}
%
% \begin{dtxexample}{An empty named context.}
%   \begin{cxt}
%     \cxtName{Formula 0}
%   \end{cxt}
% \end{dtxexample}
%
% \begin{dtxexample}{An empty \env{cxt} environment.}
%   \begin{cxt}
%   \end{cxt}
% \end{dtxexample}
%
%
%    \begin{macrocode}
    \newenvironment{cxt}[1][t]{%
    \begingroup
    \fca@cxt@resetDefaults
    \def\fca@cxt@align{#1}%
    \ignorespaces
    }{%
    \fca@cxt@tabdef% open the tabular in case there are no objects
  \end{tabular}%
  \endgroup }%
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\fca@cxt@resetDefaults}
%   Initialize macros an registered that are used in a formal context.
%   This macro is called at \cs{begin}\env{\{cxt\}}.
%    \begin{macrocode}
\newcommand{\fca@cxt@resetDefaults}{%
  \setlength{\fca@cxt@nameraise}{0pt}%
  \setlength{\fca@cxt@ttnameheight}{0pt}%
  \setcounter{fca@cxt@mAnz}{0}%
  \setboolean{fca@cxt@ttributes}{true}%
  \let\cxtName\fcaCxtName
  \let\alignBottom\fcaCxtAlignBottom
  \let\alignCenter\fcaCxtAlignCenter
  \let\alignTop   \fcaCxtAlignTop
  \let\att\fca@cxt@att
  \let\atr\fca@cxt@atr
  \let\obj\fca@cxt@obj
  \let\freeobj\fca@cxt@freeobj
  \let\cxtphantom\fca@cxt@phantom
  \let\cxtrlap\fca@cxt@rlap
  \let\fca@cxtn@me\@empty%
  \let\fca@cxt@tabdef\fca@cxt@tabdef@@
}%
%    \end{macrocode}
% \end{macro}
%
% \subsection{Cross table contents}
% \subsubsection{Defining the characters in a context.}
%
% Formal contexts usually contain crosses and – when we are looking
% for irreducible elements – arrows. Many-valued contexts can contain
% arbitrary content. This section describes the macros that used to
% typeset a single cell. This incluedes the symbols that can be used
% in a context line as well as the macros that allow to define them.
%
% It is necessary that very symbol in the context lines must be
% defined with the macros from this sections. Only this ensures that
% the parser gets restarted whenever a character is executed.
%
% \begin{macro}{\fca@cxt@phantom}
% \begin{macro}{\cxtphantom}
% This macro creates the horizontal space that would have been taken
% by a cross in the context. It is used to properly position other
% signs in the table without modifying the spacing.
%    \begin{macrocode}
\def\fca@cxt@phantom{\phantom{\fca@cxt@Kreuz}}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fca@cxt@rlap}\marg{content}
% \begin{macro}{\cxtrlap}\marg{content}
%   The argument \meta{content} will be typeset centered in a cell
%   that has the same size as an ordinary cross.
% \cs{cxtrlap} is only available in the \env{cxt} environment.
%    \begin{macrocode}
\def\fca@cxt@rlap#1{%
  \settowidth\@tempdima{\cxtphantom}%
  \makebox[\@tempdima][c]{\hss #1\hss}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \changes{2.2}{2022/03/21}{add \cs{fcaNewContextChar},\cs{fcaProvideContextChar} and \cs{fcaRenewContextChar} that define new letters for the context}
%
% \begin{macro}{\fca@cxt@M@kechar@newcommand}
% Put a starred \cs{newcommand*} into one single token. We will use it when we define a single character.
%    \begin{macrocode}
\def\fca@cxt@M@kechar@newcommand{%
  \newcommand*%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@cxt@Makechar@newcommand}\oarg{letter}
%   Defines a macro for the \meta{letter} to be used as a single token in the \env{cxt} environment. It is equivalent to
% \cs{newcommand*\{letter\}} and can take all additional arguments that \cs{newcommand} takes.
%
% Note: the macro is not restricted to letters. It can also use command names (that are converted to strings)
%    \begin{macrocode}
\def\fca@cxt@Makechar@newcommand#1{%
  \expandafter \fca@cxt@M@kechar@newcommand \csname cxt@char@\string#1 \endcsname
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fcaNewContextChar}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaNewContextChar@}\marg{character}\marg{definition}
% \begin{macro}{\fcaNewContextChar@@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaNewContextCh@r}\marg{character}\oarg{arguments}\marg{definition}
% \begin{macro}{\fcaNewContextCh@r@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
%   The macro \cs{fcaNewContextChar} can be used to define a new
%   character for usage in the \env{cxt} environment in the \cs{obj}
%   macro.
%   Internally it calls \cs{newcommand*} with the given arguments.
%
%   The remaining macros \cs{fcaNewContextChar@},
%   \cs{fcaNewContextChar@@}, \cs{fcaNewContextCh@r} and
%   \cs{fcaNewContextCh@r@} are used to pass the right arguments to
%   \cs{newcommand*}.
%    \begin{macrocode}
\def\fcaNewContextCh@r@#1[#2][#3]#4{%
  \fca@cxt@Makechar@newcommand{#1}[{#2}][{#3}]{#4\fca@cxt@read@line}%
}%
\def\fcaNewContextCh@r#1[#2]#3{%
  \fca@cxt@Makechar@newcommand{#1}[{#2}]{#3\fca@cxt@read@line}%
}%
\def\fcaNewContextChar@@#1[#2]{%
  \@ifnextchar[{\fcaNewContextCh@r@{#1}[{#2}]}{\fcaNewContextCh@r{#1}[{#2}]}%
}%
\def\fcaNewContextChar@#1#2{%
  \fca@cxt@Makechar@newcommand{#1}{#2\fca@cxt@read@line}%
}%
\def\fcaNewContextChar#1{%
  \@ifundefined{cxt@char@\string#1 }{}{%
    \PackageError{fca}{The character `\string#1' is already defined.}%
    \expandafter\let
    \csname cxt@char@\string#1 \endcsname\@undefined
  }%
  \@ifnextchar[{\fcaNewContextChar@@{#1}}{\fcaNewContextChar@{#1}}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\fca@cxt@M@kechar@providecommand}
% Put a starred \cs{providecommand*} into one single token. We will use it when we define a single character.
%    \begin{macrocode}
\def\fca@cxt@M@kechar@providecommand{%
  \providecommand*%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@cxt@Makechar@providecommand}\oarg{letter}
%   Defines a macro for the \meta{letter} to be used as a single token in the \env{cxt} environment. It is equivalent to
% \cs{providecommand*{letter}} and can take all additional arguments that \cs{providecommand} takes.
%
% Note: the macro is not restricted to letters. It can also use command names (that are converted to strings)
%    \begin{macrocode}
\def\fca@cxt@Makechar@providecommand#1{%
  \expandafter \fca@cxt@M@kechar@providecommand \csname cxt@char@\string#1 \endcsname
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fcaProvideContextChar}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaProvideContextChar@}\marg{character}\marg{definition}
% \begin{macro}{\fcaProvideContextChar@@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaProvideContextCh@r}\marg{character}\oarg{arguments}\marg{definition}
% \begin{macro}{\fcaProvideContextCh@r@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
%   The macro \cs{fcaProvideContextChar} can be used to define a provide
%   character for usage in the \env{cxt} environment in the \cs{obj}
%   macro.
%   Internally it calls \cs{providecommand*} with the given arguments.
%
%   The remaining macros \cs{fcaProvideContextChar@},
%   \cs{fcaProvideContextChar@@}, \cs{fcaProvideContextCh@r} and
%   \cs{fcaProvideContextCh@r@} are used to pass the right arguments to
%   \cs{providecommand*}.
%    \begin{macrocode}
\def\fcaProvideContextCh@r@#1[#2][#3]#4{%
  \fca@cxt@Makechar@providecommand{#1}[{#2}][{#3}]{#4\fca@cxt@read@line}%
}%
\def\fcaProvideContextCh@r#1[#2]#3{%
  \fca@cxt@Makechar@providecommand{#1}[{#2}]{#3\fca@cxt@read@line}%
}%
\def\fcaProvideContextChar@@#1[#2]{%
  \@ifnextchar[{\fcaProvideContextCh@r@{#1}[{#2}]}{\fcaProvideContextCh@r{#1}[{#2}]}%
}%
\def\fcaProvideContextChar@#1#2{%
  \fca@cxt@Makechar@providecommand{#1}{#2\fca@cxt@read@line}%
}%
\def\fcaProvideContextChar#1{%
  \@ifnextchar[{\fcaProvideContextChar@@{#1}}{\fcaProvideContextChar@{#1}}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\fca@cxt@M@kechar@renewcommand}
% Put a starred \cs{renewcommand*} into one single token. We will use it when we define a single character.
%    \begin{macrocode}
\def\fca@cxt@M@kechar@renewcommand{%
  \renewcommand*%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@cxt@Makechar@renewcommand}\oarg{letter}
%   Defines a macro for the \meta{letter} to be used as a single token in the \env{cxt} environment. It is equivalent to
% \cs{renewcommand*{letter}} and can take all additional arguments that \cs{renewcommand} takes.
%
% Note: the macro is not restricted to letters. It can also use command names (that are converted to strings)
%    \begin{macrocode}
\def\fca@cxt@Makechar@renewcommand#1{%
  \expandafter \fca@cxt@M@kechar@renewcommand \csname cxt@char@\string#1 \endcsname
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fcaRenewContextChar}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaRenewContextChar@}\marg{character}\marg{definition}
% \begin{macro}{\fcaRenewContextChar@@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
% \begin{macro}{\fcaRenewContextCh@r}\marg{character}\oarg{arguments}\marg{definition}
% \begin{macro}{\fcaRenewContextCh@r@}\marg{character}\oarg{arguments}\oarg{default}\marg{definition}
%   The macro \cs{fcaRenewContextChar} can be used to define a renew
%   character for usage in the \env{cxt} environment in the \cs{obj}
%   macro.
%   Internally it calls \cs{renewcommand*} with the given arguments.
%
%   The remaining macros \cs{fcaRenewContextChar@},
%   \cs{fcaRenewContextChar@@}, \cs{fcaRenewContextCh@r} and
%   \cs{fcaRenewContextCh@r@} are used to pass the right arguments to
%   \cs{renewcommand*}.
%    \begin{macrocode}
\def\fcaRenewContextCh@r@#1[#2][#3]#4{%
  \fca@cxt@Makechar@renewcommand{#1}[{#2}][{#3}]{#4\fca@cxt@read@line}%
}%
\def\fcaRenewContextCh@r#1[#2]#3{%
  \fca@cxt@Makechar@renewcommand{#1}[{#2}]{#3\fca@cxt@read@line}%
}%
\def\fcaRenewContextChar@@#1[#2]{%
  \@ifnextchar[{\fcaRenewContextCh@r@{#1}[{#2}]}{\fcaRenewContextCh@r{#1}[{#2}]}%
}%
\def\fcaRenewContextChar@#1#2{%
  \fca@cxt@Makechar@renewcommand{#1}{#2\fca@cxt@read@line}%
}%
\def\fcaRenewContextChar#1{%
  \@ifundefined{cxt@char@\string#1 }{%
    \PackageError{fca}{The character `\string#1' is undefined.^^J
      It must have been defined in order to be redefined.}%
    \fcaNewContextChar{#1}{}%
  }{}%
  \@ifnextchar[{\fcaRenewContextChar@@{#1}}{\fcaRenewContextChar@{#1}}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Reading context lines}
% \begin{macro}{\fca@cxt@stop}
%   This macro does nothing. It is used for checking emptiness when a
%   context line is parsed.
%    \begin{macrocode}
\def\fca@cxt@stop{}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fca@cxt@executechar}\marg{character}
%   This macro executes the command sequence associated to the meaning of a character in a context line.
%   In order to process a whole context line the macro is appended to each context character definition.
%   This gives the code the meaning of an unfolded \cs{@for} loop.
%
%   If the token is \cs{fca@cxt@stop}, the loop ends.
%    \begin{macrocode}
\def\fca@cxt@executechar#1{%
  &\@ifundefined{cxt@char@\string#1 }{%
    \PackageWarning{fca}{Undefinded character \string#1 \space in the context}%
    \let\fca@cxt@tmp=\fca@cxt@aPunkt%
  }{%
    \expandafter\let\expandafter\fca@cxt@tmp \csname
    cxt@char@\string#1 \endcsname }%
  \fca@cxt@tmp }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@cxt@read@line}\marg{character}
%   Start processing a context line. We look only at the first
%   character. If it is \cs{fca@cxt@stop}, then the line is empty and
%   nothing is to do.  Otherwise we execute the character macro. The
%   definition of the character ensures that this starts a loop until
%   eventually \cs{fca@cxt@stop} is reached.
% \begin{macrocode}
\def\fca@cxt@read@line#1{%
  \ifx#1\fca@cxt@stop \let\fca@cxt@zeile@excecutechar\@gobble \else
  \let\fca@cxt@zeile@excecutechar\fca@cxt@executechar \fi
  \fca@cxt@zeile@excecutechar{#1}%
}%
% \end{macro}
%
% \begin{macro}{\fca@cxt@Line}\marg{\line}
%   Process a whole crosstable line. We add \cs{fca@cxt@stop} at the end and start the loop by calling \cs{fca@cxt@read@line}.
% \begin{macrocode}
\def\fca@cxt@Line#1{%
  \fca@cxt@read@line#1\fca@cxt@stop }%
%    \end{macrocode}
% \end{macro}
%
% \changes{2.2}{2022/03/14}{Remove \cs{cxt@aKreuz}, \cs{cxt@aup},
% \cs{cxt@adown} and \cs{cxt@aboth}. These macros are replaced by
% calls to \cs{cxtMakeChar}.}
%
% \subsubsection{The context characters}
% Finally, we can define the predefined characters that can be used inside a formal context:
% \begin{description}
% \ItemDescribeOther[context character]{.} An empty context cell.
% \ItemDescribeOther[context character]{x} A cross in the context.
% \ItemDescribeOther[context character]{X} Alternative sign for a cross.
% \ItemDescribeOther[context character]{u} An up-arrow in the context.
% \ItemDescribeOther[context character]{d} A down-arrow in the context.
% \ItemDescribeOther[context character]{b} A cell containing both an
% up- and a down-arrow.
% \ItemDescribeOther[context character]{0} A zero in a many-valued context.
% \ItemDescribeOther[context character]{1} A one in a many-valued context.
% \ItemDescribeOther[context character]{2} Two in a many-valued context.
% \ItemDescribeOther[context character]{3} Three in a many-valued context.
% \ItemDescribeOther[context character]{4} Four in a many-valued context.
% \ItemDescribeOther[context character]{5} Five in a many-valued context.
% \ItemDescribeOther[context character]{6} Six in a many-valued context.
% \ItemDescribeOther[context character]{7} Seven in a many-valued context.
% \ItemDescribeOther[context character]{8} Eight in a many-valued context.
% \ItemDescribeOther[context character]{9} Nine in a many-valued context.
% \end{description}
%
%    \begin{macrocode}
\fcaNewContextChar .{\cxtphantom}
\fcaNewContextChar x{\fca@cxt@Kreuz}
\fcaNewContextChar X{\fca@cxt@Kreuz}
\fcaNewContextChar u{\cxtrlap{\fca@cxt@up}}
\fcaNewContextChar d{\cxtrlap{\fca@cxt@down}}
\fcaNewContextChar b{\cxtrlap{\fca@cxt@both}}
\@for\tmp:= 0,1,2,3,4,5,6,7,8,9\do{
  \edef\@tmp{
    \noexpand\fcaNewContextChar\tmp{%
      \noexpand\cxtrlap\tmp
    }%
  }%
  \@tmp
}
%    \end{macrocode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% end of cxt environment definition                                           %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \iffalse
%    \begin{macrocode}
%</fca.sty>
%    \end{macrocode}
% \fi
% \iffalse
%    \begin{macrocode}
%<*cxtinput.sty>
%    \end{macrocode}
% \fi
% \subsection{Reading Burmeister context files}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% This is the part `cxtinput.sty' : LaTeX macros for Formal Concept Analysis      %
%     input of Burmeister format contexts                                     %
%                                                                             %
%      Copyright  Tobias Schlemmer 5/09                                       %
%      Version of                  1/12                                       %
%                                                                             %
%  This program is provided under the terms of the                            %
%  LaTeX Project Public License distributed from CTAN                         %
%  archives in directory macros/latex/base/lppl.txt.                          %
%                                                                             %
%  This package defines the macro |\cxtinput|, which can input a context        %
%  file in Burmeister format                                                  %
%                                                                             %
%  Usage:                                                                      %
% \begin{verbatim}
% \begin{cxt}                                                                 %
% \cxtAlignBottom                                                             %
% \end{cxt}                                                                   %
% \end{verbatim}
%                                                                             %
% Known bugs:                                                                 %
% • The end of the .cxt file is not correctly detected.                       %
%   You will get the error message: Runaway argument?                         %
%    ! File ended while scanning use of |\fca@cxt@input@getline|.                   %
%                                                                             %
% TODO:                                                                       %
% • Make everything configurable                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% used counters
%
%    \begin{macrocode}
\newcount\fca@cxt@input@obj
\newcount\fca@cxt@input@attr
\newcount\fca@cxt@input@line
\newtoks\fca@cxt@input@contextlines
\fca@cxt@input@line0
\fca@cxt@input@contextlines{}%
%    \end{macrocode}
%
% The end user macro
%
%    \begin{macrocode}%
\newcommand\cxtinput[1]{%
%  \begingroup
  \fca@cxt@input@contextlines{}%
  \fca@cxt@input@save@nl@active%
  \fca@cxt@input@make@nl@active%
  \fca@cxt@input@input{#1}%
  \fca@cxt@input@restore@nl%
  \xdef\fca@cxt@input@tempa{\the\fca@cxt@input@contextlines}%
  %\aftergroup
  \fca@cxt@input@tempa%
%  \endgroup%
}
%    \end{macrocode}
%
% Macro holding the command for the next line
%
%    \begin{macrocode}
\def\fca@cxt@input@newline{}
%    \end{macrocode}
%
%    \begin{macrocode}
\def\fca@cxt@input@head{%
 \fca@cxt@input@getline\fca@cxt@input@check@B
}
%    \end{macrocode}
%
% Check the “B” at the beginning of the file
%
%    \begin{macrocode}
\def\fca@cxt@input@check@B#1{%
  \def\tempa{B}\def\tempb{#1}%
  \ifx\tempa\tempb
  \typeout{Burmeister format detected}%
  \else
    \fca@cxt@input@error{No Burmeister format detected}{The \string\cxtinput macro can input Burmeister .cxt files only.}%
  \fi
  \def\fca@cxt@input@newline{%
    \fca@cxt@input@getline{\fca@cxt@input@read@cxtname}%
  }%
}
%    \end{macrocode}
%
% Check for an empty line and continue with command \#2 afterwards
%
%    \begin{macrocode}
\def\fca@cxt@input@match@mptyline#1#2{%
  \edef\tempa{#2}%
  \ifx\tempa\@empty
  \else
    \fca@cxt@input@error{Error in Burmeister format.}{At the current position an empty line is expected.}%
  \fi
  \def\fca@cxt@input@newline{%
    \fca@cxt@input@getline{#1}%
  }%
}
%    \end{macrocode}
%
%  Read the context name
%
%    \begin{macrocode}
\def\fca@cxt@input@read@cxtname#1{%
  \ifx\fca@cxtn@me\@empty
    \fcaCxtName{#1}%
  \fi
  \def\fca@cxt@input@newline{%
    \fca@cxt@input@getline{\fca@cxt@input@readobjcount}%
  }%
}
%    \end{macrocode}
%
% Read number of objects from the file
%
%    \begin{macrocode}
\def\fca@cxt@input@readobjcount#1{%
 \fca@cxt@input@obj=#1\relax
 \def\fca@cxt@input@newline{%
   \fca@cxt@input@getline\fca@cxt@input@readattrcount%
 }%
}
%    \end{macrocode}
%
% Read number of attributes
%
%    \begin{macrocode}
\def\fca@cxt@input@readattrcount#1{%
  \def\fca@cxt@input@newline{%
    \fca@cxt@input@getline{\fca@cxt@input@match@mptyline\fca@cxt@input@readobjects}%
  }%
  \fca@cxt@input@attr=#1\relax
}
%    \end{macrocode}
%
% initializes the reading of the object names
%
%    \begin{macrocode}
\def\fca@cxt@input@readobjects{%
  \ifnum\fca@cxt@input@obj>0\relax
    \def\fca@cxt@input@newline{%
      \fca@cxt@input@getline\fca@cxt@input@readobjname
   }%
   \@tempcnta=1\relax
   \let\tempa\fca@cxt@input@readobjname%
 \else
    \let\tempa\fca@cxt@input@readattributes%
  \fi
 \tempa
}
%    \end{macrocode}
%
% Read the object names
%
%    \begin{macrocode}
\def\fca@cxt@input@readobjname#1{%
   \expandafter\def\csname cxt@input@objname@\the\@tempcnta\endcsname{#1}%
   \ifnum\@tempcnta < \fca@cxt@input@obj
    \advance\@tempcnta by 1\relax
 \else
    \def\fca@cxt@input@newline{%
      \fca@cxt@input@getline\fca@cxt@input@readattributes%
    }%
  \fi
}
%    \end{macrocode}
%
% Initialize reading of attibute names
%
%    \begin{macrocode}
\def\fca@cxt@input@readattributes{%
  \ifnum\fca@cxt@input@attr>0\relax
    \def\fca@cxt@input@newline{%
      \fca@cxt@input@getline\fca@cxt@input@readattrname
    }%
    \@tempcnta=1\relax
    \def\tempa{\fca@cxt@input@readattrname}%
  \else
    \def\tempa{\fca@cxt@input@readcontext}%
  \fi
  \tempa
}
%    \end{macrocode}
% Read the attribute names and store |\atr| macros for each attribute
%    \begin{macrocode}
\def\fca@cxt@input@readattrname#1{%
  \fca@cxt@input@appendtotok{#1}\atr%
  \ifnum\@tempcnta < \fca@cxt@input@attr
    \advance\@tempcnta by 1\relax
  \else
    \def\fca@cxt@input@newline{%
      \fca@cxt@input@getline\fca@cxt@input@readcontext
    }%
  \fi
}
%    \end{macrocode}
%
% initalize reading of the cross table
%
%    \begin{macrocode}
\def\fca@cxt@input@readcontext{%
  \ifnum\fca@cxt@input@obj>0\relax
    \def\fca@cxt@input@newline{%
      \fca@cxt@input@getline
      \fca@cxt@input@readcontextline
    }%
    \@tempcnta=1\relax
    \def\tempa{\fca@cxt@input@readcontextline}%
  \else
    \def\tempa{}%
  \fi
  \tempa
}
%    \end{macrocode}
%
% Read cross table and store |\obj| macros for each object
%
%    \begin{macrocode}
\def\fca@cxt@input@readcontextline#1{%
  \expandafter\expandafter\expandafter\fca@cxt@input@appendtotok
  \expandafter\expandafter\expandafter{%
    \csname cxt@input@objname@\the\@tempcnta\endcsname}%
  {\obj{#1}}%
  \ifnum\@tempcnta < \fca@cxt@input@obj
    \advance\@tempcnta by 1\relax
  \else
    \let\fca@cxt@input@newline\relax
    \let\fca@cxt@input@endoffile\relax
  \fi
}
%    \end{macrocode}
%
% add some stuff to the token register
% needed to have some tool, which can be used with |\expandierter|
%
%    \begin{macrocode}
\def\fca@cxt@input@appendtotok#1#2{%
  \expandafter\fca@cxt@input@contextlines\expandafter{%
    \the\fca@cxt@input@contextlines
    #2{#1}%
  }%
}

\def\fca@cxt@input@error#1#2{%
  \PackageError{fca}{At line \the\fca@cxt@input@line : #1}{#2}%
  \def\fca@cxt@input@newline{}%
}%
%    \end{macrocode}
%
% Some end of file mark
%
%    \begin{macrocode}
\def\fca@cxt@input@endoffile{%
  \fca@cxt@input@error{unexpected end of file}{The context file is somehow
    inconsistent.\MessageBreak The last lines of it seem to be lost.}%
}
%    \end{macrocode}
%
% macro for usage with |\ifx|
%
%    \begin{macrocode}
\def\fca@cxt@input@@endoffile{\fca@cxt@input@endoffile}
%    \end{macrocode}
%
% swich catcode of newline to runtime mode
%
%    \begin{macrocode}
\begingroup%
\catcode`\^^M\active%
%    \end{macrocode}
%
% Define a macro to save the catcode.
% Define a macro to set the catcode.
%
%    \begin{macrocode}
\gdef\fca@cxt@input@make@nl@active{%
  \catcode`\^^M\active%
% \let\fca@cxt@input@oldcr^^M%
% \def^^M{\fca@cxt@input@newline}%
}%

\gdef\fca@cxt@input@save@nl@active{%
  \chardef\fca@cxt@input@catcode@nl=\catcode`\^^M%
% \let\fca@cxt@input@oldcr^^M%
% \def^^M{\fca@cxt@input@newline}%
}%
%    \end{macrocode}
%
% Define a macro to set the catcode.
%
%    \begin{macrocode}
\gdef\fca@cxt@input@restore@nl{%
  \catcode`\^^M\fca@cxt@input@catcode@nl\relax%
% \let\fca@cxt@input@oldcr^^M%
% \def^^M{\fca@cxt@input@newline}%
}%

\fca@cxt@input@make@nl@active%
%    \end{macrocode}
%
% reads a line from the context file.
%
%    \begin{macrocode}
\long\gdef\fca@cxt@input@getline #1#2^^M{%
  \advance\fca@cxt@input@line by 1\relax%
  \def\tempa{#2}%
  \ifx\tempa\fca@cxt@input@@endoffile%
    \tempa%
  \fi%
  #1{#2}%
  \fca@cxt@input@newline%
}%
%    \end{macrocode}
%
% read the inputfile and use its content as argument for
% |\fca@cxt@input@head|
%
%    \begin{macrocode}
\gdef\fca@cxt@input@input#1{%
  \expandafter\fca@cxt@input@head\@@input #1 %
  \fca@cxt@input@endoffile%
}
%    \end{macrocode}
%
% restore newline catcode
%
%    \begin{macrocode}
\endgroup%
%    \end{macrocode}
% \iffalse
%    \begin{macrocode}
%</cxtinput.sty>
%    \end{macrocode}
% \fi
% \iffalse
%    \begin{macrocode}
%<*fca.sty>
%    \end{macrocode}
% \fi
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \section{Environment \env{diagram} for making
%            diagrams of ordered sets, graphs and concept lattices}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% To obtain a diagram for the concept lattice of the formal
% context above, try this:
%
%
% \begin{dtxexample}{A lattice diagram}
% {\unitlength 1.2mm
% \begin{diagram}{40}{55}
%   \Node{1}{20}{10}
%   \Node{2}{35}{20}
%   \Node{3}{5}{30}
%   \Node{4}{35}{40}
%   \Node{5}{20}{50}
%   \Edge{1}{2}
%   \Edge{1}{3}
%   \Edge{2}{4}
%   \Edge{3}{5}
%   \Edge{4}{5}
%   \leftAttbox{3}{2}{2}{1.}
%   \rightAttbox{2}{2}{2}{disqualified}
%   \rightAttbox{4}{2}{2}{2.}
%   \leftObjbox{3}{2}{2}{Hamilton}
%   \rightObjbox{2}{2}{2}{Montoya}
%   \rightObjbox{4}{2}{2}{Schumacher}
% \end{diagram}}
% \end{dtxexample}
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% The syntax of the commands is                                               %
%                                                                             %
% \begin{verbatim}
% \begin{diagram}{width}{height}                                              %
%                                                                             %
%   \Node{number}{xcoordinate}{ycoordinate} % (nodenumbers from 0 to 50)      %
%                                                                             %
%   \Edge{nodenumber1}{nodenumber2}                                           %
%                                                                             %
%   \leftAttbox{nodenumber}{xoffset}{yoffset}{text1 \\ text2 \\ ... }         %
%                                                                             %
%   similarly: \rightAttbox, \centerAttbox,                                   %
%   \leftObjbox,  \centerObjbox,                                              %
%   \rightObjbox.                                                             %
%                                                                             %
% \end{diagram}
% \end{verbatim}
%                                                                             %
% The circle size can be changed with the |\fcaCircleSize| command.                %
% The value must be a positive integer, which will be mutiplied               %
% by |\unitlength|. The default is                                              %
%                                                                             %
% |\fcaCircleSize{4}|.                                                             %
%                                                                             %
% A helpful command when fine tuning a diagram is                             %
%                                                                             %
% |\Numbers|.                                                                   %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% You may wish to permanently adjust the following values to your             %
% personal preferences. They can also be changed inside each diagram          %
% environment using |\renewcommand|.                                            %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    \begin{macrocode}
\newcommand{\fca@Defaults}{% Do not change this line!  %
  \newcommand{\fcaObjectLabelStyle}{%
    \small\baselineskip1em\rmfamily\upshape%
  }% %
  \newcommand{\fcaAttributeLabelStyle}{%
    \small\baselineskip1em\rmfamily\itshape
  }% %
  \newcommand{\fcaLabelBoxWidth}{40mm}%
  \let\Node\fca@node
  \let\Edge\fca@edge
  \iffca@compat@macros
  \else
    \def\ObjectLabelStyle{\fcaObjectLabelStyle}%
    \def\AttributeLabelStyle{\fcaAttributeLabelStyle}%
    \let\LabelBoxWidth\fcaLabelBoxWidth
    \let\EdgeThickness\fcaEdgeThickness
    \let\NodeThickness\fcaNodeThickness
    \let\Numbers\fcaNumbers
    \let\noNumbers\fcaNoNumbers
    \let\NodeColor\fcaNodeColor
    \let\ColorNode\fcaColorNode
    \let\NoDots\fcaNoDots
    \let\Dots\fcaDots
  \fi
  \let\leftAttbox\fca@leftAttbox
  \let\centerAttbox\fca@centerAttbox
  \let\rightAttbox\fca@rightAttbox
  \let\leftObjbox\fca@leftObjbox
  \let\centerObjbox\fca@centerObjbox
  \let\rightObjbox\fca@rightObjbox
}% %
\newboolean{fca@connectors}\setboolean{fca@connectors}{true}% %
\iffca@compat@macros
  \newcommand{\diagramXoffset}{0}% %
  \newcommand{\diagramYoffset}{0}% %
  \newcommand{\fcaDiagramXoffset}{\diagramXoffset}% %
  \newcommand{\fcaDiagramYoffset}{\diagramYoffset}% %
\else
  \newcommand{\fcaDiagramXoffset}{0}% %
  \newcommand{\fcaDiagramYoffset}{0}% %
\fi
\newcommand*{\fca@xunitlength}{\unitlength}%
\newcommand*{\fca@yunitlength}{\unitlength}%
\newcommand*{\fca@edge@thickness}{.8pt}% %
\newcommand*{\fca@node@thickness}{1pt}% %
\newcommand*{\fca@transform}{}%
\newcommand*{\fca@options}{}%
\newcommand*{\fca@defaultoptions}{}%
\newcommand*{\fca@usepath}{}%
\newcommand*{\fca@node@number@prefix}{\pgfkeysvalueof{/fca/namespace}\space node\space}%
\newcommand*{\fca@node@number@suffix}{\space number}%
\newcommand*{\fca@label@edge@width}{\@wholewidth}%
\newcommand*{\fca@label@at}{center}% anchor of node
\newcommand*{\fca@label@shift@x}{0pt}%
\newcommand*{\fca@label@shift@y}{0pt}%
\newcommand*{\fca@label@shift@x@sign}{}
\newcommand*{\fca@label@shift@y@sign}{}
\newcommand*{\fca@label@type}{attributes}%
\newcommand*{\fca@label@position}{right}%

\newcommand*\fca@none{none}
\newcommand*\fca@firstofthree[3]{#1}
\newcommand*\fca@secondofthree[3]{#2}
\newcommand*\fca@thirdofthree[3]{#3}
\newcommand*\fca@testoption[1]{%
  \def\fca@tempa{#1}%
  \ifx\empty\fca@tempa
    \let\fca@tempb\fca@thirdofthree
  \else
    \def\fca@tempb{\pgfkeysnovalue}%
    \ifx\fca@tempa\fca@tempb
      \let\fca@tempb\fca@thirdofthree
    \else
      \ifx\fca@tempa\fca@none
        \let\fca@tempb\fca@secondofthree
      \else
        \let\fca@tempb\fca@firstofthree
      \fi
    \fi
  \fi
  \fca@tempb
}
%    \end{macrocode}
%
% Sometimes (e.g. for large contexts) it is not possible to arrange
% all nodes in such a way that the edges do not cross any nodes. In
% such case its often worse not to print any lattice than to live with
% some compromises. I such situations we must divide the lattice into
% several layers. Fortunately, \PGF{} and \TikZ{} support to assign
% certain graphical objects into layers. This allows us, to keep the
% order of defining nodes before the edges, while the nodes are drawn
% on top of the edges (see below).
%
% Please, do not confuse implementation layers (\TikZ, \PGF{} Basic
% Layer and drivers) with graphical layers. Graphical layers can be
% thought of slide overlays stacked on top of each other. You can draw
% on one layer, use the positions in another layer for drawing objects
% and return to the original layer to add further content.
%
% The formal definition and documentation of layers can be found in
% the \TikZ{} and \PGF{} manual at \url{https://tikz.dev} or in your
% local tex installation calling either texdoctk or -- on the command
% line using the command “|texdoc pgfmanual|” in the section
% \href{https://tikz.dev/base-layers}{“IX The Basic Layer”
% $\rightarrow$ “Layered Graphics”}.
%
% \begin{macro}{\fcaLayer}\marg{fca entity}\marg{layer}
%
%   This macro assigns an entity to an existing PGF layer. The layer
%   can be accessed in two ways: Ether by using the environment
%   \env{pgfonlayer} with the argument \meta{layer} or by putting the
%   material between the two macros |\fca@|\meta{entity}|layer| and
%   |\fca@end|\meta{entity}|layer|. As the at sign shows, the latter
%   form is intended for internal use in \LaTeX{} packages.
%    \begin{macrocode}
\newcommand*\fcaLayer[2]{%
  \def\@tempa{main}%
  \edef\@tempb{#2}%
  \ifx\@tempb\@empty\let\@tempb\@tempa\fi
  \ifx\@tempa\@tempb
    \def\@tempa{}%
    \def\@tempb{}%
  \else
    \def\@tempa{%
      \begin{pgfonlayer}{#2}%
      }
    \def\@tempb{%
      \end{pgfonlayer}%
    }
  \fi
  \expandafter\let\csname fca@#1layer\endcsname\@tempa
  \expandafter\let\csname fca@end#1layer\endcsname\@tempb
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@labelslayer}
% \begin{macro}{\fca@endlabelslayer}
% \begin{macro}{\fca@labelconceptslayer}
% \begin{macro}{\fca@endlabelconceptslayer}
%
% Since objects and attributes can be collected on two different
% layers, and the same is true for the object and attribute overlays
% of concepts, we use two meta layers to select the correct layer
% depending on the type of the current label. However, help lines (so
% called connectors) are always on the same layer for both object
% labels and attribute labels.
%    \begin{macrocode}
\newcommand*{\fca@labelslayer}{\csname fca@\fca@label@type layer\endcsname}
\newcommand*{\fca@endlabelslayer}{\csname fca@end\fca@label@type layer\endcsname}
\newcommand*{\fca@labelconceptslayer}{\csname fca@\fca@label@type conceptlayer\endcsname}
\newcommand*{\fca@endlabelconceptslayer}{\csname fca@end\fca@label@type conceptlayer\endcsname}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \begin{macro}{\fcaNewLayer}\marg{fca entity}\marg{layer}
%
% This macro is similar to \cs{fcaLayer}, but it creates the PGF
% layer \meta{layer} before assinging it to the macros.
%    \begin{macrocode}
\newcommand*{\fcaNewLayer}[2]{%
  \pgfdeclarelayer{#2}%
  \fcaLayer{#1}{#2}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fcaDeclareLayers} creates a standard set of
%   layers. The layers are assigned and used in the following way:
%   \begin{description}
%  \item[{nodes}]{main}
%  \item[{nodenumbers}]{\pgfkeysvalueof{/fca/namespace} node numbers}
%  \item[{attributes}]{\pgfkeysvalueof{/fca/namespace} attributes}
%  \item[{objects}]{\pgfkeysvalueof{/fca/namespace} objects}
%  \item[{attributesconcept}]{%
%    \pgfkeysvalueof{/fca/namespace} attribute concepts}
%  \item[{objectsconcept}]{%
%    \pgfkeysvalueof{/fca/namespace} object concepts}
%  \item[{edges}]{\pgfkeysvalueof{/fca/namespace} edges}
%  \item[{connectors}]{\pgfkeysvalueof{/fca/namespace} connectors}
%  \item[{}]{\pgfkeysvalueof{/fca/namespace} above nodes}
%  \item[{}]{\pgfkeysvalueof{/fca/namespace} below nodes}
%   \end{description}
%    \begin{macrocode}
\newcommand*{\fcaDeclareLayers}{%
  \fcaLayer{nodes}{main}
  \fcaNewLayer{nodenumbers}{\pgfkeysvalueof{/fca/namespace} node numbers}
  \fcaNewLayer{attributes}{\pgfkeysvalueof{/fca/namespace} attributes}
  \fcaNewLayer{objects}{\pgfkeysvalueof{/fca/namespace} objects}
  \fcaNewLayer{attributesconcept}{%
    \pgfkeysvalueof{/fca/namespace} attribute concepts}
  \fcaNewLayer{objectsconcept}{%
    \pgfkeysvalueof{/fca/namespace} object concepts}
  \fcaNewLayer{edges}{\pgfkeysvalueof{/fca/namespace} edges}
  \fcaNewLayer{connectors}{\pgfkeysvalueof{/fca/namespace} connectors}
  \pgfdeclarelayer{\pgfkeysvalueof{/fca/namespace} above nodes}
  \pgfdeclarelayer{\pgfkeysvalueof{/fca/namespace} below nodes}
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fcaSetLayers} defines the order of the layers used in
%   a diagram. The order can changed using \cs{pgfsetlayers}, if
%   necessary. Note: All used layers should occur in this
%   list. Otherwise they will be ignored by PGF.
%    \begin{macrocode}
\newcommand*{\fcaSetLayers}{%
  \pgfsetlayers{%
    \pgfkeysvalueof{/fca/namespace} edges,%
    \pgfkeysvalueof{/fca/namespace} connectors,%
    \pgfkeysvalueof{/fca/namespace} below nodes,%
    main,%
    \pgfkeysvalueof{/fca/namespace} above nodes,%
    \pgfkeysvalueof{/fca/namespace} node numbers,%
    \pgfkeysvalueof{/fca/namespace} attribute concepts,%
    \pgfkeysvalueof{/fca/namespace} object concepts,%
    \pgfkeysvalueof{/fca/namespace} attributes,%
    \pgfkeysvalueof{/fca/namespace} objects%
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fcaNoLayers} assigns all layers to the current
% layer. This means the graphic objects are drawn one on top of the
% other in the order they appear in the source code. This is the
% default behaviour of the |fca| packages.
%    \begin{macrocode}
\newcommand*\fcaNoLayers{%
  \fcaLayer{nodes}{main}%
  \fcaLayer{nodenumbers}{main}%
  \fcaLayer{attributes}{main}%
  \fcaLayer{objects}{main}%
  \fcaLayer{attributesconcept}{main}%
  \fcaLayer{objectsconcept}{main}%
  \fcaLayer{edges}{main}%
  \fcaLayer{connectors}{main}%
}
\fcaNoLayers
%    \end{macrocode}
%
% \end{macro}{\fcaLayers} instructs a diagram to collect the different
% parts of a diagram into layers. By default later parts are drawn
% above prior parts. So edges are drawn above nodes. In simple
% lattices this is not a problem, but for more complex lattice
% diagrams it may not be completely possible to draw all edges between
% nodes and labels.
%    \begin{macrocode}
\newcommand*{\fcaLayers}{%
  \fcaDeclareLayers
  \fcaSetLayers
}
%    \end{macrocode}
%
%
%   Now, two tests (one for PGF and \TikZ):
% \begin{dtxexample}*{A diagram with layers (left) and flat (right) }
%   \begin{diagram}
%     \fcaLayers
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \Node(3)(20,30)
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \Edge(1)(5)
%     \Edge(2)(4)
%     \Edge(4)(5)
%     \leftAttbox(3){1.}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \leftObjbox(3){Hamilton}
%     \rightObjbox(2){Massa}
%     \rightObjbox(4){Alonso}
%     \end{diagram}
%   \begin{diagram}
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \Node(3)(20,30)
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \Edge(1)(5)
%     \Edge(2)(4)
%     \Edge(4)(5)
%     \leftAttbox(3){1.}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \leftObjbox(3){Hamilton}
%     \rightObjbox(2){Massa}
%     \rightObjbox(4){Alonso}
%     \end{diagram}
% \end{dtxexample}
%
% \iffcatikzdoc
% \begin{dtxexample}*{A \protect\TikZ{} diagram (left: with layers,
% right: without layers)}
%   \begin{tikzdiagram}[/tikz/x=.1cm,/tikz/y=.1cm]%
%     \fcaLayers
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \Node[/tikz/opacity=0.8](3)(20,30)
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \Edge[draw=black,/tikz/opacity=0.3](1)(5)
%     \Edge[/tikz/arrows=<->](2)(4)
%     \Edge[/tikz/opacity=0.3](3)(5)
%     \Edge(4)(5)
%     \leftAttbox[/tikz/opacity=0.3](3){1.}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \leftObjbox[/tikz/opacity=0.3](3){Hamilton}
%     \rightObjbox(2){Massa}
%     \rightObjbox(4){Alonso}
%     \draw (1.center) -- (4.center);
%     \begin{pgfonlayer}{fca below nodes}
%       \draw (5.center)--(2.center);
%     \end{pgfonlayer}
%   \end{tikzdiagram}
%   \begin{tikzdiagram}[/tikz/x=.1cm,/tikz/y=.1cm]%
%     \Node(1)(20,10)
%     \Node(2)(35,20)
%     \Node[/tikz/opacity=0.3](3)(20,30)
%     \Node(4)(35,40)
%     \Node(5)(20,50)
%     \Edge(1)(2)
%     \Edge[/tikz/draw=black,/tikz/opacity=0.3](1)(5)
%     \Edge[/tikz/arrows=<->](2)(4)
%     \Edge(4)(5)
%     \leftAttbox[/tikz/opacity=0.3](3){1.}
%     \rightAttbox(2){disqualified}
%     \rightAttbox(4){2.}
%     \leftObjbox[/tikz/opacity=0.3](3){Hamilton}
%     \rightObjbox(2){Massa}
%     \rightObjbox(4){Alonso}
%     \draw (1.center) -- (4.center);
%     \draw (5.center)--(2.center);
%   \end{tikzdiagram}
% \end{dtxexample}
% \fi
%
%    \begin{macrocode}
% We allow to select the label type and positioning independently.
% This function executes the right positioning settings.
\newcommand\fca@dolabelposition{%
  \pgfkeysgetvalue{/fca/label/type}{\@tempa}%
  \pgfkeysgetvalue{/fca/label/position}{\@tempb}%
  \ifx\pgfnovalue\@tempa
  \else
    \ifx\pgfnovalue\@tempb
    \else
      \pgfkeysalso{/fca/label/\@tempa{} position=\@tempb}%
    \fi
  \fi
}

\newcommand*\fcaNewLabelType{%
  \@ifstar{\fca@NewLabelType}{\fca@NewL@belType}%\fistar
}
\newcommand*\fca@NewLabelType[1]{%
  \pgfqkeys{/fca/label}{%
    type/#1/.style={type=#1},
    #1 position/.is choice,
  }%
}
\newcommand*\fca@NewL@belType[1]{%
  \fca@NewLabelType{#1}%
  \pgfqkeys{/fca/label}{%
    #1/.style={type=#1}%
  }%
}
\newcommand*\fcaNewLabelPosition{%
  \@ifstar{\fca@NewLabelPosition}{\fca@NewL@belPosition}%\fistar
}
\newcommand*\fca@NewLabelPosition[1]{%
  \pgfqkeys{/fca/label}{%
    position/#1/.style={position=#1},
  }%
}
\newcommand*\fca@NewL@belPosition[1]{%
  \fca@NewLabelPosition{#1}%
  \pgfqkeys{/fca/label}{%
    #1/.style={position=#1}%
  }%
}

%    \end{macrocode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% Changing the default values                                                 %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Generate some parameters which may be shared with \TikZ}
%    \begin{macrocode}
\newcommand*\fca@generate@tikz@parameter[3]{%
  \pgfqkeys{/fca/#1}{.initial={#2},.value required}
}
\newcommand*\fca@generate@tikz@parameters{%
  \@for \fca@tmp:=%
  {font}{}{\tikz@textfont},%
  {node font}{}{\tikz@node@textfont},%
  {text opacity}{}{\tikz@textopacity},%
  {text width}{\pgfkeysnovalue}{\tikz@text@width},%
  {text height}{}{\tikz@text@height},
  {text depth}{}{\tikz@text@depth},
  {text action}{}{\tikz@text@action},
  {options}{}{\tikz@options},%\newcommand*{\fca@node@fill}{white}%
  {anchor}{}{\tikz@anchor},
  {shape}{}{\tikz@shape}
  \do {
    \expandafter\fca@generate@tikz@parameter\fca@tmp
  }
}
\fca@generate@tikz@parameters
%    \end{macrocode}
% \iffalse
%</fca.sty>
%<*tikz>
% \fi
%
% \subsection{set up what we need from tikz}
%    \begin{macrocode}
\RequirePackage{fca}
\let\fca@tikz@without@library\relax
\def\fca@generate@tikz@parameter#1#2#3{%
  \pgfkeysdef{/fca/#1}{\pgfkeys{/tikz/#1=##1}}
  \pgfkeyssetvalue{/fca/#1}{#3}%
}
%    \end{macrocode}
% \subsection{Backports and bugfixes for \TikZ{}}
%    \begin{macrocode}
\@ifpackagelater{tikz}{2020/09/28}{}{%
  \PackageWarning{fca}{Your TikZ version does not fully support fca
    name spaces.^^J
    I'm trying to fix that..., trying to apply^^J
    patch 88951be592b558b94b14a97aaffe9df6c1ce61ee from TikZ}
  \def\tikz@calc@anchor#1.#2\tikz@stop{%
    % Check if a shape with name prefix exists, otherwise try the global name
    % without prefix.
    \ifcsname pgf@sh@ns@\tikz@pp@name{#1}\endcsname%
      \pgfpointanchor{\tikz@pp@name{#1}}{#2}%
    \else
      \pgfpointanchor{#1}{#2}%
    \fi
  }%
\def\tikz@subpicture@handle@#1{
  \pgfkeys{/tikz/pics/.cd,#1}%
  \tikz@node@transformations%
  \let\tikz@transform=\relax%
  \let\tikz@picmode\tikz@mode%
  \tikzset{name prefix ../.style/.expanded={/tikz/name prefix=\pgfkeysvalueof{/tikz/name prefix}}}%
  \ifx\tikz@fig@name\pgfutil@empty\else%
    \tikzset{name prefix/.expanded=\tikz@fig@name}%
  \fi%
  \pgfkeysvalueof{/tikz/pics/setup code}%
  \pgfkeysgetvalue{/tikz/pics/code}{\tikz@pic@code}
  \ifx\tikz@pic@code\pgfutil@empty\else%
  \setbox\tikz@whichbox=\hbox\bgroup%
    \unhbox\tikz@whichbox%
      \hbox\bgroup
      \bgroup%
      \pgfinterruptpath%
      \pgfscope%
      \tikz@options%
      \setbox\tikz@figbox=\box\pgfutil@voidb@x%
      \setbox\tikz@figbox@bg=\box\pgfutil@voidb@x%
      \tikz@atbegin@scope%
      \scope[every pic/.try]%
      \tikz@pic@code%
      \endscope%
      \tikz@atend@scope%
      \endpgfscope%
      \endpgfinterruptpath%
      \egroup
      \egroup%
      \egroup%
    \fi%
    \pgfkeysgetvalue{/tikz/pics/foreground code}{\tikz@pic@code}
    \ifx\tikz@pic@code\pgfutil@empty\else%
      \setbox\tikz@figbox=\hbox\bgroup%
      \unhbox\tikz@figbox%
      \hbox\bgroup
      \bgroup%
      \pgfinterruptpath%
      \pgfscope%
      \tikz@options%
      \setbox\tikz@figbox=\box\pgfutil@voidb@x%
      \setbox\tikz@figbox@bg=\box\pgfutil@voidb@x%
      \tikz@atbegin@scope%
      \scope[every front pic/.try]%
      \tikz@pic@code%
      \endscope%
      \tikz@atend@scope%
      \endpgfscope%
      \endpgfinterruptpath%
      \egroup
      \egroup%
      \egroup%
    \fi%
    \pgfkeysgetvalue{/tikz/pics/background code}{\tikz@pic@code}
    \ifx\tikz@pic@code\pgfutil@empty\else%
      \setbox\tikz@figbox@bg=\hbox\bgroup%
      \unhbox\tikz@figbox@bg%
      \hbox\bgroup
      \bgroup%
      \pgfinterruptpath%
      \pgfscope%
      \tikz@options%
      \setbox\tikz@figbox=\box\pgfutil@voidb@x%
      \setbox\tikz@figbox@bg=\box\pgfutil@voidb@x%
      \tikz@atbegin@scope%
      \scope[every behind pic/.try]%
      \tikz@pic@code%
      \endscope%
      \tikz@atend@scope%
      \endpgfscope%
      \endpgfinterruptpath%
      \egroup
      \egroup%
      \egroup%
    \fi%
    \tikz@node@finish%
  }%
\def\tikz@parse@node#1(#2){%
  \pgfutil@in@.{#2}% Ok, flag this
  \ifpgfutil@in@
    \tikz@calc@anchor#2\tikz@stop%
  \else%
    \tikz@calc@anchor#2.center\tikz@stop% to be on the save side, in
                                % case iftikz@shapeborder is ignored...
    \ifcsname pgf@sh@ns@\tikz@pp@name{#2}\endcsname
      \expandafter\ifx\csname pgf@sh@ns@\tikz@pp@name{#2}\endcsname\tikz@coordinate@text%
      \else
        \tikz@shapebordertrue%
        \def\tikz@shapeborder@name{\tikz@pp@name{#2}}%
      \fi%
    \else\ifcsname pgf@sh@ns@#2\endcsname
      \expandafter\ifx\csname pgf@sh@ns@#2\endcsname\tikz@coordinate@text%
      \else
        \tikz@shapebordertrue%
        \def\tikz@shapeborder@name{#2}%
      \fi%
    \fi\fi
  \fi%
  \edef\tikz@marshal{\noexpand#1{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}}%
  \tikz@marshal%
}%
 }%
%    \end{macrocode}
%
% \paragraph{Options that are directly forwarded to \TikZ{}} If they
% are not documented somewhere else, their implementation needs
% \filenm{fca.sty} fröm the \TikZ{library} \filenm{fca}.
% \begin{description}
% \ItemDescribeOption{shape} shape of the node
% \ItemDescribeOption{text ragged} node text is ragged right with hyphenation%
% \ItemDescribeOption{text badly ragged} node text is ragged right
% nearly without hyphenation (normal \LaTeX{} mode)%
% \ItemDescribeOption{text ragged left} node text is ragged left%
% \ItemDescribeOption{text badly ragged left} node text is ragged left
% nearly without hyphenation (normal \LaTeX{} mode)%%
% \ItemDescribeOption{text justified} The text is spread to fit the
% border on both sides of the text box (typically with hyphanation)%
% \ItemDescribeOption{text centered} The node text is horizontally centered%
% \ItemDescribeOption{text badly centered}  node text is centered horizontally
% nearly without hyphenation (normal \LaTeX{} mode)%%%
% \ItemDescribeOption{even odd rule} self overlapping paths are filled
% so that every border is an outside border (an even number of borders
% in each direction means outside and an odd number means inside.
% \ItemDescribeOption{nonzero rule} The default rule of \TikZ{} for
% filling paths. The algorithm is described in the
% \href{https://tikz.dev/tikz-actions#sec-15.5.2}{\TikZ{} documentation}
% (see \cmd{texdoc pgfmanual.pdf}).
% \ItemDescribeOption{fill opacity} The opacity of the filled copy of
% the path or node
% \ItemDescribeOption{opacity} General option of the opacity%
% \ItemDescribeOption{blend mode} This option defines, how thransparency
% changes the colors of semitransparent objects. See the
% \href{https://tikz.dev/tikz-transparency#sec-23.3}{\TikZ{}
%   documentation} for further details.
% \ItemDescribeOption{color} Sets stroke and fill color (border and
% interior) to the same color
% \ItemDescribeOption{rotate} rotate some path%
% \ItemDescribeOption{solid} draw lines solid%
% \ItemDescribeOption{dotted} draw lines dotted%
% \ItemDescribeOption{loosely dotted} draw lines dotted with more space
% between the dots%
% \ItemDescribeOption{densely dotted} draw lines dotted with less space
% between the dots%
% \end{description}
%
%    \begin{macrocode}
\fca@generate@tikz@parameters
\@for \@tempa:=%
shape,
text ragged,%
text badly ragged,%
text ragged left,%
text badly ragged left,%
text justified,%
text centered,%
text badly centered,%
even odd rule,%
nonzero rule,%
fill opacity,%
opacity,%
blend mode,%
color,%
rotate,%
solid,%
dotted,%
loosely dotted,%
densely dotted,%
line width,%
x,%
y%
\do {
  \edef\@tempb{%
    \noexpand\pgfkeysdef{/fca/\@tempa}{\noexpand\pgfqkeys{/tikz}{\@tempa={##1}}}%
  }%
  \@tempb
}
\pgfkeysdef{/fca/options}{\tikz@addoption{#1}}
\pgfkeysdef{/fca/stroke}{%
  \pgfqkeys{/tikz}{draw={#1}}%
  \fca@testoption{#1}{%
    \fca@append\fca@usepath{stroke,}%
  }{}{%
    \fca@append\fca@usepath{stroke,}%
  }%
}
\pgfkeysdef{/fca/fill}{%
  \pgfqkeys{/tikz}{fill={#1}}%
  \fca@testoption{#1}{%
    \fca@append\fca@usepath{fill,}%
  }{}{%
    \fca@append\fca@usepath{fill,}%
  }%
}
\def\fca@options{\tikz@options}%
\def\fca@defaultoptions{\tikz@options}%
\def\fca@transform{\tikz@transform}%
\@ifundefined{tikz@transform}{\let\tikz@transform\empty}{}
\let\fca@ifintikz\@secondoftwo
\tikzaddtikzonlycommandshortcutlet\fca@ifintikz\@firstoftwo
\fcaset{%
  attributes left/.append style={
    align=flush right
  },
  attributes center/.append style={
    align=flush center
  },
  attributes right/.append style={
    align=flush left
  },
  objects left/.append style={
    align=flush right
  },
  objects center/.append style={
    align=flush center
  },
  objects right/.append style={
    align=flush left
  }
}

%    \end{macrocode}
%
%    \begin{macrocode}
\let\fca@notikz@parse@paren@vector\fca@parse@paren@vector
\newcommand\fca@tikz@parse@paren@vector[3]{%
  \def\tikz@coordinate@caller{%
    \fca@notikz@parse@paren@vector{#1}{#2}{#3}%
  }%
  \tikz@scan@one@point \tikz@@coordinate@at@math
}

\newcommand\fca@tikz@oldnode[4]{%
  \begin{pgfscope}%
    \fca@nodeslayer
    \path (#3,#4) node[
      anchor=center,
      shape=circle,
      /fca/.cd,
      /fca/every node/.try,
      /fca/every concept/.try,
      #1]
      (#2) {} ;%
    \fca@endnodeslayer
    \ifthenelse{\boolean{fca@CircledNumbers}}{%
      \fca@nodenumberslayer
      \path (#2)
        node[
        shape=circle,
        anchor=center,
        /fca/.cd,
        /fca/every node/.try,
        /fca/every concept/.try,
        #1
        /fca/.cd,
        /fca/node number,
        draw=none]%
        (#2 number)
        {#2};%
      \fca@endnodenumberslayer
    }{}%
  \end{pgfscope}%
  \ignorespaces
}
%    \end{macrocode}
%
% \iffcatikzdoc
% \begin{dtxexample}{Testing lines with \TikZ{}}
%   \definecolor{darkgreen}{rgb}{0.05,0.5,0.}
% \begin{tikzdiagram}[x=1.2mm,y=1.2mm]
%  \Node(1)(20,10)
%  \Node(2)(35,20)
%  \Node(3)(5,30)
%  \Node(4)(35,40)
%  \Node(5)(20,50)
%  {\color{red}\Edge(1)(2)}
%  \Edge[draw=blue,dotted,line width=1mm](1)(3)
%  \Edge(2)(4)
%  \EdgeThickness{2mm}
%  \Edge[draw=green](3)(5)
%  \Edge(4)(5)
% \end{tikzdiagram}
% \end{dtxexample}
% \fi
%
%    \begin{macrocode}
\newcommand{\fca@tikz@oldedge}[3]{%
  \fca@edgeslayer
  \path[draw,/fca/.cd,every edge/.try,#1] (#2) edge (#3);%
  \fca@endedgeslayer
  \ignorespaces
}

\newcommand\fca@tikz@labelBox[1]{%
  \begin{scope}%
    \fcaset{every node/.try,every label/.try,#1}%
    \edef\@tempa{\pgfkeysvalueof{/fca/pgfnode}}%
    \xdef\fca@temp@node@name{%
      \expandafter\fca@remove@anchor\expandafter{\@tempa}%
    }%
    \fca@labelslayer
      \path[/fca/.cd,every node/.try,every label/.try,#1]
      (\fca@temp@node@name.\fca@label@at)
      ++(\fca@label@shift@x,\fca@label@shift@y)
      node[shape=rectangle] (%
        \pgfkeysvalueof{/fca/label/name prefix}%
        \pgfkeysvalueof{/fca/node}%
        \pgfkeysvalueof{/fca/label/name suffix}%
      ){%
        \pgfkeysvalueof{/fca/node contents}%
      };%
    \fca@endlabelslayer
    \iffca@connectors
      \begin{scope}
        \fca@connectorslayer
        \path[draw,/fca/.cd,#1,every label edge/.try,/tikz/.cd]
        (\pgfkeysvalueof{/fca/node}) --
        (%
        \pgfkeysvalueof{/fca/label/name prefix}%
        \pgfkeysvalueof{/fca/node}%
        \pgfkeysvalueof{/fca/label/name suffix}%
        .\pgfkeysvalueof{/fca/anchor}) ;
        \fca@endconnectorslayer
      \end{scope}%
    \fi
    \begin{scope}
      \fcaset{shape=coordinate,#1}%
      \fcaset{%
        every label concept/.try}%
      \fcaset{%
        label concept/.try
      }%
      \def\@tempa{coordinate}%
      \ifx\@tempa\tikz@shape
      \else
        \fca@labelconceptslayer
        %\edef\fca@tempa{
        \path
          (\fca@temp@node@name.\fca@label@at)%
          node[draw,
          /fca/.cd,
          shape=coordinate,
          #1,
          every label concept/.try,
          label concept/.try]
        (\pgfkeysvalueof{/fca/label/name prefix}%
          \pgfkeysvalueof{/fca/node}%
          \pgfkeysvalueof{/fca/label/name suffix}%
          ){};
        % \pgfsetstrokecolor{\fca@node@color}%
        %\pgfnode{}{\pgfkeysvalueof{/fca/anchor}}{}{}%
        \fca@endlabelconceptslayer
      \fi
    \end{scope}
  \end{scope}%
  \ignorespaces
}
\newcommand\fca@tikz@startdiagram[1][]{%
  \fca@notikz@startdiagram%
  \fca@tikz@diagram@
}
\newcommand\fca@tikz@Defaults{
  \fca@notikz@Defaults
  \pgfkeysgetvalue{/tikz/name prefix}{\fca@tikz@origprefix}%
  \pgfkeysgetvalue{/fca/name prefix}{\@tempb}%
  \let\@tempa\fca@tikz@origprefix
  \fca@concat\@tempa\@tempb%
  \pgfqkeys{/tikz}{%
    name prefix/.expand once=\@tempa
  }%
  \pgfkeysgetvalue{/fca/name suffix}{\@tempa}%
  \pgfkeysgetvalue{/tikz/name suffix}{\@fca@tikz@origsuffix}%
  \fca@concat\@tempa\@fca@tikz@origsuffix%
  \pgfqkeys{/tikz}{%
    name suffix/.expand once=\@tempa
  }%
  \pgfkeyssetvalue{/fca/name prefix}{%
    \pgfkeysvalueof{/tikz/name prefix}%
  }%
  \pgfkeyssetvalue{/fca/name suffix}{%
    \pgfkeysvalueof{/tikz/name suffix}%
  }%
}
\tikzaddtikzonlycommandshortcutlet\fca@oldnode\fca@tikz@oldnode
\tikzaddtikzonlycommandshortcutlet\fca@oldedge\fca@tikz@oldedge
\tikzaddtikzonlycommandshortcutlet\fca@@labelBox\fca@tikz@labelBox
\tikzaddtikzonlycommandshortcutlet\fca@parse@paren@vector\fca@tikz@parse@paren@vector
\tikzaddtikzonlycommandshortcutlet\fca@notikz@Defaults\fca@Defaults
\tikzaddtikzonlycommandshortcutlet\fca@Defaults\fca@tikz@Defaults
%    \end{macrocode}
% \iffalse
%</tikz>
%<*fca.sty>
% \fi
%
% \begin{macro}{\fcaset}\marg{key value list}
%   Sets the options for the following operations. Possible options
%   are listed below. The beginning \optn{/fca/} can be omitted as it
%   is provieded by the macro \cs{fcaset}. \cs{fcaset}\marg{key value
%   list} is expanded to \cs{pgfqkeys}\optn{{/fca}}\marg{key value list}.
%
%   This macro is similar to \cs{pgfkeys}, except that it
%   sets \filenm{/fca} as default path. This is a powerful macro that
%   cannot be described here in full detail. The full documentation
%   can be found in the \href{https://tikz.dev/pgfkeys}{\PGF/\TikZ{}
%   Manual} in \filenm{pgfmanual.pdf} of your \PGF{} documentation.
%
%
%    \begin{macrocode}
\newcommand*\fcaset{\pgfqkeys{/fca}}
%    \end{macrocode}
% \end{macro}
%
% Options can be set globally outside
%
% \begin{description}
% \ItemDescribeOption{/fca/font} font selection macros used inside
% nodes (forwarded to \optn{/tikz/font} when loaded as TikZ library).
% \ItemDescribeOption{/fca/node font} The font selection macros that
% are used during node size calculation
% (forwarded to \optn{/tikz/node font} when loaded as TikZ library).
% \ItemDescribeOption{/fca/text opacity} Opacity of the text in nodes
% (forwarded to \optn{/tikz/text opacity} when loaded as TikZ library).
% \ItemDescribeOption{/fca/text width} Width of the text in nodes
% (allows multiline nodes e.g. multi-line labels)
% (forwarded to \optn{/tikz/text width} when loaded as TikZ library).
% \ItemDescribeOption{/fca/text height} height of the text box of
% \PGF{} nodes
% (forwarded to \optn{/tikz/text height} when loaded as TikZ library).
% \ItemDescribeOption{/fca/text depth} depth of the text box of \PGF{}
% nodes
% (forwarded to \optn{/tikz/text depth} when loaded as TikZ library).
% \ItemDescribeOption{/fca/text action} \textbf{Undocumented extension
% to \TikZ} Stores the alignment setup macros \TikZ{} nodes.
% \ItemDescribeOption{/fca/options}  \textbf{Undocumented extension
% to \TikZ} direct access to \cs{tikz@options}.
% \ItemDescribeOption{/fca/anchor} specifies the anchor of a node to
% be used for placement
% (forwarded to \optn{/tikz/anchor} when loaded as TikZ library).
% \ItemDescribeOption{/fca/shape} the shape of a node (concept or label)
% (forwarded to \optn{/tikz/shape} when loaded as TikZ library).
% \ItemDescribeOption{/fca/connector} Draw a connector line between the node
% and the label. Values are \optn{true} and \optn{false}.
% \ItemDescribeOption{/fca/namespace} Namespace used in name prefixes and
% layer names, Default: fca, \textbf{value required}
% \ItemDescribeOption{/fca/name prefix} Pattern to be added before node
% names. This can be interesting when a diagram is inside a
% \env{tikzpicture} or \env{pgfpicture} environment in order to
% address the diagram nodes. Default: |\pgfkeysvalueof{/fca/namespace}\space node\space|,
%   \textbf{value required}
% \ItemDescribeOption{/fca/name suffix} Default: empty,
%   \textbf{value required}
% \ItemDescribeOption{/fca/every node/.style} Style to be executed at the
% beginning of every node (both labels as well as concepts). Default: empty
% \ItemDescribeOption{/fca/every concept/.style} Style to be executed at
% every concept node (when calling \cs{Node}).
% Default:
% \begin{verbatim}
% {%
%   radius = 2,
%   fill=white,
%   draw=black
% },
% \end{verbatim}
% \ItemDescribeOption{/fca/every attributes/.style} Style that is executed
% whenever an attribute label is typeset. Default:
% \begin{verbatim}
% {%
%   font=\small\baselineskip1em\rmfamily\itshape
% }%
% \end{verbatim}
% \ItemDescribeOption{/fca/every objects/.style} Style that is executed
% whenever an object label is placed in the diagram. Defaul:
% \begin{verbatim}
% {%
%   font=\small\baselineskip1em\rmfamily\upshape
% }
% \end{verbatim}
% \ItemDescribeOption{/fca/every edge/.style} Style that is executed
% whenever an edge betwee two concepts is drawn using
% \cs{Edge}. Default: empty.
% \ItemDescribeOption{/fca/every label edge/.style}
%   Style that is drawn whenever a connector between a concept and one
%   of its labels is drawn. Default:
% \begin{verbatim}
% {
%   dotted, draw=black
% }
% \end{verbatim}
%   \ItemDescribeOption{/fca/font}
%   Font to be used inside labels. This is the actually set font.
%   Default: |\small\baselineskip1em\rmfamily|
%
% \watchout the font is applied after the node size has been
% calculated. The font size for the size calculations must be set
% using the option \optn{node font}.
% \ItemDescribeOption{/fca/shape} Shape of the nodes. Default: circle,
% \ItemDescribeOption{/fca/minimum width} Set the minimum width of a node
% or label.
% This is an alias of \optn{/pgf/minimum width}.
% \ItemDescribeOption{/fca/minimum height} set the minimum height of a node
% or label. This is an alias of /pgf/minimum height.
% \ItemDescribeOption{/fca/minimum size} Set both \optn{minimum width} and
% \optn{minimum height}. This is an alias of /pgf/minimum size.
% \ItemDescribeOption{/fca/inner xsep} Minimum horizontal distance between
% node content and node border (same for labels). This is an alias of /pgf/inner xsep.
% \ItemDescribeOption{/fca/inner ysep} Minimum vertical distance between
% node content and node border (same for labels). This is an alias of /pgf/inner ysep.
% \ItemDescribeOption{/fca/inner sep} Sets both \optn{inner xsep} and
% \optn{inner ysep}. This is an alias of /pgf/inner sep.
% \ItemDescribeOption{/fca/outer xsep} Minimum horizontal distance between
% node border and the next elements. This is an alias of /pgf/outer xsep.
% \ItemDescribeOption{/fca/outer ysep} Minimum vertical distance between
% node border and the next elements. This is an alias of /pgf/outer ysep.
% \ItemDescribeOption{/fca/outer sep} Sets both \optn{inner xsep} and
% \optn{inner ysep}. This is an alias of /pgf/outer sep.
% \ItemDescribeOption{/fca/radius} Set the radius of circled nodes in |\unitlength|
% \ItemDescribeOption{/fca/anchor} Determines which anchor should be
% represented by the given coordinates.
%   \textbf{value required}
% \ItemDescribeOption{/fca/node number/.style} Style of the node names
% (traditionally numbers) of the diagram when \cs{fcaNumbers} is used.
% Default:
% \begin{verbatim}
% {
%   node font=\tiny,
%   font=\tiny
% }
% \end{verbatim}
% \ItemDescribeOption{/fca/color} Change the color of the things to be drawn
% \ItemDescribeOption{/fca/stroke} Draw the line in the current object. If
% a value is given it is interpreted to be the line colour.
% \ItemDescribeOption{/fca/draw} This is an alias of \optn{/fca/stroke}.
% \ItemDescribeOption{/fca/fill} Fill the current object with the colour
% given as value or the default fill colour.
% \ItemDescribeOption{/fca/text} The colour that is used for texts in
% nodes. Default: |pgfstrokecolor|, that is the line colour.
%   \textbf{value required}
% \ItemDescribeOption{/fca/label type} This is an alias of \optn{/fca/label/type}.
% \ItemDescribeOption{/fca/label position} This is an alias of \optn{/fca/label/position}.
% \ItemDescribeOption{/fca/pgfnode} Pattern used to construct node names
% (if \TikZ{} is not loaded). \textbf{value required} Default:
% \begin{verbatim}
% \pgfkeysvalueof{/fca/name prefix}\pgfkeysvalueof{/fca/node}\pgfkeysvalueof{/fca/name suffix}a
% \end{verbatim}
% \ItemDescribeOption{/fca/node} Name of the node where the label should be
% attached to. Default: {},
%   \textbf{value required}
% \ItemDescribeOption{/fca/node contents} Contents of the new node to be
% drawn. This is mainly used for labels. Default: {},
%   \textbf{value required}
% \ItemDescribeOption{/fca/shift/x} \textbf{value required}
% \ItemDescribeOption{/fca/shift/y} \textbf{value required}
% \ItemDescribeOption{/fca/shift=\{\parg{x,y}\}} Offset values for
% shifting labels from their default position. Usually the offset is
% added to the coordinates where the anchor would be. Prior to version
% 3.0 \filenm{fca.sty} used distences to shift the nodes. Both Schemes
% are valid and have their benefits. The current implementation
% follows the scheme of \TikZ{}.
%
% \watchout[changes in 3.0] For compatibility reasons the sign of the
% shift parameter is changed when the old syntax for labels is used.
%
% \ItemDescribeOption{/fca/shift/x/signv2.1} \textbf{value required}
% \ItemDescribeOption{/fca/shift/y/signv2.1} \textbf{value required}
% These parameters define how the distance values in the old syntax
% should be interpreted by \LaTeX{}. You should change this parameter
% only, if you really know what you are doing. Otherwise you could
% easily mess up the diagram.
%
% \ItemDescribeOption{/fca/rotate} rotate the current object
% \ItemDescribeOption{/fca/solid} Draw lines as solid lines
% \ItemDescribeOption{/fca/dotted} Draw lines as dotted lines
% \ItemDescribeOption{/fca/loosely dotted} Draw lines as dotted lines with
% more space between the dots
% \ItemDescribeOption{/fca/densely dotted} Draw lines as dotted lines with
% less space between the dots
% \ItemDescribeOption{/fca/every label/.style} A style that describes how
% object and attribute labels should be decorated. Default:
% \begin{verbatim}
% {
%   text=pgfstrokecolor,
%   /pgf/outer sep=0pt,
%   /pgf/inner sep=0pt,
% }
% \end{verbatim}
%
% \ItemDescribeOption{/fca/node/line width} line width of the nodes
%   \textbf{value required}
% \ItemDescribeOption{/fca/node/radius} Node radius
%  \ItemDescribeOption{/fca/node/layer} Layer where the node shall be
%  put in.
% \ItemDescribeOption{/fca/node/numbers}  \meta{true} or \meta{false},
% defaults to \meta{true}, if given without value.  Draw \PGF{} node names of the
% concepts in the diagram.
%
% \ItemDescribeOption{/fca/node/number prefix}
%   \textbf{value required} Prefix to be added to the node name for
%   the name of the node that contains the node name
% \ItemDescribeOption{/fca/node/number suffix}
%   \textbf{value required} Prefix to be added to the node name for
%   the name of the node that contains the node
%   name
% \watchout[Confused?] The printed node name is a node
%   itself. And every node in \PGF{} must have a unique name. This is
%   constructed by appending this prefix to the already existing
%   prefix and prepending this suffix to the already existing suffix.
%
% \watchout[TODO!] Or are prefix and suffix simply replaced?
% \ItemDescribeOption{/fca/label/name prefix} Default: |\pgfkeysvalueof{/fca/namespace}\space node\space|,
%   \textbf{value required}
% \ItemDescribeOption{/fca/label/name suffix} Default: |\space\fca@label@type\space\fca@label@position|,
% \textbf{value required}
% Prefix and suffix to be added to the node name for
%   the name of the label
%
% \watchout[TODO!] Or are prefix and suffix simply replaced?
% \ItemDescribeOption{/fca/label/fill}
%   \textbf{value required}, fill the label with the given colour,
% \ItemDescribeOption{/fca/label/text width},
%   \textbf{value required} Width of the text of the node. This option
%   enables multiline labels.
% \ItemDescribeOption{/fca/label/node font}
%   \textbf{value required}, Font macros to be applied to the label content
%   before the size of the node is calculated.
% \ItemDescribeOption{/fca/label/edge width}
%   \textbf{value required}, thickness of the edge of the label node
%   (typically the border size)
% \ItemDescribeOption{/fca/label/at}
% \textbf{value required} Information for anchoring labels on nodes
% \watchout[TODO!!!] look up what is really done
% \ItemDescribeOption{/fca/label/type}
% Defines the type of the given label. Every subobject of
% \optn{/fca/label/type} can be chose as label type. The predefined
% options are \optn{attributes} and \optn{objects}.
%
% New types can be defined by adding it to this path. In that case
% also a styles named \optn{/fca/label/\meta{type} \meta{position}}
% should be defined that do the actual formatting of the new label
% type. These types are immediately executed whenever a label type or
% a label position is changed (see below).
%
% \ItemDescribeOption{/fca/label/type/attributes/.style}
% Makes the label type \optn{attributes} available and defines styles
% for all attribute labels.
% \ItemDescribeOption{/fca/label/type/objects/.style}
% Makes the label type \optn{objects} available and defines styles
% for all object labels.
%
% \ItemDescribeOption{/fca/label/position}
% Defines the positon of the given label. Every subobject of
% \optn{/fca/label/positon} can be chose as position. The predefined
% options are \optn{left}, \optn{center} and \optn{right}.
%
% \ItemDescribeOption{/fca/label/position/left/.style}
% Makes the label position \optn{left} available and defines styles
% for all left labels.
% \ItemDescribeOption{/fca/label/position/center/.style}
% Makes the label position \optn{center} available and defines styles
% for all centered labels.
% \ItemDescribeOption{/fca/label/position/right/.style}
% Makes the label position \optn{right} available and defines styles
% for all right labels.
%
% \ItemDescribeOption{/fca/label/attributes left/.style}
% Describes how attribute labels on the left hand side of the concept
% should be formatted. By default this affects placement and text
% alignment.
% \ItemDescribeOption{/fca/label/attributes center.style}
% Describes how attribute labels that are horizontally centered to the concept
% should be formatted. By default this affects placement and text
% alignment.
% \ItemDescribeOption{/fca/label/attributes left/.style}
% Describes how attribute labels on the right hand side of the concept
% should be formatted. By default this affects placement and text
% alignment.
% \ItemDescribeOption{/fca/label/objects left/.style}
% Describes how object labels on the left hand side of the concept
% should be formatted. By default this affects placement and text
% alignment.
% \ItemDescribeOption{/fca/label/objects center.style}
% Describes how object labels that are horizontally centered to the concept
% should be formatted. By default this affects placement and text
% alignment.
% \ItemDescribeOption{/fca/label/objects left/.style}
% Describes how object labels on the right hand side of the concept
% should be formatted. By default this affects placement and text
% alignment.
% \end{description}
%
%    \begin{macrocode}

\newcommand\fca@append[2]{%
  \expandafter\def\expandafter#1\expandafter{#1#2}%
}
\newcommand\fca@concat[2]{%
  \expandafter\fca@append\expandafter#1\expandafter{#2}%
}


\fcaset{%
  connector/.is if=fca@connectors,
  namespace/.initial=fca,
  namespace/.value required,
  name prefix/.initial=\pgfkeysvalueof{/fca/namespace}\space node\space,
  name prefiv/.value required,
  name suffix/.initial={},
  name suffix/.value required,
  every node/.style = {},
  every concept/.style = {
    radius = 2,
    fill=white,
    draw=black
  },
  every attributes/.style = {
    font=\AttributeLabelStyle
  },%\newcommand*{\fca@node@fill}{white}%%\newcommand*{\fca@node@fill}{white}%
  every objects/.style = {
    font=\ObjectLabelStyle
  },
  every edge/.style = {},
  every label edge/.style = { dotted, draw=black },
  font=\small\baselineskip1em\rmfamily,
  shape/.initial=circle,
  minimum width/.forward to=/pgf/minimum width,
  minimum height/.forward to=/pgf/minimum height,
  minimum size/.forward to=/pgf/minimum size,
  inner xsep/.forward to=/pgf/inner xsep,
  inner ysep/.forward to=/pgf/inner ysep,
  inner sep/.forward to=/pgf/inner sep,
  outer xsep/.forward to=/pgf/outer xsep,
  outer ysep/.forward to=/pgf/outer ysep,
  outer sep/.forward to=/pgf/outer sep,
  radius/.code={
    \fca@parselength\@tempdima{#1}\unitlength
    \@tempdima=.70710678118654752440084436210484\@tempdima
    \edef\@tempa{\noexpand\pgfkeysalso{/pgf/inner sep=\the\@tempdima}}%
    \@tempa
  },
  % anchor/.store in=\fca@label@anchor,
  % anchor/.value required,
  node number/.style = { node font=\tiny, font=\tiny },
  color/.code={\fca@append\fca@options{\color{#1}}},
  line width/.code={%
    \fca@append\fca@options{\pgfsetlinewidth{#1}}%
    \pgfmathsetlength\pgflinewidth{#1}%
  },
  stroke/.code={%
    \fca@testoption{#1}{%
      \fca@append\fca@options{%
        \pgfsetstrokecolor{#1}%
      }%
      \fca@append\fca@usepath{stroke,}%
    }{%
      \fca@append\fca@options{%
        \let\pgf@up@stroke\pgfutil@empty
      }%
    }{%
      \fca@append\fca@usepath{stroke,}%
    }%
  },
  draw/.forward to=/fca/stroke,
  fill/.code={%
    \fca@testoption{#1}{%
      \fca@append\fca@options{%
        \pgfsetfillcolor{#1}%
      }%
      \fca@append\fca@usepath{fill,}%
    }{%
      \fca@append\fca@options{%
        \let\pgf@up@fill\pgfutil@empty
      }%
    }{%
      \fca@append\fca@usepath{fill,}%
    }%
  },
  text/.initial=pgfstrokecolor,
  text/.value required,
  label type/.forward to=/fca/label/type,
  label position/.forward to=/fca/label/position,
  pgfnode/.initial={%
    \pgfkeysvalueof{/fca/name prefix}%
    \pgfkeysvalueof{/fca/node}%
    \pgfkeysvalueof{/fca/name suffix}%
  },
  pgfnode/.value required,
  node/.initial={},
  node/.value required,
  node contents/.initial={},
  node contents/.value required,
  shift/x/.store in=\fca@label@shift@x,
  shift/x/.value required,
  shift/y/.store in=\fca@label@shift@y,
  shift/y/.value required,
  shift/.value required,
  shift/.style args={(#1,#2)}{%
    /fca/shift/x=#1,
    /fca/shift/y=#2
  },%
  shift/x/signv2.1/.store in=\fca@label@shift@x@sign,
  shift/x/signv2.1/.value required,
  shift/y/signv2.1/.store in=\fca@label@shift@y@sign,
  shift/y/signv2.1/.value required,
  rotate/.code={%
    \fca@append\fca@transform{%
      \pgftransformrotate{#1}%
    }%
  },
  solid/.code={%
    \fca@append\fca@options{%
      \pgfsetdash{}{0pt}%
    }%
  },%
  dotted/.code={%
    \fca@append\fca@options{%
      \pgfsetdash{{\pgflinewidth}{2pt}}{0pt}%
    }%
  },%
  loosely dotted/.code={%
    \fca@append\fca@options{%
      \pgfsetdash{{\pgflinewidth}{4pt}}{0pt}%
    }%
  },%
  densely dotted/.code={%
    \fca@append\fca@options{%
      \pgfsetdash{{\pgflinewidth}{4pt}}{0pt}%
    }%
  }%
}
\fcaset{%
  every label/.style = {
    text=pgfstrokecolor,
    /pgf/outer sep=0pt,
    /pgf/inner sep=0pt,
  }
}

\pgfqkeys{/fca/node}{%
  line width/.store in=\fca@node@thickness,
  line width/.value required,
  radius/.style={
    /pgf/inner sep=#1
  },
  color/.initial={},
  layer/.code=\fcalayer{node},%
  numbers/.is if=fca@CircledNumbers,
  number prefix/.store in=\fca@node@number@prefix,
  number prefix/.value required,
  number suffix/.store in=\fca@node@number@suffix,
  number suffix/.value required,
}

% Line thickness in standard \LaTeX{}:
% thin lines are .4pt
% thick lines are 0.8pt

% Dotted: \pgfsetdash{{\pgflinewidth}{2pt}}

\pgfqkeys{/fca/label}{%
  name prefix/.initial=\pgfkeysvalueof{/fca/namespace}\space node\space,
  name prefix/.value required,
  name suffix/.initial=\space\fca@label@type\space\fca@label@position,
  name suffix/.value required
  fill/.store in=\fca@node@fill,
  fill/.value required,
  text width/.store in=\fca@label@text@width,
  text width/.value required,
  node font/.initial={},
  node font/.value required,
  edge width/.store in=\fca@label@edge@width,
  edge width/.value required,
  at/.store in=\fca@label@at,
  at/.value required,
  type/.store in=\fca@label@type,
  type/.is choice,
  type/.append code={%
    \def\fca@label@type{#1}% the choice does not store the value
    \pgfqkeysalso{/fca}{every #1/.try}%
    \pgfqkeysalso{/fca/label}{\fca@label@type\space\fca@label@position}%
  },
  type/attributes/.style={},
  type/objects/.style={},
  position/.store in=\fca@label@position,
  position/.is choice,
  position/.append code={%
    \def\fca@label@position{#1}% the choice does not store the value
    \pgfqkeysalso{/fca/label}{\fca@label@type\space\fca@label@position}%
  },
  position/left/.style={},
  position/right/.style={},
  position/center/.style={},
  %
  attributes left/.style={
    at=north west,
    /fca/anchor=south east,
    /fca/shift={(-1pt,1pt)},
    /fca/shift/x/signv2.1=-,
    /fca/shift/y/signv2.1={},
    /fca/font/.append=\raggedleft
  },
  attributes center/.style={
    at=north,
    /fca/anchor=south,
    /fca/shift={(0,1pt)},
    /fca/shift/x/signv2.1={},
    /fca/shift/y/signv2.1={},
    /fca/font/.append=\centering
  },
  attributes right/.style={
    at=north east,
    /fca/anchor=south west,
    /fca/shift={(1pt,1pt)},
    /fca/shift/x/signv2.1={},
    /fca/shift/y/signv2.1={},
    /fca/font/.append=\raggedright
  },
  objects left/.style={
    at=south west,
    /fca/anchor=north east,
    /fca/shift={(-1pt,-1pt)},
    /fca/shift/x/signv2.1=-,
    /fca/shift/y/signv2.1=-,
    /fca/font/.append=\raggedleft
  },
  objects center/.style={
    at=south,
    /fca/anchor=north,
    /fca/shift={(0,-1pt)},
    /fca/shift/x/signv2.1={},
    /fca/shift/y/signv2.1=-,
    /fca/font/.append=\centering
  },
  objects right/.style={
    at=south east,
    /fca/anchor=north west,
    /fca/shift={(1pt,-1pt)},
    /fca/shift/x/signv2.1={},
    /fca/shift/y/signv2.1=-,
    /fca/font/.append=\raggedright
  }
}

\newcommand*\fca@tikz@without@library{%
  \PackageWarning{fca}{FCA TikZ integration is not activated.^^J
    You should consider \tikzlibrary{fca} instead of
    \string\usepackage{fca}
  }%
}

\AtBeginDocument{%
  \@ifundefined{tikz@color}{}{\fca@tikz@without@library}
}


\newcommand*{\fcaNodeThickness}[1]{%
  \fcaset{node/line width={#1}}%
  \ignorespaces
}% %
\newcommand*{\fcaEdgeThickness}[1]{%
  \fcaset{line width={#1}}%
  \ignorespaces
}
\newcommand*{\fcaNodeColor}[1]{%
  \pgfkeyssetvalue{/fca/node/color}{#1}%
  \ignorespaces
}%
\newcommand*{\fcaNumbers}{%
  \setboolean{fca@CircledNumbers}{true}%
}%
\newcommand*{\fcaNoNumbers}{%
  \setboolean{fca@CircledNumbers}{false}%
}%
\newcommand*{\fcaCircleSize}[1]{%
  \fcaset{every concept/.append style={radius=(#1)*0.5\unitlength}}%
  \ignorespaces
}%
\iffca@compat@macros
  \def\fcaObjectLabelStyle{\fcaObjectLabelStyle}%
  \def\fcaAttributeLabelStyle{\AttributeLabelStyle}%
  \def\fcaLabelBoxWidth{\LabelBoxWidth}%
  \def\EdgeThickness{\fcaEdgeThickness}%
  \def\NodeThickness{\fcaNodeThickness}%
  \def\NodeColor{\fcaNodeColor}%
  \def\Numbers{\fcaNumbers}%
  \def\noNumbers{\fcaNoNumbers}
  \def\CircleSize{\fcaCircleSize}%
  \def\NoDots{\fcaNoDots}
  \def\Dots{\fcaDots}
\fi
%    \end{macrocode}
% \iffcatikzdoc
% \begin{dtxexample}{Testing node  parameters}
% {\unitlength 1.2mm
% \definecolor{darkgreen}{rgb}{0.05,0.5,0.}
% \begin{diagram}
%  \Node[draw=red, fill=green,/tikz/line width=.5mm](1)(20,10)
%  \Node[fill=black, radius=2mm](2)(35,20)
%  \fcaCircleSize{10}%
%  \Node[opacity=0.3,fill=red](3)(5,30)
%  \fcaset{node/line width=2mm}
%  \NodeColor{darkgreen}
%  \Node(4)(35,40)
%  \fcaNodeColor{orange}
%  \Node[/tikz/rectangle](5)(20,50)
% \end{diagram}}
% \end{dtxexample}
% \fi
%
%    \begin{macrocode}
\newcounter{fca@minNode}%
\newcounter{fca@maxNode}%
\newcounter{fca@runNode}%
\newboolean{fca@CircledNumbers}%
\newcounter{fca@CircleDiameter}%
\newcounter{fca@AuxCounter}%
\newcounter{fca@BuxCounter}%
\def\fca@adjNode#1{%
  \ifthenelse{#1<\value{fca@minNode}}{\setcounter{fca@minNode}{#1}}{}%
  \ifthenelse{\value{fca@maxNode}<#1}{\setcounter{fca@maxNode}{#1}}{}}%
\newcommand\fca@node[1][]{%
  \@ifnextchar\bgroup{\fca@oldnode{#1}}{%
      \@ifnextchar({\fca@pictnode{#1}}{\fca@tikznode{#1}}%)
    }%
% \egroup
}
\newcommand\fca@typeset@node@content[1]{%
  \pgfkeysgetvalue{/fca/text width}\@tempa
  \edef\@tempb{\@tempa}%
  \expandafter\fca@testoption\expandafter{\@tempb}{%
    \def\fca@node@end@content{\end{minipage}}%
    \fca@parselength\@tempdima{\fca@tempa}\fca@xunitlength
    \begin{minipage}{\@tempdima}%
  }{%
    \let\fca@node@end@content\egroup
    \makebox\bgroup%
  }{%
    \let\fca@node@end@content\egroup
    \makebox\bgroup
  }%
  \pgfkeysvalueof{/fca/font}%
  \color{\pgfkeysvalueof{/fca/text}}%
  #1%
  \fca@node@end@content%
}
\newcommand\fca@oldnode[4]{%
  \begin{pgfscope}%
    \fcaset{shape=circle,
      line width=\fca@node@thickness}%
    \fcaset{every node/.try}%
    \pgfkeysgetvalue{/fca/node/color}{\fca@node@color}%
    \expandafter\fca@testoption\expandafter{\fca@node@color}{%
      \fca@append\fca@options{%
        \expandafter\pgfsetfillcolor\expandafter{\fca@node@color}%
      }%
      \fca@append\fca@usepath{fill,}%
    }{% none
    }{% empty or \pgfkeysnovalue
    }%
    \fcaset{every concept/.try}%
    \fcaset{#1}%
    \fca@nodeslayer
    \pgfkeysvalueof{/fca/node font}%
    \fca@parselength\@tempdima{#3}\unitlength
    \fca@parselength\@tempdimb{#4}\unitlength
    \pgftransformshift{\pgfpoint{\@tempdima}{\@tempdimb}}%
    \fca@options
    % \pgfsetstrokecolor{\fca@node@color}%
    \pgfnode{\pgfkeysvalueof{/fca/shape}}{center}{}{%
      \pgfkeysvalueof{/fca/name prefix}#2\pgfkeysvalueof{/fca/name suffix}%
    }{\expandafter\pgfusepath\expandafter{\fca@usepath}}%
    \fca@endnodeslayer
    \ifthenelse{\boolean{fca@CircledNumbers}}{%
      \fca@nodenumberslayer
      \def\fca@usepath{}%
      \fcaset{node number}%
      \fca@options
      \pgfnode{\pgfkeysvalueof{/fca/shape}}{center}{%
        \fca@typeset@node@content
        {%
          \centering
          \pgfkeysvalueof{/fca/font}%
          #2%
        }%
      }{%
        \pgfkeysvalueof{/fca/name prefix}#2\pgfkeysvalueof{/fca/name
          suffix} number%
      }{\expandafter\pgfusepath\expandafter{\fca@usepath}}%
      \fca@endnodenumberslayer
    }{}%
  \end{pgfscope}%
  \ignorespaces
}
\newcommand\fca@pictnode[1]{%
  \fca@parse@parenlabel{\fca@pictn@de{#1}}%
}
\newcommand\fca@pictn@de[2]{%
  \fca@parse@paren@vector{%
    \edef\fca@tempa{{\the\@tempdima}{\the\@tempdimb}}%
    \def\fca@tempb{\fca@oldnode{#1}{#2}}%
    \expandafter\fca@tempb\fca@tempa
  }\@tempdima\@tempdimb
}
\newcommand{\fca@edge}[1][]{%
  \@ifnextchar\bgroup{\fca@oldedge{#1}}{\fca@newedge{#1}}%
% \egroup
}
\newcommand\fca@newedge[1]{%
  \fca@parse@parenlabel{\fca@new@dge{#1}}%
}
\newcommand\fca@new@dge[2]{%
  \fca@parse@parenlabel{\fca@oldedge{#1}{#2}}%
}
%    \end{macrocode}
% \begin{dtxexample}{Testing lines}
% {\unitlength 1.2mm
% \definecolor{darkgreen}{rgb}{0.05,0.5,0.}
% \begin{diagram}
%  \Node(1)(20,10)
%  \Node(2)(35,20)
%  \Node(3)(5,30)
%  \Node(4)(35,40)
%  \Node(5)(20,50)
%  {\color{red}\Edge(1)(2)}
%  \Edge[draw=blue,dotted,line width=1mm](1)(3)
%  \Edge(2)(4)
%  \EdgeThickness{2mm}
%  \Edge[draw=green](3)(5)
%  \Edge(4)(5)
% \end{diagram}}
% \end{dtxexample}
%    \begin{macrocode}
\newcommand{\fca@oldedge}[3]{%
  \begin{pgfscope}%
    \fca@edgeslayer
    \fcaset{every edge/.try,#1}%
    \fca@options
    \fca@transform
    %\pgfsetlinewidth{\pgfkeysgetvalue{/fca/line width}}%
    \pgfpathmoveto{%
      \pgfpointshapeborder{%
        \pgfkeysvalueof{/fca/name prefix}#2\pgfkeysvalueof{/fca/name suffix}%%
      }{%
        \pgfpointanchor{%
          \pgfkeysvalueof{/fca/name prefix}#3\pgfkeysvalueof{/fca/name suffix}%%
        }{center}%
      }%
    }%
    \pgfpathlineto{%
      \pgfpointshapeborder{%
        \pgfkeysvalueof{/fca/name prefix}#3\pgfkeysvalueof{/fca/name suffix}%%
      }{%
        \pgfpointanchor{%
        \pgfkeysvalueof{/fca/name prefix}#2\pgfkeysvalueof{/fca/name suffix}%%
        }{center}%
      }%
    }%
    \pgfusepath{stroke}%
    \fca@endedgeslayer
  \end{pgfscope}%
  \ignorespaces
}
%
\def\fca@changeaValue#1#2#3{\setcounter{fca@AuxCounter}{#1}%
  \addtocounter{fca@AuxCounter}{#2}\def#3{\value{fca@AuxCounter}}}%
\def\fca@changebValue#1#2#3{\setcounter{fca@BuxCounter}{#1}%
  \addtocounter{fca@BuxCounter}{#2}\def#3{\value{fca@BuxCounter}}}%
\newcommand{\fcaNoDots}{\setboolean{fca@connectors}{false}}
\newcommand{\fcaDots}{\setboolean{fca@connectors}{true}}
%    \end{macrocode}
%\begin{dtxexample}{Testing nodots}
%   \begin{diagram}[text width=3.4cm]
%     \Node(0)(20,10)
%     \NoDots
%     \leftAttbox[draw](0)(-5,1){left\\ attribute\\ label}
%     \Dots
%     \rightAttbox[fill=red!50!blue!20](0)(10,10){right
%     attri-\\ bute label}
%     \fcaNoDots\centerObjbox(0)(0,-10){centered\\ object label}
%     \fcaDots
%     \rightObjbox[draw=brown](0)(20,5){right\\ object\\ label}
%   \end{diagram}
% \end{dtxexample}

%    \begin{macrocode}
\def\fca@parse@parenlabel#1(#2){#1{#2}}
\def\fca@parse@paren@vector#1#2#3(#4,#5){%
  \fca@parse@brace@vector{#1}{#2}{#3}{#4}{#5}%
}
%    \end{macrocode}
% \begin{macro}{\fca@parse@label}\marg{true material}\marg{else
%   material}\parg{label}
% \begin{macro}{\fca@parse@label}\marg{true material}\marg{else
%   material}\marg{label}
% \begin{macro}{\fca@parse@label}\marg{true material}\marg{else
%   material}
% The argument \meta{label} is parsed if it is given. In that case it
% is fed to \meta{true path} as ordinary argument. If it is not
% given, the code in \meta{else material} is executed.
%    \begin{macrocode}
\newcommand*\fca@parse@label[2]{%
  \@ifnextchar\bgroup{%\egroup
    #1%
  }{%
    \@ifnextchar(%)
    {%
      \fca@parse@parenlabel{#1}%
    }{%
      #2%
    }%
  }%
}
\newcommand*\fca@parse@vector[4]{%
  \@ifnextchar(%)
  {%
    \fca@parse@paren@vector{#1}{#3}{#4}%
  }{%
    \@ifnextchar\bgroup{%\egroup
      \fca@parse@brace@vector{#1}{#3}{#4}%
    }{#2}%
  }%
}
\newcommand*\fca@parse@brace@vector[5]{%
  \fca@parselength#2{#4}\fca@xunitlength
  \fca@parselength#3{#5}\fca@yunitlength
  #1%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@labelBox}\oarg{options}
% \begin{macro}{\fca@labelBox}\oarg{options}\marg{label}
% \begin{macro}{\fca@labelBox}\oarg{options}\marg{label}\marg{content}
% \begin{macro}{\fca@labelBox}\oarg{options}\marg{label}\marg{xoffset}\marg{yoffset}\marg{content}
% \begin{macro}{\fca@labelBox}\oarg{options}\marg{label}\parg{xoffset,yoffset}\marg{content}
% \begin{macro}{\fca@labelBox}\oarg{options}\parg{label}\marg{content}
% \begin{macro}{\fca@labelBox}\oarg{options}\parg{label}\parg{xoffset,yoffset}\marg{content}
% \begin{dtxexample}{Syntax test for labels}
%   {\unitlength 1.2mm\relax
%   \begin{diagram}{40}{55}
%     \Numbers
%     \Node{1}{20}{10}
%     \Node{2}{35}{20}
%     \Node{3}{5}{30}
%     \Node{4}{35}{40}
%     \Node{5}{20}{50}
%     \Edge{1}{2}
%     \Edge{1}{3}
%     \Edge{2}{4}
%     \Edge{3}{5}
%     \Edge{4}{5}
%     \fcaNoDots
%     \leftAttbox(1)(-5,4){also not connected}
%     \fcaDots
%     \rightAttbox[node=2,node contents={first}]
%     \rightAttbox[node contents=second]{4}
%     \leftObjbox{3}{third}
%     \rightObjbox{2}{2}{2}{fourth}
%     \rightObjbox{4}(2,2){fifth}
%     \leftAttbox(5){sixth}
%     \rightAttbox(5)(3,3){sevenths}
%     \rightAttbox[connector=false](1)(10,2){not connected}
%   \end{diagram}
% }
% \end{dtxexample}
%    \begin{macrocode}
\newcommand*\fca@labelBox[1][]{%
  \fca@parse@label{\fca@l@belBox{#1}}{\fca@@labelBox{#1}}%
}
\newcommand*\fca@l@belBox[2]{%
  \@ifnextchar\bgroup{%
    \fca@lab@lBox{#1}{#2}%
  }{%
    \@ifnextchar({%)
      \fca@parse@vector{%
        \def\fca@tempa{outer sep=1pt,#1,node=#2,shift=}%
        \edef\fca@tempb{{(\the\@tempdima,\the\@tempdimb)}}%
        \fca@concat\fca@tempa\fca@tempb%
        \@ifnextchar\bgroup{%
          \expandafter\fca@l@b@lBox\expandafter{\fca@tempa}%
        }{%
          \expandafter\fca@@labelBox\expandafter{\fca@tempa}%
        }%
      }{}{\@tempdima}{\@tempdimb}%
    }{%
      \fca@@labelBox{#1,node={#2}}%
    }%
  }%
}
\newcommand*\fca@lab@lBox[3]{%
  \@ifnextchar\bgroup{%
    \fca@parse@vector{%
      \@ifnextchar\bgroup{%
        \fca@oldlabelBox{#1,node=#2}{\the\@tempdima}{\the\@tempdimb}%
      }{%
        \fca@oldlabelBox{#1,node=#2}{\the\@tempdima}{\the\@tempdimb}{}%
      }%
    }{}{\@tempdima}{\@tempdimb}{#3}%
  }{%
    \fca@@labelBox{#1,node={#2},node contents={#3}}%
  }%
}
\newcommand*\fca@l@b@lBox[2]{%
  \fca@@labelBox{#1,node contents=#2}
}
\newcommand*\fca@label@shift@sign@{}%
\expandafter\newcommand\expandafter*\csname fca@label@shift@sign@+\endcsname[1]{+(#1)}
\expandafter\newcommand\expandafter*\csname fca@label@shift@sign@-\endcsname[1]{-(#1)}
\newcommand*\fca@addshiftsign[1]{%
  \expandafter\fca@@ddshiftsign\expandafter{\csname
  fca@label@shift@#1@sign\endcsname}
}
\newcommand*\fca@@ddshiftsign[1]{%
  \csname fca@label@shift@sign@#1\endcsname
}

\newcommand\fca@oldlabelBox[4]{%
  \def\fca@tempa{%
    #1,
    label/at=center,
    shift=
  }%
  \edef\fca@tempb{%
    {({\noexpand\fca@addshiftsign x{#2}},{\noexpand\fca@addshiftsign y{#3}})}%
  }%
  \expandafter\expandafter\expandafter\fca@@labelBox
  \expandafter\expandafter\expandafter{%
    \expandafter\fca@tempa
    \fca@tempb,
    node contents={#4}%
  }%
}
%    \end{macrocode}
%
% \begin{macro}{\fca@remove@anchor}\marg{point}
%   This macro removes the anchor part of a node name.
%    \begin{macrocode}
\newcommand\fca@remove@anchor[1]{%
  \fca@remove@anch@r#1.\fca@remove@anchor%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fca@remove@anch@r}
%
\def\fca@remove@anch@r#1.#2\fca@remove@anchor{#1}
%
% \end{macro}
%
% \begin{macro}{\fca@prepare@node}\marg{point}\marg{direction}\marg{prefix}\marg{suffix}\marg{node}
%
% This macro is used to find the correct anchor point and the point a
% vector from another node will likely point to. This follows the
% following logic: If \marg{node} is not passed in braces and contains
% a dot (|.|), then \marg{point} will contain a macro that crates a
% point pointing to some other |\pgfpoint| on the border of
% \marg{prefix}\marg{node}\marg{suffix}. And \marg{direction} will be
% the \marg{default anchor} of that node. Otherwise we assume that an
% anchor is given and we should draw lines directly from that
% anchor. So both macros \marg{point} and \marg{direction} will be
% defined to return the same point
% |\pgfpointanchor{|\marg{prefix}\marg{node
% name}\marg{suffix}|}{|\marg{node anchor}|}|.
%    \begin{macrocode}
\newcommand\fca@prepare@node[5]{%
  \def\@tempa{\fca@split@node@{#1}{#2}{#3}{#4}}%
  \edef\@tempb{#5.center.}%
  \fca@concat\@tempa{\@tempb\fca@split@node@}%
  \@tempa
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@split@node@}\marg{point}\marg{direction}\marg{prefix}\marg{suffix}\marg{node}|.|\marg{default
%   anchor}|.\fca@split@node@|
%
% This macro is called by \cs{fca@prepare@node}. It should not be
% called directly.
%
% This macro is used to find the correct anchor point and the point a
% vector from another node will likely point to. This follows the
% following logic: If \marg{node} is not passed in braces and contains
% a dot (|.|), then \marg{point} will contain a macro that crates a
% point pointing to some other |\pgfpoint| on the border of
% \marg{prefix}\marg{node}\marg{suffix}. And \marg{direction} will be
% the \marg{default anchor} of that node. Otherwise we assume that an
% anchor is given and we should draw lines directly from that
% anchor. So both macros \marg{point} and \marg{direction} will be
% defined to return the same point
% |\pgfpointanchor{|\marg{prefix}\marg{node
% name}\marg{suffix}|}{|\marg{node anchor}|}|.
%
%    \begin{macrocode}
\def\fca@split@node@#1#2#3#4#5.#6.#7\fca@split@node@{%
  \def\@tempa{#7}%
  \ifx\@tempa\empty\relax
    \def#1##1{\pgfpointshapeborder{#3#5#4}{##1}}%
  \else
    \def#1##1{\pgfpointanchor{#3#5#4}{#6}}%
  \fi
  \def#2{%
    \pgfpointanchor{#3#5#4}{#6}%
  }%
}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\def\fca@def@expanded@node#1#2#3#4{%
  \edef\@tempa{\noexpand\def\noexpand#1\noexpand\fca@node@full@node{#2}{#3}#4..\fca@node@fullnode}%
  \@tempa
}
%    \end{macrocode}
% \begin{macro}{\fca@node@anchor}\marg{node}|.|\marg{anchor}|\fca@node@anchor|
%   Create a pgfpoint from a string of the form |node.anchor| as in
%   \TikZ. The anchor must be given, no default can be defined.
%    \begin{macrocode}
\def\fca@node@anchor#1.#2\fca@node@anchor{%
  \pgfpointanchor{#1}{#2}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fca@node@border}\marg{node1}|,|\marg{node2}|.|\marg{anchor2}|.|\marg{garbage}|\fca@node@border|
% This macro finds the |\pgfpoint| on the border of \marg{node1} that
% goes towards \marg{node2}|.|\marg{anchor2}. The argument
% \marg{garbage} is thrown away. This allows to select a default
% anchor in case no anchor is given for the \marg{node2}.
%    \begin{macrocode}
\def\fca@node@border#1,#2.#3.#4\fca@node@border{%
  \pgfpointshapeborder{#1}{\pgfpointanchor{#2}{#3}}%
}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\newcommand\fca@calculate@edgepoint[3]{%
  \edef\@tempa{\noexpand\pfgutil@in@{.}{#2}}%
  \@tempa
  \ifpfgutil@in@
    \def#1{%
      \fca@node@anchor#2\fca@node@anchor
    }%
  \else
    \def#1{%
      \fca@node@border#2,#3.center.\fca@node@border
    }%
  \fi
}
%    \end{macrocode}
%
% \fcaset{conexpstyle/.style={%
%    every attributes/.append style={
%      label concept/.append style={
%        shape=semicircle,
%        fill=blue,
%        draw=black,
%        anchor=south,
%        outer sep=0pt,
%        minimum height=2\unitlength,
%        label/name suffix=attribute concept,
%        label/at=center,
%        solid
%      }
%    },
%    every objects/.append style={
%      label concept/.append style={
%      shape=semicircle,
%      outer sep=0pt,
%        fill=black,
%        draw=black,
%        anchor=south,
%        minimum height=2\unitlength,
%        label/name suffix=attribute concept,
%        label/at=center,
%        solid,
%        rotate=180
%      }
%    }}}
%
%\fbox{\unitlength 1.2mm
%  \definecolor{darkgreen}{rgb}{0.05,0.5,0.}
% \begin{diagram}
%  \Node[draw=red, fill=green](1)(20,10)
%  \Node[fill=black]{2}{35}{20}
%  \Node{3}{5}{30}
%  \Node[fill=darkgreen]{4}{35}{40}
%  \Node{5}{20}{50}
%  {\color{red}\Edge{1}{2}}
%  \Edge[draw=blue,dotted]{1}{3}
%  {\thicklines\Edge{2}{4}}
%  \Edge[draw=darkgreen](3)(5)
%  \Edge{4}{5}
%  \leftAttbox{3}{2}{2}{1}
%   \rightAttbox{2}{2}{2}{disqualified}
%  \rightAttbox{4}{2}{2}{2.}
%  \leftObjbox{3}{2}{2}{Verstappen}
%  \rightObjbox{2}{2}{2}{Leclerc}
%  \rightObjbox{4}{2}{2}{Hamilton}
%\end{diagram}
%
%\begin{diagram}[conexpstyle]
%  \Node(1)(20,10)
%  \Node(2)(35,20)
%  \Node(3)(5,30)
%  \Node(4)(35,40)
%  \Node(5)(20,50)
%  \Edge(1)(2)
%  \Edge(1)(3)
%  \Edge(2)(4)
%  \Edge(3)(5)
%  \Edge(4)(5)
%  \leftAttbox{3}{2}{2}{1}
%   \rightAttbox{2}{2}{2}{disqualified}
%  \rightAttbox{4}{2}{2}{2.}
%  \leftObjbox{3}{2}{2}{Verstappen}
%  \rightObjbox{2}{2}{2}{Leclerc}
%  \rightObjbox{4}{2}{2}{Hamilton}
%\end{diagram}
%}
%
% Using the style only for special nodes
%\fbox{\unitlength 1.2mm
%\begin{diagram}
%  \Node(1)(20,10)
%  \Node(2)(35,20)
%  \Node(3)(5,30)
%  \Node(4)(35,40)
%  \Node(5)(20,50)
%  \Edge(1)(2)
%  \Edge(1)(3)
%  \Edge(2)(4)
%  \Edge(3)(5)
%  \Edge(4)(5)
%  \leftAttbox[conexpstyle]{3}{2}{2}{1}
%  \rightAttbox[conexpstyle]{2}{2}{2}{disqualified}
%  \rightAttbox{4}{2}{2}{2.}
%  \leftObjbox[conexpstyle]{3}{2}{2}{Verstappen}
%  \rightObjbox{2}{2}{2}{Leclerc}
%  \rightObjbox[conexpstyle]{4}{2}{2}{Hamilton}
%\end{diagram}
%}
%
% \begin{diagram}[conexpstyle]
%   \Node(1)(20,10)
%   \Node(2)(35,20)
%   \Node(3)(5,30)
%   \Node(4)(35,40)
%   \Node(5)(20,50)
%   \Edge(1)(2)
%   \Edge(1)(3)
%   \Edge(2)(4)
%   \Edge(3)(5)
%   \Edge(4)(5)
%   \leftAttbox(3)(-20,20){1}
%   \rightAttbox(2)(20,20){disqualified}
%   \rightAttbox(4)(20,20){2.}
%   \leftObjbox(3)(-20,-2){Verstappen}
%   \rightObjbox(2)(2,-2){Leclerc}
%   \rightObjbox(4)(20,-2){Hamilton}
% \end{diagram}
%
% \begin{dtxexample}{testing label lines}
% \unitlength=1.2mm
% \begin{diagram}[conexpstyle]
%   \Node(1)(20,10)
%   \Node(2)(35,20)
%   \Node(3)(5,30)
%   \Node(4)(35,40)
%   \Node(5)(20,50)
%   \Edge(1)(2)
%   \Edge(1)(3)
%   \Edge(2)(4)
%   \Edge(3)(5)
%   \Edge(4)(5)
%   \leftAttbox(3)(-20,20){1}
%   \rightAttbox[draw,line width=1mm](2)(20,20){disqualified}
%   \rightAttbox[label/edge width=1mm](4)(20,20){2.}
%   \leftObjbox(3)(-20,-2){Verstappen}
%   \rightObjbox[draw](2)(2,-2){Leclerc}
%   \fcaset{label/edge width=2mm}
%   \rightObjbox[draw](4)(20,-2){Hamilton}
% \end{diagram}
% \end{dtxexample}
% Notice the dependency between the connector lines and the
% border of the attribute and object concepts. These are the reason
% why the macros from
%
%    \begin{macrocode}
\newcommand\fca@@labelBox[1]{%
  \begin{pgfscope}%
    \fcaset{every node/.try,
      node font=\pgfkeysvalueof{/fca/label/node font},
      every label/.try,#1}%
    \fca@labelslayer
    \pgfkeysvalueof{/fca/node font}%
    \fca@options
    \edef\@tempa{\pgfkeysvalueof{/fca/pgfnode}}%
    \xdef\fca@temp@node@name{%
      \expandafter\fca@remove@anchor\expandafter{\@tempa}%
    }%
    \pgftransformshift{%
      \pgfpointanchor{%
        \fca@temp@node@name
      }{\fca@label@at}%
    }%
    \fca@parselength\@tempdima{\fca@label@shift@x}\unitlength
    \fca@parselength\@tempdimb{\fca@label@shift@y}\unitlength
    \pgftransformshift{\pgfpoint{\@tempdima}{\@tempdimb}}%
    \fca@transform
    \pgfnode{rectangle}{\pgfkeysvalueof{/fca/anchor}}{%
      \fca@typeset@node@content
      {%
        \pgfkeysvalueof{/fca/node contents}%
      }%
    }{%
      \pgfkeysvalueof{/fca/label/name prefix}%
      \pgfkeysvalueof{/fca/node}%
      \pgfkeysvalueof{/fca/label/name suffix}%
    }{%
      \expandafter\pgfusepath\expandafter{\fca@usepath}%
    }%
    \fca@endlabelslayer
    % pin edge
    \iffca@connectors
      \fca@connectorslayer
      \pgftransformreset
      \let\fca@options\fca@defaultoptions
      \fcaset{%
        line width=\fca@label@edge@width
      }
      \fcaset{every label edge/.try}%
      \fcaset{#1}%
      \fca@options
      \fca@transform
      %\pgfsetlinewidth{\pgfkeysgetvalue{/fca/line width}}%
      \fca@prepare@node\fca@temp@start@point\fca@temp@start@point@{}{}{\pgfkeysvalueof{/fca/pgfnode}}%
      \fca@prepare@node\fca@temp@end@point\fca@temp@end@point@
      {\pgfkeysvalueof{/fca/label/name prefix}}%
      {\pgfkeysvalueof{/fca/label/name suffix}}%
      {\pgfkeysvalueof{/fca/node}.\pgfkeysvalueof{/fca/anchor}}%
      \pgfpathmoveto{\fca@temp@start@point\fca@temp@end@point@}%
      \pgfpathlineto{\fca@temp@end@point\fca@temp@start@point@}%
      \pgfusepath{stroke}%
      \fca@endconnectorslayer
    \fi
    % overlay concept
    \pgftransformreset
    \let\fca@options\fca@defaultoptions
    \pgfsetdash{}{0pt}%
    \fcaset{shape=coordinate,#1}%
    \fcaset{every label concept/.try}%
    \fcaset{label concept/.try}%
    \ifx\pgfkeysvalueof{/fca/shape}\pgfkeysnovalue
    \else
      \fca@labelconceptslayer
      \pgftransformshift{%
        \pgfpointanchor{%
          \fca@temp@node@name
        }{\fca@label@at}%
      }%
      \fca@transform
      \fca@options
      % \pgfsetstrokecolor{\fca@node@color}%
      \pgfnode{\pgfkeysvalueof{/fca/shape}}{\pgfkeysvalueof{/fca/anchor}}{}{%
        \pgfkeysvalueof{/fca/label/name prefix}%
        \pgfkeysvalueof{/fca/node}%
        \pgfkeysvalueof{/fca/label/name suffix}%
      }{\expandafter\pgfusepath\expandafter{\fca@usepath}}%
      \fca@endlabelconceptslayer
    \fi
  \end{pgfscope}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \changes{2.2}{2022/09/12}{Rename \cs{ColorNode} into \cs{fcaColorNode}}
%    \begin{macrocode}
\newcommand\fca@leftAttbox[1][]{%
  \fca@labelBox[label type=attributes,label position=left,#1]
}
\newcommand\fca@centerAttbox[1][]{%
  \fca@labelBox[label type=attributes,label position=center,#1]
}
\newcommand\fca@rightAttbox[1][]{%
  \fca@labelBox[label type=attributes,label position=right,#1]
}
\newcommand\fca@leftObjbox[1][]{%
  \fca@labelBox[label type=objects,label position=left,#1]
}
\newcommand\fca@centerObjbox[1][]{%
  \fca@labelBox[label type=objects,label position=center,#1]
}
\newcommand\fca@rightObjbox[1][]{%
  \fca@labelBox[label type=objects,label position=right,#1]
}
%
\def\fca@ResetDefaults{\setcounter{fca@minNode}{60}%
  \setcounter{fca@maxNode}{0}%
  \setcounter{fca@CircleDiameter}{4}%
  \setboolean{fca@CircledNumbers}{false}%
  \fca@Defaults}%
%
\def\fcaColorNode#1{{%
    \PackageWarning{fca}{The \string\ColorNode\space macro is
      deprecated.^^J
      Use `\string\Node[fill=#1]` instead}
    \linethickness{\fca@node@thickness}%
    \color{#1}{\circle*{\value{fca@CircleDiameter}}}%
    \color{black}{\circle{\value{fca@CircleDiameter}}}}}%
%
\def\fca@circle{{%
    \linethickness{\fca@node@thickness}%
    \color{\fca@node@fill}{\circle*{\value{fca@CircleDiameter}}}%
    \color{black}{\circle{\value{fca@CircleDiameter}}}}}%
%
\def\fca@DrawCircles{\setcounter{fca@runNode}{\value{fca@minNode}}%
  \stepcounter{fca@maxNode}%
  \whiledo{\value{fca@runNode}<\value{fca@maxNode}}%
  {\fca@getNode{\value{fca@runNode}}%
    \put(\fca@x,\fca@y){\fca@circle}%
    \ifthenelse{\boolean{fca@CircledNumbers}}%
    {\put(\fca@x,\fca@y){\makebox(0,0){\tiny\arabic{fca@runNode}}}}{}%
    \stepcounter{fca@runNode}}}%
%

\newcommand*\fca@setb@undingbox{%
}%
\newcommand*\fca@ignoreboundingbox{}%

% set bounding box using brace notation
\newcommand*\fca@olddiagram[2]{%
  \fca@parselength\@tempdima{#1}\unitlength
  \edef\fca@right@border{\the\@tempdima}%
  \fca@parselength\@tempdimb{#2}\unitlength
  \edef\fca@top@border{\the\@tempdimb}%
  \let\fca@boundingbox\fca@setboundingbox
  \fca@parselength\@tempdima{-(\fcaDiagramXoffset)}\unitlength%
  \edef\fca@left@border{\the\@tempdima}%
  \fca@parselength\@tempdima{-(\fcaDiagramYoffset)}\unitlength%
  \edef\fca@bottom@border{\the\@tempdima}%
  \fca@startdiagram
  \fca@setboundingbox{\fca@left@border}{\fca@bottom@border}
  {\fca@right@border}{\fca@top@border}%
}
\newcommand*\fca@diagram{%
  \@ifnextchar(\fca@diagr@m\fca@di@gram
% )
}
% set bounding box using parentheses
\newcommand*\fca@diagr@m{%(#1,#2)
  \PackageError{fca}{not implemented}{not implemented}%
}
% set bounding box using defaults
\newcommand*\fca@di@gram{%
  \fca@startdiagram
}
\newcommand*\fca@startdiagram{%
  \fca@begindiagram
  \fca@Defaults
}
\newcommand*\fca@setboundingbox[4]{%
  \pgfpathrectangle{\pgfpoint{#1}{#2}}{\pgfpoint{#3}{#4}}%
  \pgfusepath{use as bounding box}%
}
% \todo{Lattice diagrams inside pgf pictures should be drawn inside
% their own scope}
\newenvironment{diagram}[1][]
{%
  \ifpgfpicture
    \def\fca@begindiagram{%
      \begin{pgfscope}%
        \fcaset{#1}%
        \unitlength=\dimexpr\pgf@xx+\pgf@yx\relax
        \def\fca@enddiagram{%
          \end{pgfscope}%
        }%
    }%
  \else
    \def\fca@begindiagram{%
      \begin{pgfpicture}%
        \fcaset{#1}%
        \def\fca@enddiagram{\end{pgfpicture}}%
    }%
  \fi
  \noindent
  \@ifnextchar\bgroup\fca@olddiagram\fca@diagram% This line must be
                                % executed before \begin{pgfpicture}
}%
{%
  %\fca@DrawCircles
  \fca@enddiagram%
}%
%    \end{macrocode}
% \changes{2.2}{2022/05/06}{Rename \cs{EdgeThickness} to
% \cs{fcaEdgeThickness} and \cs{NodeThickness} to \cs{fcaNodeThickness}}
%
% \iffalse
%</fca.sty>
%<*tikz>
% \fi
%
% \begin{environment}{tikzdiagram}
%   This environment places a diagram in a \TikZ{} picture.
%    \begin{macrocode}
\newenvironment{tikzdiagram}[1][]{%
  \def\fca@begindiagram{%
    \begin{tikzpicture}%
      \fcaset{#1}%
      \unitlength=\dimexpr\pgf@xx+\pgf@yx\relax
    }%
    \noindent
    \@ifnextchar\bgroup\fca@olddiagram\fca@diagram% This line must be
    % executed before \begin{pgfpicture}
  }{%
  \end{tikzpicture}%
}
%    \end{macrocode}
% \end{environment}
% \iffalse
%</tikz>
%<*fca.sty>
% \fi
% End of diagram environment definition.
%
%
%
% \subsection{Some simple macros for FCA texts}
%
%
%    \begin{macrocode}
\providecommand{\GMI}{(G,M,\relI)}
\newcommand{\context}[1][K]{\ensuremath{\mathbb{#1}}}
\providecommand{\'}{\ensuremath{\sp\prime}}% derivation operator
\providecommand{\extent}[1]{\textrm{ext}(#1)}
\providecommand{\intent}[1]{\textrm{int}(#1)}
\providecommand{\extents}[1]{\textrm{Ext}(#1)}
\providecommand{\intents}[1]{\textrm{Int}(#1)}
\providecommand{\BV}{\underline{{\mathfrak B}}}
\providecommand{\CL}{\BV}
\providecommand{\BGMI}{{\mathfrak B} (G,M,\relI)}
\providecommand{\CGMI}{\BGMI}
\providecommand{\BVGMI}{\BV (G,M,\relI)}
\providecommand{\CLGMI}{\BVGMI}
\providecommand{\HNI}{(H,N,\relI \cap\; H{\times}N)}
\providecommand{\relI}{\mathrel{I}}
\providecommand{\notI}{\mathrel{\mbox{\rlap{\char'40}%
      {\it I}\hspace*{-0.09em}\raisebox{.27ex}{\char'40}}}}%
%
\providecommand{\bigtimes}{\mathop{%
    \mathchoice{\raisebox{-2pt}{\huge$\times$}}{\mbox{\LARGE$\times$}}%
    {\raisebox{0pt}{\Large$\times$}}{\times}}\displaylimits}%
%
\providecommand{\Runterpfeil}{\mathrel{\swarrow}}
\providecommand{\DownArrow}{\Runterpfeil}
\providecommand{\Hochpfeil}{\mathrel{\nearrow}}
\providecommand{\UpArrow}{\Hochpfeil}
\providecommand{\IRunterpfeil}{\mathrel{\searrow}}
\providecommand{\IDownArrow}{\IRunterpfeil}
\providecommand{\IHochpfeil}{\mathrel{\nwarrow}}
\providecommand{\IUpArrow}{\IHochpfeil}
\providecommand{\Doppelpfeil}{\mathrel{\!\!\rlap{$\;\nearrow$}\swarrow}}
\providecommand{\DoubleArrow}{\Doppelpfeil}
%
\newcommand{\DDPfeil}{\mathrel{\mathchoice%
    {\mbox{$\displaystyle\swarrow\hspace{-.7em}\swarrow$}}
    {\mbox{$\textstyle\swarrow\hspace{-.7em}\swarrow$}}
    {\mbox{$\scriptstyle\swarrow\hspace{-.5em}\swarrow$}}
    {\mbox{$\scriptscriptstyle\swarrow\hspace{-.35em}\swarrow$}}}}
%
\newcommand{\NDDPfeil}{\mathrel{\mathchoice%
    {\mbox{$\displaystyle\swarrow\hspace{-.7em}\swarrow%
        \hspace{-1.2em}\backslash\hspace{.4em}$}}
    {\mbox{$\textstyle\swarrow\hspace{-.7em}\swarrow
        \hspace{-1.1em}\backslash\hspace{.4em}$}}
    {\mbox{$\scriptstyle\swarrow\hspace{-.5em}\swarrow
        \hspace{-.6em}\backslash\hspace{.2em}$}}
    {\mbox{$\scriptscriptstyle\swarrow\hspace{-.35em}\swarrow
        \hspace{-.5em}\backslash\hspace{.1em}$}}}}
%
\providecommand{\DPfeil}{\DDPfeil}
\providecommand{\NDPfeil}{\NDDPfeil}
\newcommand{\DDArrow}{\DDPfeil}
\newcommand{\NDDArrow}{\NDDPfeil}
\providecommand{\Semi}{\mathrel{\mbox{\tiny\rlap{\raisebox{2.0ex}%
        {$\bigtriangledown$}}\raisebox{-0.0ex}{$\bigtriangleup$}}}}
\def\ovee{\mbox{\small$\mathrel{\hspace{.35em}\raisebox{-1pt}%
      {$\smash{\vee}$}\hspace*{-.835em}\bigcirc\hspace{.2em}}$}}
\def\owedge{\mbox{\small$\mathrel{\hspace{.35em}\smash{\wedge}%
      \hspace*{-.835em}\bigcirc\hspace{.2em}}$}}
%
\providecommand{\ptimes}[1]{\mathrel{\stackrel{#1}{\times}}}
%
\providecommand{\FCA}{Formal Concept Analysis\xspace}
\providecommand{\FBA}{Formale Begriffsanalyse\xspace}
\providecommand{\FnBA}{Formalen Begriffsanalyse\xspace}
%    \end{macrocode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
% End of fca.sty style file definitions                                       %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \iffalse
%    \begin{macrocode}
%</fca.sty>
%    \end{macrocode}
% \fi
% \section{The PGF Coordinate system}
% \begin{pgfpicture}%
%   \pgfmoveto{\pgfpoint{0}{0}}%
%   \pgflineto{\pgfpoint{1cm}{0}}%
%   \pgfmoveto{\pgfpoint{0}{0}}%
%   \pgflineto{\pgfpoint{0}{1cm}}%
% {%
%   \pgftransformshift{\pgfpoint{1cm}{0}}%
%   \pgfnode{rectangle}{west}{(1,0)}{x}{\pgfusepath{stroke}}%
% }{%
%   \pgftransformshift{\pgfpoint{0}{1cm}}%
%   \pgfnode{rectangle}{south}{(0,1)}{y}{\pgfusepath{stroke}}%
% }%
% \end{pgfpicture}
% \iffalse
%    \begin{macrocode}
%<*formula1.cxt>
%    \end{macrocode}
% \fi
% \section{Formal contexts for demonstrating \cs{cxtinput}}
% The following formal context file is saved as \filenm{formula1.dtx}
% in the documentation folder.
%    \begin{macrocode}
B
Formula 1
3
3

Verstappen
Hamilton
Leclerc
1.
2.
disqualified
X..
.X.
.XX
%    \end{macrocode}
% \iffalse
%    \begin{macrocode}
%</formula1.cxt>
%<*formula0.cxt>
%    \end{macrocode}
% \fi
%    \begin{macrocode}
B

3
3

Verstappen
Hamilton
Leclerc
1.
2.
disqualified
X..
.X.
.XX
%    \end{macrocode}
% \iffalse
%    \begin{macrocode}
%</formula0.cxt>
%    \end{macrocode}
% \fi
% \Finale
% \PrintChanges
%
% \endinput
% Local Variables:
% mode: doctex
% TeX-master: t
% End:
